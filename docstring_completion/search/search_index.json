{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to AeroMAPS Documentation !","text":"<p>AeroMAPS is a framework for performing Multidisciplinary Assessment of Prospective Scenarios for air transport. For  instance, it allows simulating and analyzing scenarios for reducing aviation climate impacts through various levers of  action. It is intended to become a sectoral Integrated Assessment Model (IAM) taking into account technological,  environmental, sociological, economic and other considerations. It aims to assess the sustainability of simulated air  transport transition scenarios on multiple criteria.</p> <p>The objective of this documentation is to provide the main elements concerning AeroMAPS.</p> <p>In particular, see: - API Reference \u2014 understanding the intended use of user-facing functions and classes. - AeroMAPS Models \u2014 details on each model used by the framework. - User documentation \u2014 general principles of AeroMAPS, including example applications.  </p>"},{"location":"#about-aeromaps","title":"About AeroMAPS","text":"<p>AeroMAPS, formerly CAST published in 2021, is an open-source framework developed in Python by ISAE-SUPAERO (Toulouse,  France). It is also fed by multiple multidisciplinary works from the Institute for Sustainable Aviation (ISA). Providing a free framework that researchers, organizations, authorities and companies can interact with for defining sustainable aviation prospective scenarios was the initial main motivation.</p>"},{"location":"#license","title":"License","text":"<p>This file is part of AeroMAPS.</p> <p>AeroMAPS is free software: you can redistribute it and/or modify it under the terms of the GNU General Public  License as published by the Free Software Foundation, either version 3 of the License, or (at your option)  any later version.</p> <p>AeroMAPS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for  more details.</p> <p>You should have received a copy of the GNU General Public License along with AeroMAPS.  If not, see https://www.gnu.org/licenses/.</p>"},{"location":"#authors","title":"Authors","text":"<ul> <li>Thomas Plan\u00e8s, Associate Professor at ISAE-SUPAERO</li> <li>Scott Delbecq, Associate Professor at ISAE-SUPAERO</li> <li>Antoine Salgas, postdoctoral researcher at ISAE-SUPAERO and the Institute for Sustainable Aviation (ISA)</li> <li>F\u00e9lix Pollet, postdoctoral researcher at ISAE-SUPAERO and the Institute for Sustainable Aviation (ISA)</li> </ul>"},{"location":"#citations","title":"Citations","text":"<p>Please cite this article when using AeroMAPS in your research works:</p> <p>Plan\u00e8s, T., Delbecq, S., Salgas, A. (2023). AeroMAPS: a framework for performing multidisciplinary assessment of prospective scenarios for air transport. Submitted to Journal of Open Aviation Science.</p> <pre><code>@article{planes2023aeromaps,\n  title={AeroMAPS: a framework for performing multidisciplinary assessment of prospective scenarios for air transport},\n  author={Plan{\\`e}s, Thomas and Delbecq, Scott and Salgas, Antoine},\n  journal={Journal of Open Aviation Science},\n  volume={1},\n  number={1},\n  year={2023}\n}\n\n</code></pre> <p>Other publications from our research group that describe specific methods and models implemented in AeroMAPS can be found in the References section of the documentation.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>The authors would like to thank the following people who contributed to the development of AeroMAPS versions: Bastien Pa\u00efs, Laurent  Joly, Val\u00e9rie Pommier-Budinger, Florian Simatos, Alice Fabre, Martin Delavenne and Emmanuel B\u00e9nard.</p>"},{"location":"#contact","title":"Contact","text":"<p>aeromaps@isae-supaero.fr</p> <p>This site is built with MkDocs and mkdocstrings.</p>"},{"location":"api/","title":"API Reference","text":"<p>This section documents the AeroMAPS Python API, covering only user-facing functions and classes.</p> <p>All user-facing execution is performed through an AeroMAPSProcess object.  Some configuration files operations can also be executed through utility functions, also described by this API. </p> <p>Nota bene</p> <p>A full description of the whole AeroMAPS package, including disciplinary models implemented in AeroMAPS can be found in the AeroMAPS Models section of the documentation.</p>"},{"location":"api/aeromaps.core.models/","title":"<code>aeromaps.core.models</code>","text":"<p>This module creates dictionaries of default models for various AeroMAPS configurations.</p>"},{"location":"api/aeromaps.core.process/","title":"<code>aeromaps.core.process</code>","text":"<p>High-level AeroMAPS process orchestration.</p> <p>This module defines the main process class that orchestrates parameter initialization, model instantiation, GEMSEO configuration, generic energy carrier handling, and data export for the AeroMAPS framework.</p>"},{"location":"api/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess","title":"AeroMAPSProcess","text":"<pre><code>AeroMAPSProcess(configuration_file=None, models=default_models_top_down, use_fleet_model=False, add_examples_aircraft_and_subcategory=True, optimisation=False)\n</code></pre> <p>               Bases: <code>object</code></p> <p>High-level AeroMAPS process driver.</p> <p>This class configures parameters, instantiates discipline models, builds GMESEO objects, handles generic energy carrier pathways, and manages input and output data structures for AeroMAPS studies.</p> <p>Parameters:</p> Name Type Description Default <code>configuration_file</code> <p>Path to a configuration JSON file overriding default settings.</p> <code>None</code> <code>models</code> <p>Dictionary of model instances to be used in the process.</p> <code>default_models_top_down</code> <code>use_fleet_model</code> <p>Whether to instantiate and use the bottom-up fleet model.</p> <code>False</code> <code>add_examples_aircraft_and_subcategory</code> <p>Whether to populate the fleet with example aircraft and subcategories when the fleet model is used.</p> <code>True</code> <code>optimisation</code> <p>Whether to configure GEMSEO for optimisation instead of a pure MDA chain.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>configuration_file</code> <p>Path of the active configuration JSON file.</p> <code>use_fleet_model</code> <p>Flag indicating if the bottom-up fleet model is used.</p> <code>models</code> <p>Dictionary of discipline and auxiliary models used in the process.</p> <code>parameters</code> <p>Central parameter container used by all models and disciplines.</p> <code>disciplines</code> <p>List of wrapped discipline objects used by GEMSEO or the MDA chain.</p> <code>data</code> <p>Dictionary storing structured inputs and outputs, including scalar, string, vector, climate, and LCA results.</p> <code>json</code> <p>Dictionary reserved for JSON-compatible representations of results.</p> <code>add_examples_aircraft_and_subcategory</code> <p>Flag controlling insertion of example fleet content.</p> <code>mda_chain</code> <p>GEMSEO MDAChain instance used when running pure MDA analyses.</p> <code>scenario</code> <p>GEMSEO scenario instance for conventional MDO.</p> <code>scenario_adapted</code> <p>GEMSEO scenario of scenario instance for the bilevel optimization problem.</p> <code>gemseo_settings</code> <p>Dictionary containing all GEMSEO-related configuration options.</p> <code>fleet</code> <p>Fleet instance when the bottom-up fleet model is activated, else None.</p> <code>fleet_model</code> <p>FleetModel instance wrapping the fleet when the bottom-up model is used.</p> <code>energy_resources_data</code> <p>Parsed configuration data for generic energy resources.</p> <code>energy_processes_data</code> <p>Parsed configuration data for generic energy processes.</p> <code>energy_carriers_data</code> <p>Parsed configuration data for aviation energy carrier pathways.</p> <code>pathways_manager</code> <p>EnergyCarrierManager instance describing available energy pathways.</p> <code>climate_historical_data</code> <p>Historical climate dataset used by climate-related models.</p> <p>Initialize an AeroMAPSProcess instance.</p> <p>This method loads configuration settings, initializes parameters, deep-copies the provided models dictionary when needed, and performs the common setup. It then configures either an MDA chain or an optimization scenario depending on the specified mode.</p> <p>Parameters:</p> Name Type Description Default <code>configuration_file</code> <p>Path to a configuration JSON file overriding default settings.</p> <code>None</code> <code>models</code> <p>Dictionary of model instances to be used in the process.</p> <code>default_models_top_down</code> <code>use_fleet_model</code> <p>Whether to instantiate and use the bottom-up fleet model.</p> <code>False</code> <code>add_examples_aircraft_and_subcategory</code> <p>Whether to populate the fleet with example aircraft and subcategories when the fleet model is used.</p> <code>True</code> <code>optimisation</code> <p>Whether to configure GEMSEO for optimization instead of a pure MDA chain.</p> <code>False</code> Source code in <code>aeromaps/core/process.py</code> <pre><code>def __init__(\n    self,\n    configuration_file=None,\n    models=default_models_top_down,\n    use_fleet_model=False,\n    add_examples_aircraft_and_subcategory=True,\n    optimisation=False,\n):\n    \"\"\"Initialize an AeroMAPSProcess instance.\n\n    This method loads configuration settings, initializes parameters,\n    deep-copies the provided models dictionary when needed, and\n    performs the common setup. It then configures either an MDA chain\n    or an optimization scenario depending on the specified mode.\n\n    Parameters\n    ----------\n    configuration_file\n        Path to a configuration JSON file overriding default\n        settings.\n    models\n        Dictionary of model instances to be used in the process.\n    use_fleet_model\n        Whether to instantiate and use the bottom-up fleet model.\n    add_examples_aircraft_and_subcategory\n        Whether to populate the fleet with example aircraft and\n        subcategories when the fleet model is used.\n    optimisation\n        Whether to configure GEMSEO for optimization instead of a\n        pure MDA chain.\n    \"\"\"\n    self.configuration_file = configuration_file\n    self._initialize_configuration()\n    self.use_fleet_model = use_fleet_model\n\n    # Recopy models to avoid shared state between instances.\n    # For specific models that would be too heavy to deepcopy, set attribute `deepcopy_at_init` to False.\n    # E.g., models that load large datasets that are read-only (c.f. LCA model).\n    self.models = {\n        k: deepcopy(v) if getattr(v, \"deepcopy_at_init\", True) else v for k, v in models.items()\n    }\n\n    # Initialize inputs\n    self._initialize_inputs()\n\n    self.common_setup(add_examples_aircraft_and_subcategory)\n    if not optimisation:\n        self.setup_mda()\n    else:\n        self.setup_optimisation()\n</code></pre>"},{"location":"api/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.common_setup","title":"common_setup","text":"<pre><code>common_setup(add_examples_aircraft_and_subcategory)\n</code></pre> <p>Perform common setup steps independent of analysis type.</p> <p>This method initializes the disciplines list, the main data container, and JSON storage, and computes index structures and climate data. It also stores the flag indicating whether to add example aircraft and subcategories to the fleet.</p> Warning <p>This method should be called only if end year was modified, otherwise it is called in init.</p> <p>Parameters:</p> Name Type Description Default <code>add_examples_aircraft_and_subcategory</code> <p>Whether to populate the fleet with example aircraft and subcategories when the fleet model is used.</p> required Source code in <code>aeromaps/core/process.py</code> <pre><code>def common_setup(self, add_examples_aircraft_and_subcategory):\n    \"\"\"Perform common setup steps independent of analysis type.\n\n    This method initializes the disciplines list, the main data\n    container, and JSON storage, and computes index structures and\n    climate data. It also stores the flag indicating whether to add\n    example aircraft and subcategories to the fleet.\n\n    Warning\n    ---------\n    This method should be called only if end year was modified, otherwise it is called in __init__.\n\n    Parameters\n    ----------\n    add_examples_aircraft_and_subcategory\n        Whether to populate the fleet with example aircraft and\n        subcategories when the fleet model is used.\n    \"\"\"\n    self.disciplines = []\n    self.data = {}\n    self.json = {}\n    self._initialize_data()\n    self.add_examples_aircraft_and_subcategory = add_examples_aircraft_and_subcategory\n</code></pre>"},{"location":"api/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.setup_mda","title":"setup_mda","text":"<pre><code>setup_mda()\n</code></pre> <p>Configure the process for a standalone MDA chain.</p> <p>This method initializes generic energy inputs and disciplines, then builds a GEMSEO MDAChain with default convergence settings for multidisciplinary analysis execution of AeroMAPS.</p> Warning <p>This method should be called only if end year was modified, otherwise it is called in init.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def setup_mda(self):\n    \"\"\"Configure the process for a standalone MDA chain.\n\n    This method initializes generic energy inputs and disciplines,\n    then builds a GEMSEO MDAChain with default convergence settings\n    for multidisciplinary analysis execution of AeroMAPS.\n\n    Warning\n    ---------\n    This method should be called only if end year was modified, otherwise it is called in __init__.\n    \"\"\"\n    # Initialize energy carriers\n    self._initialize_generic_energy()\n\n    self._initialize_disciplines(self.add_examples_aircraft_and_subcategory)\n\n    self.mda_chain = MDAChain(\n        disciplines=self.disciplines,\n        tolerance=1e-5,\n        initialize_defaults=True,\n        inner_mda_name=\"MDAGaussSeidel\",\n        log_convergence=True,\n    )\n</code></pre>"},{"location":"api/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.setup_optimisation","title":"setup_optimisation","text":"<pre><code>setup_optimisation()\n</code></pre> <p>Configure the process for GEMSEO-based optimization.</p> <p>This method initializes the internal GEMSEO settings dictionary so that optimization scenarios can be defined and executed later.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def setup_optimisation(self):\n    \"\"\"Configure the process for GEMSEO-based optimization.\n\n    This method initializes the internal GEMSEO settings dictionary\n    so that optimization scenarios can be defined and executed later.\n    \"\"\"\n    self._initialize_gemseo_settings()\n</code></pre>"},{"location":"api/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.create_gemseo_scenario","title":"create_gemseo_scenario","text":"<pre><code>create_gemseo_scenario()\n</code></pre> <p>Build a single-level GEMSEO MDO scenario.</p> <p>This method initializes generic energy inputs and disciplines, and then creates a GEMSEO scenario using the current <code>gemseo_settings</code> for objective, design space, scenario type, and formulation.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def create_gemseo_scenario(self):\n    \"\"\"Build a single-level GEMSEO MDO scenario.\n\n    This method initializes generic energy inputs and disciplines,\n    and then creates a GEMSEO scenario using the current\n    ``gemseo_settings`` for objective, design space, scenario type,\n    and formulation.\n    \"\"\"\n    self._initialize_generic_energy()\n    self._initialize_disciplines(self.add_examples_aircraft_and_subcategory)\n\n    self.scenario = create_scenario(\n        disciplines=self.disciplines,\n        objective_name=self.gemseo_settings[\"objective_name\"],\n        design_space=self.gemseo_settings[\"design_space\"],\n        scenario_type=self.gemseo_settings[\"scenario_type\"],\n        formulation_name=self.gemseo_settings[\"formulation\"],\n        main_mda_settings={\n            \"inner_mda_name\": \"MDAGaussSeidel\",\n            \"max_mda_iter\": 12,\n            \"initialize_defaults\": True,\n            \"tolerance\": 1e-4,\n        },\n        # grammar_type=self.gemseo_settings[\"grammar_type\"],\n        # input_data=self.input_data,\n    )\n</code></pre>"},{"location":"api/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.create_gemseo_bilevel","title":"create_gemseo_bilevel","text":"<pre><code>create_gemseo_bilevel()\n</code></pre> <p>Build a GEMSEO bilevel optimization formulation.</p> <p>This method wraps an inner GEMSEO scenario in an <code>MDOScenarioAdapter</code> and creates an outer scenario that optimizes over the adapter. If the inner scenario is not yet defined, it is created using the current <code>gemseo_settings</code>.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def create_gemseo_bilevel(self):\n    \"\"\"Build a GEMSEO bilevel optimization formulation.\n\n    This method wraps an inner GEMSEO scenario in an\n    ``MDOScenarioAdapter`` and creates an outer scenario that\n    optimizes over the adapter. If the inner scenario is not yet\n    defined, it is created using the current ``gemseo_settings``.\n    \"\"\"\n    # if no scenario is created raise an error create_gemseo_scenario needs to be called first\n    if self.scenario is None:\n        logging.warning(\n            f\"Inner scenario of the bilevel formulation was not fully defined. Creating it with the following settings:\"\n            f\"Arguments used: disciplines={self.disciplines}, \"\n            f\"objective_name={self.gemseo_settings['objective_name']}, \"\n            f\"design_space={self.gemseo_settings['design_space']}, \"\n            f\"scenario_type={self.gemseo_settings['scenario_type']}, \"\n            f\"formulation_name={self.gemseo_settings['formulation']}\"\n        )\n        self.create_gemseo_scenario()\n\n    self.scenario.set_algorithm(self.gemseo_settings[\"algorithm_inner\"])\n\n    # dv_names = self.scenario.formulation.design_variables.keys()\n    self.adapter = MDOScenarioAdapter(\n        # TODO make generic --&gt; ?\n        self.scenario,\n        input_names=self.gemseo_settings[\"doe_input_names\"],\n        output_names=self.gemseo_settings[\"doe_output_names\"],\n        reset_x0_before_opt=True,\n        set_x0_before_opt=False,\n    )\n\n    self.scenario_adapted = create_scenario(\n        self.adapter,\n        formulation_name=self.gemseo_settings[\"formulation\"],\n        objective_name=self.gemseo_settings[\"objective_name_outer\"],\n        design_space=self.gemseo_settings[\"design_space_outer\"],\n        scenario_type=\"MDO\",\n    )\n</code></pre>"},{"location":"api/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.compute","title":"compute","text":"<pre><code>compute()\n</code></pre> <p>Run the configured analysis or optimization.</p> <p>This method prepares input data, then executes either a bilevel optimization, a single-level GEMSEO scenario, or an MDA chain depending on the current configuration. After execution, it updates the internal data structures with model outputs.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def compute(self):\n    \"\"\"Run the configured analysis or optimization.\n\n    This method prepares input data, then executes either a bilevel\n    optimization, a single-level GEMSEO scenario, or an MDA chain\n    depending on the current configuration. After execution, it\n    updates the internal data structures with model outputs.\n    \"\"\"\n    input_data = self._pre_compute()\n    if hasattr(self, \"scenario\") and self.scenario:\n        if hasattr(self, \"scenario_adapted\") and self.scenario_adapted:\n            print(\"Running bi-level MDO\")\n            # self.scenario.default_inputs.update(self.scenario.options)\n            self.scenario_adapted.execute(self.gemseo_settings[\"algorithm_outer\"])\n        else:\n            print(\"Running MDO\")\n            self.scenario.execute(self.gemseo_settings[\"algorithm\"])\n    else:\n        if not hasattr(self, \"mda_chain\") or self.mda_chain is None:\n            raise ValueError(\"MDA chain not created. Please call setup_mda() first.\")\n        else:\n            print(\"Running MDA\")\n            self.mda_chain.execute(input_data=input_data)\n\n    self._update_data_from_model()\n</code></pre>"},{"location":"api/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.get_dataframes","title":"get_dataframes","text":"<pre><code>get_dataframes()\n</code></pre> <p>Return all main DataFrames as a dictionary, generated on demand.</p> <p>This method generates and returns a dictionary of key DataFrames representing inputs, outputs, and climate-related quantities in a tabular form suitable for inspection or export.</p> <p>Returns:</p> Type Description <code>dataframes</code> <p>Dictionary mapping DataFrame names to pandas DataFrame instances for data information, inputs, and outputs.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def get_dataframes(self):\n    \"\"\"Return all main DataFrames as a dictionary, generated on demand.\n\n    This method generates and returns a dictionary of key DataFrames\n    representing inputs, outputs, and climate-related quantities in a\n    tabular form suitable for inspection or export.\n\n    Returns\n    -------\n    dataframes\n        Dictionary mapping DataFrame names to pandas DataFrame\n        instances for data information, inputs, and outputs.\n    \"\"\"\n    return {\n        \"data_information\": self._get_data_information_df(),\n        \"vector_inputs\": self._get_vector_inputs_df(),\n        \"float_inputs\": self._get_float_inputs_df(),\n        \"str_inputs\": self._get_str_inputs_df(),\n        \"vector_outputs\": self._get_vector_outputs_df(),\n        \"float_outputs\": self._get_float_outputs_df(),\n        \"climate_outputs\": self._get_climate_outputs_df(),\n        # Add more if needed\n    }\n</code></pre>"},{"location":"api/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.get_json","title":"get_json","text":"<pre><code>get_json()\n</code></pre> <p>Return the model outputs as a JSON-serializable dictionary.</p> <p>Returns:</p> Type Description <code>json_data</code> <p>Dictionary containing JSON-compatible inputs and outputs.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def get_json(self):\n    \"\"\"\n    Return the model outputs as a JSON-serializable dictionary.\n\n    Returns\n    -------\n    json_data\n        Dictionary containing JSON-compatible inputs and outputs.\n    \"\"\"\n    return self._data_to_json()\n</code></pre>"},{"location":"api/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.write_json","title":"write_json","text":"<pre><code>write_json(file_name=None)\n</code></pre> <p>Write model inputs and outputs to a JSON file.</p> <p>This method builds the JSON-compatible data and writes it to disk, using either the provided file name or the path defined in the configuration.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <p>Path to the output JSON file. If None, the path from the configuration is used.</p> <code>None</code> Source code in <code>aeromaps/core/process.py</code> <pre><code>def write_json(self, file_name=None):\n    \"\"\"Write model inputs and outputs to a JSON file.\n\n    This method builds the JSON-compatible data and writes it to\n    disk, using either the provided file name or the path defined in\n    the configuration.\n\n    Parameters\n    ----------\n    file_name\n        Path to the output JSON file. If None, the path from the\n        configuration is used.\n    \"\"\"\n    if (\n        file_name is None\n        and self.configuration_file is not None\n        and \"OUTPUTS_JSON_DATA_FILE\" in self.config\n    ):\n        configuration_directory = os.path.dirname(self.configuration_file)\n        new_output_file_path = os.path.join(\n            configuration_directory, self.config[\"OUTPUTS_JSON_DATA_FILE\"]\n        )\n        file_name = new_output_file_path\n    elif file_name is None:\n        file_name = self.config[\"OUTPUTS_JSON_DATA_FILE\"]\n\n    # Ensure the directory exists\n    os.makedirs(os.path.dirname(file_name), exist_ok=True)\n\n    # Retrieve the data from the model\n    json_data = self.get_json()\n\n    with open(file_name, \"w\", encoding=\"utf-8\") as f:\n        dump(json_data, f, ensure_ascii=False, indent=4)\n</code></pre>"},{"location":"api/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.write_excel","title":"write_excel","text":"<pre><code>write_excel(file_name=None)\n</code></pre> <p>Write main result tables to an Excel workbook.</p> <p>This method exports data information, inputs, and outputs into separate sheets of a single Excel file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <p>Path to the output Excel file. If None, the path from the configuration is used.</p> <code>None</code> Source code in <code>aeromaps/core/process.py</code> <pre><code>def write_excel(self, file_name=None):\n    \"\"\"Write main result tables to an Excel workbook.\n\n    This method exports data information, inputs, and outputs into\n    separate sheets of a single Excel file.\n\n    Parameters\n    ----------\n    file_name\n        Path to the output Excel file. If None, the path from the\n        configuration is used.\n    \"\"\"\n    if file_name is None:\n        file_name = self.config[\"EXCEL_DATA_FILE\"]\n    with pd.ExcelWriter(file_name) as writer:\n        self._get_data_information_df().to_excel(writer, sheet_name=\"Data Information\")\n        self._get_vector_inputs_df().to_excel(writer, sheet_name=\"Vector Inputs\")\n        self._get_float_inputs_df().to_excel(writer, sheet_name=\"Float Inputs\")\n        self._get_str_inputs_df().to_excel(writer, sheet_name=\"String Inputs\")\n        self._get_vector_outputs_df().to_excel(writer, sheet_name=\"Vector Outputs\")\n        self._get_float_outputs_df().to_excel(writer, sheet_name=\"Float Outputs\")\n        self._get_climate_outputs_df().to_excel(writer, sheet_name=\"Climate Outputs\")\n</code></pre>"},{"location":"api/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.generate_n2","title":"generate_n2","text":"<pre><code>generate_n2()\n</code></pre> <p>Generate an N2 diagram for the current disciplines.</p> <p>This method calls GEMSEO to create an N2 plot describing the coupling structure between the configured disciplines.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def generate_n2(self):\n    \"\"\"Generate an N2 diagram for the current disciplines.\n\n    This method calls GEMSEO to create an N2 plot describing the\n    coupling structure between the configured disciplines.\n    \"\"\"\n    generate_n2_plot(self.disciplines)\n</code></pre>"},{"location":"api/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.list_available_plots","title":"list_available_plots","text":"<pre><code>list_available_plots()\n</code></pre> <p>List the names of supported plots.</p> <p>Returns:</p> Type Description <code>plot_names</code> <p>List of strings identifying available plot functions.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def list_available_plots(self):\n    \"\"\"List the names of supported plots.\n\n    Returns\n    -------\n    plot_names\n        List of strings identifying available plot functions.\n    \"\"\"\n    return list(available_plots.keys())\n</code></pre>"},{"location":"api/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.list_float_inputs","title":"list_float_inputs","text":"<pre><code>list_float_inputs()\n</code></pre> <p>Return the current scalar input values.</p> <p>Returns:</p> Type Description <code>float_inputs</code> <p>Dictionary of scalar input names and their values.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def list_float_inputs(self):\n    \"\"\"Return the current scalar input values.\n\n    Returns\n    -------\n    float_inputs\n        Dictionary of scalar input names and their values.\n    \"\"\"\n    return self.data[\"float_inputs\"]\n</code></pre>"},{"location":"api/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.list_str_inputs","title":"list_str_inputs","text":"<pre><code>list_str_inputs()\n</code></pre> <p>Return the current string input values.</p> <p>Returns:</p> Type Description <code>str_inputs</code> <p>Dictionary of string input names and their values.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def list_str_inputs(self):\n    \"\"\"Return the current string input values.\n\n    Returns\n    -------\n    str_inputs\n        Dictionary of string input names and their values.\n    \"\"\"\n    return self.data[\"str_inputs\"]\n</code></pre>"},{"location":"api/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.plot","title":"plot","text":"<pre><code>plot(name, save=False, size_inches=None, remove_title=False)\n</code></pre> <p>Generate a predefined AeroMAPS plot.</p> <p>Depending on the plot name, this method uses either generic or fleet-specific plotting functions and optionally saves the figure to a PDF file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Identifier of the plot to generate, possible to obtain from list_available_plots().</p> required <code>save</code> <p>Whether to save the generated plot as a PDF file.</p> <code>False</code> <code>size_inches</code> <p>Optional figure size in inches as a tuple or list.</p> <code>None</code> <code>remove_title</code> <p>Whether to remove the plot title before saving.</p> <code>False</code> <p>Returns:</p> Type Description <code>fig</code> <p>Object holding the created plot, as returned by the plot function.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def plot(self, name, save=False, size_inches=None, remove_title=False):\n    \"\"\"Generate a predefined AeroMAPS plot.\n\n    Depending on the plot name, this method uses either generic or\n    fleet-specific plotting functions and optionally saves the figure\n    to a PDF file.\n\n    Parameters\n    ----------\n    name\n        Identifier of the plot to generate, possible to obtain from list_available_plots().\n    save\n        Whether to save the generated plot as a PDF file.\n    size_inches\n        Optional figure size in inches as a tuple or list.\n    remove_title\n        Whether to remove the plot title before saving.\n\n    Returns\n    -------\n    fig\n        Object holding the created plot, as returned by the plot\n        function.\n    \"\"\"\n    if name in available_plots_fleet:\n        try:\n            # todo: if we pass the process to the plot, fleet_model is no longer needed as an argument.\n            fig = available_plots_fleet[name](self, self.fleet_model)\n            if save:\n                if size_inches is not None:\n                    fig.fig.set_size_inches(size_inches)\n                if remove_title:\n                    fig.fig.gca().set_title(\"\")\n                fig.fig.savefig(f\"{name}.pdf\", bbox_inches=\"tight\")\n        except AttributeError as e:\n            raise NameError(\n                f\"Plot {name} requires using bottom up fleet model. Original error: {e}\"\n            )\n    elif name in available_plots:\n        fig = available_plots[name](self)\n        if save:\n            if size_inches is not None:\n                fig.fig.set_size_inches(size_inches)\n            if remove_title:\n                fig.fig.gca().set_title(\"\")\n            fig.fig.savefig(f\"{name}.pdf\", bbox_inches=\"tight\")\n    else:\n        raise NameError(\n            f\"Plot {name} is not available. List of available plots: {list(available_plots.keys()), list(available_plots_fleet.keys())}\"\n        )\n    return fig\n</code></pre>"},{"location":"api/aeromaps/","title":"<code>AeroMAPS</code>","text":"<p>Initialization module for the AeroMAPS package, which provides the function to create an AeroMAPSProcess.</p>"},{"location":"api/aeromaps/#aeromaps.create_process","title":"create_process","text":"<pre><code>create_process(configuration_file=None, models=default_models_top_down, use_fleet_model=False, add_examples_aircraft_and_subcategory=True, optimisation=False)\n</code></pre> <p>Create an AeroMAPS process.</p> <p>Parameters:</p> Name Type Description Default <code>configuration_file</code> <code>str</code> <p>Path to the configuration file (default is None).</p> <code>None</code> <code>models</code> <code>dict</code> <p>Dictionary of models to be used (default is default_models_top_down).</p> <code>default_models_top_down</code> <code>use_fleet_model</code> <code>bool</code> <p>Whether to use the fleet model (default is False).</p> <code>False</code> <code>add_examples_aircraft_and_subcategory</code> <code>bool</code> <p>Whether to add example aircraft and subcategories (default is True).</p> <code>True</code> <code>optimisation</code> <code>bool</code> <p>Whether to enable optimisation (default is False).</p> <code>False</code> <p>Returns:</p> Type Description <code>AeroMAPSProcess</code> <p>An instance of the AeroMAPSProcess class.</p> Source code in <code>aeromaps/__init__.py</code> <pre><code>def create_process(\n    configuration_file=None,\n    models=default_models_top_down,\n    use_fleet_model=False,\n    add_examples_aircraft_and_subcategory=True,\n    optimisation=False,\n) -&gt; AeroMAPSProcess:\n    \"\"\"\n    Create an AeroMAPS process.\n\n    Parameters\n    ----------\n    configuration_file : str, optional\n        Path to the configuration file (default is None).\n    models : dict, optional\n        Dictionary of models to be used (default is default_models_top_down).\n    use_fleet_model : bool, optional\n        Whether to use the fleet model (default is False).\n    add_examples_aircraft_and_subcategory : bool, optional\n        Whether to add example aircraft and subcategories (default is True).\n    optimisation : bool, optional\n        Whether to enable optimisation (default is False).\n\n    Returns\n    -------\n    AeroMAPSProcess\n        An instance of the AeroMAPSProcess class.\n    \"\"\"\n\n    return AeroMAPSProcess(\n        configuration_file=configuration_file,\n        models=models,\n        use_fleet_model=use_fleet_model,\n        add_examples_aircraft_and_subcategory=add_examples_aircraft_and_subcategory,\n        optimisation=optimisation,\n    )\n</code></pre>"},{"location":"api/aeromaps.utils.functions/","title":"<code>aeromaps.utils.functions</code>","text":""},{"location":"api/aeromaps.utils.functions/#aeromaps.utils.functions.create_partitioning","title":"create_partitioning","text":"<pre><code>create_partitioning(file, path='')\n</code></pre> <p>Generation of a JSON input file (air transport data) and a CSV file (climate data) for running an AeroMAPS process for a partitioned scope.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <p>Path to the CSV file containing AeroSCOPE data for the partitioned scope.</p> required <code>path</code> <p>Directory path where the generated files will be saved.</p> <code>''</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>aeromaps/utils/functions.py</code> <pre><code>def create_partitioning(file, path=\"\"):\n    \"\"\"\n    Generation of a JSON input file (air transport data) and a CSV file (climate data) for running an AeroMAPS process for a partitioned scope.\n\n    Parameters\n    ----------\n    file\n        Path to the CSV file containing AeroSCOPE data for the partitioned scope.\n    path\n        Directory path where the generated files will be saved.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n\n    # World input data recovery\n    world_data_path = pth.join(data.__path__[0], \"parameters.json\")\n    with open(world_data_path, \"r\") as parameters_file:\n        world_data_dict = json.load(parameters_file)\n\n    # Assumption on freight\n    freight_energy_share_2019_partitioned = world_data_dict[\"freight_energy_share_2019\"]\n\n    # AeroSCOPE data recovery\n    partitioned_data_df = read_csv(file, delimiter=\",\")\n    partitioned_data = partitioned_data_df.values\n    total_ask_2019 = partitioned_data[0, 1]\n    short_range_ask_2019 = partitioned_data[0, 2]\n    medium_range_ask_2019 = partitioned_data[0, 3]\n    long_range_ask_2019 = partitioned_data[0, 4]\n    total_seats_2019 = partitioned_data[2, 1]\n    total_energy_consumption_per_ask_2019 = partitioned_data[4, 1]\n    short_range_energy_consumption_per_ask_2019 = partitioned_data[4, 2]\n    medium_range_energy_consumption_per_ask_2019 = partitioned_data[4, 3]\n    long_range_energy_consumption_per_ask_2019 = partitioned_data[4, 4]\n    total_energy_consumption_2019 = (\n        total_energy_consumption_per_ask_2019\n        * total_ask_2019\n        / (1 - freight_energy_share_2019_partitioned / 2 / 100)\n    )  # Dedicated freight (half of total freight) not included in AeroSCOPE\n    short_range_energy_consumption_2019 = (\n        short_range_energy_consumption_per_ask_2019 * short_range_ask_2019\n    ) * (1 - 0.075 / (1 - 0.075))\n    medium_range_energy_consumption_2019 = (\n        medium_range_energy_consumption_per_ask_2019 * medium_range_ask_2019\n    ) * (1 - 0.075 / (1 - 0.075))\n    long_range_energy_consumption_2019 = (\n        long_range_energy_consumption_per_ask_2019 * long_range_ask_2019\n    ) * (1 - 0.075 / (1 - 0.075))\n\n    # Calculation of the partitioned input values\n\n    ## Float inputs\n    short_range_energy_share_2019_partitioned = (\n        short_range_energy_consumption_2019 / total_energy_consumption_2019 * 100\n    )\n    medium_range_energy_share_2019_partitioned = (\n        medium_range_energy_consumption_2019 / total_energy_consumption_2019 * 100\n    )\n    long_range_energy_share_2019_partitioned = (\n        long_range_energy_consumption_2019 / total_energy_consumption_2019 * 100\n    )\n    short_range_rpk_share_2019_partitioned = short_range_ask_2019 / total_ask_2019 * 100\n    medium_range_rpk_share_2019_partitioned = medium_range_ask_2019 / total_ask_2019 * 100\n    long_range_rpk_share_2019_partitioned = long_range_ask_2019 / total_ask_2019 * 100\n    commercial_aviation_coefficient_partitioned = 1\n\n    ## Vector inputs\n    share_ask_partitioned_vs_world_2019 = total_ask_2019 / world_data_dict[\"ask_init\"][19] * 100\n    share_seats_partitioned_vs_world_2019 = total_seats_2019 / (\n        world_data_dict[\"pax_init\"][19]\n        * world_data_dict[\"ask_init\"][19]\n        / world_data_dict[\"rpk_init\"][19]\n        * 100\n    )\n    share_energy_consumption_partitioned_vs_world_2019 = (\n        total_energy_consumption_2019 / world_data_dict[\"energy_consumption_init\"][19] * 100\n    )\n    rpk_init_partitioned = []\n    ask_init_partitioned = []\n    rtk_init_partitioned = []\n    total_aircraft_distance_init_partitioned = []\n    freight_init_partitioned = []\n    pax_init_partitioned = []\n    energy_consumption_init_partitioned = []\n    for k in range(0, 20):\n        rpk_init_partitioned.append(\n            world_data_dict[\"rpk_init\"][k] * share_ask_partitioned_vs_world_2019 / 100\n        )\n        ask_init_partitioned.append(\n            world_data_dict[\"ask_init\"][k] * share_ask_partitioned_vs_world_2019 / 100\n        )\n        rtk_init_partitioned.append(\n            world_data_dict[\"rtk_init\"][k] * share_ask_partitioned_vs_world_2019 / 100\n        )\n        freight_init_partitioned.append(\n            world_data_dict[\"freight_init\"][k] * share_ask_partitioned_vs_world_2019 / 100\n        )\n        total_aircraft_distance_init_partitioned.append(\n            world_data_dict[\"total_aircraft_distance_init\"][k]\n            * share_ask_partitioned_vs_world_2019\n            / 100\n        )\n        pax_init_partitioned.append(\n            world_data_dict[\"pax_init\"][k] * share_seats_partitioned_vs_world_2019 / 100\n        )\n        energy_consumption_init_partitioned.append(\n            world_data_dict[\"energy_consumption_init\"][k]\n            * share_energy_consumption_partitioned_vs_world_2019\n            / 100\n        )\n\n    # TODO move historic and prospection start year out of custom input file\n\n    historic_start_year_partitioned = world_data_dict[\"historic_start_year\"]\n    prospection_start_year_partitioned = world_data_dict[\"prospection_start_year\"]\n\n    # Generation of the JSON file\n    partitioned_inputs_dict = {\n        \"rpk_init\": rpk_init_partitioned,\n        \"ask_init\": ask_init_partitioned,\n        \"rtk_init\": rtk_init_partitioned,\n        \"pax_init\": pax_init_partitioned,\n        \"freight_init\": freight_init_partitioned,\n        \"energy_consumption_init\": energy_consumption_init_partitioned,\n        \"total_aircraft_distance_init\": total_aircraft_distance_init_partitioned,\n        \"short_range_energy_share_2019\": short_range_energy_share_2019_partitioned,\n        \"medium_range_energy_share_2019\": medium_range_energy_share_2019_partitioned,\n        \"long_range_energy_share_2019\": long_range_energy_share_2019_partitioned,\n        \"freight_energy_share_2019\": freight_energy_share_2019_partitioned,\n        \"short_range_rpk_share_2019\": short_range_rpk_share_2019_partitioned,\n        \"medium_range_rpk_share_2019\": medium_range_rpk_share_2019_partitioned,\n        \"long_range_rpk_share_2019\": long_range_rpk_share_2019_partitioned,\n        \"commercial_aviation_coefficient\": commercial_aviation_coefficient_partitioned,\n        \"historic_start_year\": historic_start_year_partitioned,\n        \"prospection_start_year\": prospection_start_year_partitioned,\n    }\n    partitioned_inputs_path = pth.join(path, \"partitioned_inputs.json\")\n    with open(partitioned_inputs_path, \"w\") as outfile:\n        json.dump(partitioned_inputs_dict, outfile)\n\n    # Create a CSV file for initialisation of vector inputs.\n    # TODO: not necessary without optim, check relevance of the process?\n    vector_inputs_df = pd.DataFrame(\n        {\n            \"rpk_init\": rpk_init_partitioned,\n            \"ask_init\": ask_init_partitioned,\n            \"rtk_init\": rtk_init_partitioned,\n            \"pax_init\": pax_init_partitioned,\n            \"freight_init\": freight_init_partitioned,\n            \"energy_consumption_init\": energy_consumption_init_partitioned,\n            \"total_aircraft_distance_init\": total_aircraft_distance_init_partitioned,\n        },\n        index=range(historic_start_year_partitioned, prospection_start_year_partitioned),\n    )\n\n    vector_inputs_path = pth.join(path, \"vector_inputs_partitioned.csv\")\n    vector_inputs_df.to_csv(vector_inputs_path, sep=\";\")\n\n    # Generation of a CSV file for using climate models\n    climate_world_data_path = pth.join(\n        climate_data.__path__[0], \"temperature_historical_dataset.csv\"\n    )\n    climate_world_data_df = pd.read_csv(climate_world_data_path, delimiter=\";\", header=None)\n    climate_world_data = climate_world_data_df.values\n    climate_world_data_years = climate_world_data[:, 0]\n    climate_world_data_co2_emissions = climate_world_data[:, 1]\n    climate_world_data_nox_emissions = climate_world_data[:, 2]\n    climate_world_data_h2o_emissions = climate_world_data[:, 3]\n    climate_world_data_soot_emissions = climate_world_data[:, 4]\n    climate_world_data_sulfur_emissions = climate_world_data[:, 5]\n    climate_world_data_distance = climate_world_data[:, 6]\n    climate_partitioned_data_years = climate_world_data_years\n    climate_partitioned_data_co2_emissions = (\n        climate_world_data_co2_emissions * share_energy_consumption_partitioned_vs_world_2019 / 100\n    )\n    climate_partitioned_data_nox_emissions = (\n        climate_world_data_nox_emissions * share_energy_consumption_partitioned_vs_world_2019 / 100\n    )\n    climate_partitioned_data_h2o_emissions = (\n        climate_world_data_h2o_emissions * share_energy_consumption_partitioned_vs_world_2019 / 100\n    )\n    climate_partitioned_data_soot_emissions = (\n        climate_world_data_soot_emissions * share_energy_consumption_partitioned_vs_world_2019 / 100\n    )\n    climate_partitioned_data_sulfur_emissions = (\n        climate_world_data_sulfur_emissions\n        * share_energy_consumption_partitioned_vs_world_2019\n        / 100\n    )\n    climate_partitioned_data_distance = (\n        climate_world_data_distance * share_ask_partitioned_vs_world_2019 / 100\n    )\n    climate_partitioned_data_years_number = len(climate_partitioned_data_years)\n    partitioned_historical_climate_dataset = np.zeros((climate_partitioned_data_years_number, 7))\n    for k in range(0, climate_partitioned_data_years_number):\n        partitioned_historical_climate_dataset[k, 0] = climate_partitioned_data_years[k]\n        partitioned_historical_climate_dataset[k, 1] = climate_partitioned_data_co2_emissions[k]\n        partitioned_historical_climate_dataset[k, 2] = climate_partitioned_data_nox_emissions[k]\n        partitioned_historical_climate_dataset[k, 3] = climate_partitioned_data_h2o_emissions[k]\n        partitioned_historical_climate_dataset[k, 4] = climate_partitioned_data_soot_emissions[k]\n        partitioned_historical_climate_dataset[k, 5] = climate_partitioned_data_sulfur_emissions[k]\n        partitioned_historical_climate_dataset[k, 6] = climate_partitioned_data_distance[k]\n    climate_partitioned_data_path = pth.join(path, \"partitioned_temperature_historical_dataset.csv\")\n    np.savetxt(climate_partitioned_data_path, partitioned_historical_climate_dataset, delimiter=\";\")\n\n    return\n</code></pre>"},{"location":"api/aeromaps.utils.functions/#aeromaps.utils.functions.merge_json_files","title":"merge_json_files","text":"<pre><code>merge_json_files(file1, file2, output_file)\n</code></pre> <p>Merge two JSON files into a single JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>file1</code> <p>Path to the first JSON file.</p> required <code>file2</code> <p>Path to the second JSON file.</p> required <code>output_file</code> <p>Path to the output JSON file where the merged content will be saved.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>aeromaps/utils/functions.py</code> <pre><code>def merge_json_files(file1, file2, output_file):\n    \"\"\"\n    Merge two JSON files into a single JSON file.\n\n    Parameters\n    ----------\n    file1\n        Path to the first JSON file.\n    file2\n        Path to the second JSON file.\n    output_file\n        Path to the output JSON file where the merged content will be saved.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    with open(file1, \"r\") as f1, open(file2, \"r\") as f2:\n        data1 = json.load(f1)\n        data2 = json.load(f2)\n\n    merged_data = {**data1, **data2}\n\n    with open(output_file, \"w\") as outfile:\n        json.dump(merged_data, outfile, indent=4)\n</code></pre>"},{"location":"api/aeromaps.utils.functions/#aeromaps.utils.functions.compare_json_files","title":"compare_json_files","text":"<pre><code>compare_json_files(file1_path, file2_path, ignore_order=False, verbose=True, rtol=0.0001, atol=0.1)\n</code></pre> <p>Compare two JSON files using deepdiff and return whether differences exist.</p> <p>Parameters:</p> Name Type Description Default <code>file1_path</code> <code>str</code> <p>Path to the first JSON file.</p> required <code>file2_path</code> <code>str</code> <p>Path to the second JSON file.</p> required <code>ignore_order</code> <code>bool</code> <p>Whether to ignore the order in lists.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print differences.</p> <code>True</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for numeric comparisons.</p> <code>0.0001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for numeric comparisons.</p> <code>0.1</code> <p>Returns:</p> Type Description <code>differences_exist</code> <p>True if differences exist between the two JSON files, False otherwise.</p> Source code in <code>aeromaps/utils/functions.py</code> <pre><code>def compare_json_files(\n    file1_path: str,\n    file2_path: str,\n    ignore_order: bool = False,\n    verbose: bool = True,\n    rtol: float = 0.0001,\n    atol: float = 0.1,\n) -&gt; bool:\n    \"\"\"\n    Compare two JSON files using deepdiff and return whether differences exist.\n\n    Parameters\n    ----------\n    file1_path\n        Path to the first JSON file.\n    file2_path\n        Path to the second JSON file.\n    ignore_order\n        Whether to ignore the order in lists.\n    verbose\n        Whether to print differences.\n    rtol\n        Relative tolerance for numeric comparisons.\n    atol\n        Absolute tolerance for numeric comparisons.\n\n    Returns\n    -------\n    differences_exist\n        True if differences exist between the two JSON files, False otherwise.\n    \"\"\"\n    with open(file1_path, \"r\") as f1, open(file2_path, \"r\") as f2:\n        json1 = json.load(f1)\n        json2 = json.load(f2)\n\n    diff = DeepDiff(\n        json1,\n        json2,\n        ignore_order=ignore_order,\n        exclude_paths=False or [],\n    )\n\n    # Remove value changes that are within tolerance\n    if \"values_changed\" in diff:\n        keys_to_remove = []\n        for key, value in diff[\"values_changed\"].items():\n            if isinstance(value, dict) and \"new_value\" in value and \"old_value\" in value:\n                new_value = value[\"new_value\"]\n                old_value = value[\"old_value\"]\n                if (\n                    isinstance(new_value, (float, int))\n                    and isinstance(old_value, (float, int))\n                    and np.isclose(new_value, old_value, rtol=rtol, atol=atol, equal_nan=True)\n                ):\n                    keys_to_remove.append(key)\n                elif isinstance(new_value, dict) and isinstance(old_value, dict):\n                    # Check if all numeric values in the dict are close enough\n                    if all(\n                        np.isclose(new_value[k], old_value[k], rtol=rtol, atol=atol, equal_nan=True)\n                        for k in new_value\n                        if isinstance(new_value[k], (float, int))\n                        and k in old_value\n                        and isinstance(old_value[k], (float, int))\n                    ):\n                        keys_to_remove.append(key)\n        for key in keys_to_remove:\n            del diff[\"values_changed\"][key]\n        if not diff[\"values_changed\"]:\n            del diff[\"values_changed\"]\n\n    # Clean up iterable diffs by removing items that are close enough to something in the other JSON\n    iterable_messages = []\n\n    def cleanup_iterable_diff(tag, other_json):\n        if tag in diff:\n            keys_to_remove = []\n            for key, value in diff[tag].items():\n                # The path looks like \"root['some_list'][2]\"\n                prefix, idx_str = key.rsplit(\"[\", 1)\n                idx = idx_str[:-1]  # Remove the trailing ']'\n                other_parent = eval(prefix.replace(\"root\", \"other_json\"))\n                if isinstance(other_parent, list):\n                    if np.isclose(\n                        value, other_parent[int(idx)], rtol=rtol, atol=atol, equal_nan=True\n                    ):\n                        keys_to_remove.append(key)\n                    else:\n                        iterable_messages.append(\n                            f\"For: {prefix}, index {idx} beyond tolerance: {value} against {other_parent[int(idx)]}\"\n                        )\n            for k in keys_to_remove:\n                del diff[tag][k]\n            if not diff[tag]:\n                del diff[tag]\n\n    cleanup_iterable_diff(\"iterable_item_added\", json1)\n    cleanup_iterable_diff(\"iterable_item_removed\", json2)\n\n    if verbose:\n        if diff or iterable_messages:\n            print(\"Differences found:\")\n            if diff:\n                print(json.dumps(diff, indent=2, default=convert_non_serializable))\n            if iterable_messages:\n                for message in iterable_messages:\n                    print(message)\n        else:\n            print(\"No differences found.\")\n    return bool(diff)\n</code></pre>"},{"location":"api/aeromaps.utils.functions/#aeromaps.utils.functions.convert_non_serializable","title":"convert_non_serializable","text":"<pre><code>convert_non_serializable(obj)\n</code></pre> <p>Convert non-serializable objects to a serializable format for JSON output.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <p>The object to convert.</p> required <p>Returns:</p> Type Description <code>serializable</code> <p>A JSON-serializable representation of the object.</p> Source code in <code>aeromaps/utils/functions.py</code> <pre><code>def convert_non_serializable(obj):\n    \"\"\"\n    Convert non-serializable objects to a serializable format for JSON output.\n\n    Parameters\n    ----------\n    obj\n        The object to convert.\n\n    Returns\n    -------\n    serializable\n        A JSON-serializable representation of the object.\n\n    \"\"\"\n    # Native containers -&gt; convert to list\n    if isinstance(obj, (set, list, tuple)):\n        return list(obj)\n\n    # If it's an iterable (but not a string/bytes/mapping), try to convert to list.\n    # This handles deepdiff.SetOrdered and similar container-like types that don't\n    # expose useful __dict__ contents.\n    if not isinstance(obj, (str, bytes, dict)) and hasattr(obj, \"__iter__\"):\n        try:\n            lst = list(obj)\n            return lst\n        except Exception:\n            # If it cannot be converted to a list, fall through to other handlers\n            pass\n\n    # If object has a non-empty __dict__, prefer that (useful for plain objects)\n    if hasattr(obj, \"__dict__\") and obj.__dict__:\n        # Optional debug left intentionally minimal\n        # print('Converting using __dict__', obj)\n        return obj.__dict__\n\n    # Last resort: convert to string\n    return str(obj)\n</code></pre>"},{"location":"api/aeromaps.utils.functions/#aeromaps.utils.functions.custom_logger_config","title":"custom_logger_config","text":"<pre><code>custom_logger_config(logger)\n</code></pre> <p>Specific filter to remove a warning triggered in the absence of a docstring in each discipline. Hopefully temporary!!!</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <p>The logger to configure.</p> required <p>Returns:</p> Type Description <code>logger</code> <p>The configured logger with the custom filter applied.</p> Source code in <code>aeromaps/utils/functions.py</code> <pre><code>def custom_logger_config(logger):\n    \"\"\"\n    Specific filter to remove a warning triggered in the absence of a docstring in each discipline.\n    Hopefully temporary!!!\n\n\n    Parameters\n    ----------\n    logger\n        The logger to configure.\n\n    Returns\n    -------\n    logger\n        The configured logger with the custom filter applied.\n\n    \"\"\"\n\n    # Specific filter to remove a warning triggered in the absence of a docstring in each discipline.\n    class SuppressArgsSectionWarning(logging.Filter):\n        def filter(self, record: logging.LogRecord) -&gt; bool:\n            return record.getMessage() != \"The Args section is missing.\"\n\n    for handler in logger.handlers:\n        handler.addFilter(SuppressArgsSectionWarning())\n\n    return logger\n</code></pre>"},{"location":"api/aeromaps.utils.functions/#aeromaps.utils.functions.clean_notebooks_on_tests","title":"clean_notebooks_on_tests","text":"<pre><code>clean_notebooks_on_tests(namespace=None, force_cleanup=False)\n</code></pre> <p>Clean up the notebook namespace by deleting variables when running tests or when forced to save semaphore memory.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <p>The namespace (dictionary) to clean. If None, uses globals().</p> <code>None</code> <code>force_cleanup</code> <p>If True, forces cleanup regardless of test detection.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>aeromaps/utils/functions.py</code> <pre><code>def clean_notebooks_on_tests(namespace=None, force_cleanup=False):\n    \"\"\"\n    Clean up the notebook namespace by deleting variables when running tests or when forced to save semaphore memory.\n\n    Parameters\n    ----------\n    namespace\n        The namespace (dictionary) to clean. If None, uses globals().\n    force_cleanup\n        If True, forces cleanup regardless of test detection.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    import os\n    import gc\n\n    logger = logging.getLogger(\"aeromaps.utils.functions\")\n    logger.info(\"\ud83e\uddf9 clean_notebooks_on_tests called\")\n\n    if namespace is None:\n        namespace = globals()\n    RUNNING_TEST = os.environ.get(\"PYTEST_CURRENT_TEST\") is not None\n\n    if RUNNING_TEST or force_cleanup:\n        logger.info(\"\ud83e\uddea Detected test run or force cleanup\")\n        to_delete = [\n            var\n            for var in list(namespace.keys())\n            if not var.startswith(\"_\")\n            and var not in (\"os\", \"gc\", \"RUNNING_TEST\", \"clean_notebooks_on_tests\", \"namespace\")\n        ]\n        for var in to_delete:\n            del namespace[var]\n        gc.collect()\n        logger.info(f\"\u2705 Cleaned up {len(to_delete)} variables\")\n    else:\n        logger.info(\"\u23ed Skipping cleanup during notebook run\")\n</code></pre>"},{"location":"books/","title":"Documentation","text":"<p>This documentation provides an overview of the AeroMAPS modelling, and additional resources for users. </p> <p>In particular, it includes sections on: </p> <ul> <li>Graphical User Interface (GUI): Instructions on how to use the AeroMAPS GUI (Old version - to be updated).</li> <li>Documentation: Detailed information about the models used in AeroMAPS (Old version - to be updated).</li> <li>Examples: Various use cases and tutorials to help users get started with AeroMAPS.</li> <li>References: Information on how to cite AeroMAPS in your work (to be updated).</li> </ul>"},{"location":"books/_changelog/","title":"changelog","text":"<p><code>{include} ../../CHANGELOG.md</code></p>"},{"location":"books/documentation_airtransport/","title":"Air transport modeling","text":"<p>This part of the documentation is deprecated. It describes AeroMAPS in late 2023</p> <p>It will be updated soon.!</p> <p>The air transport system model presented in the AeroMAPS architecture rely on the modeling of levers of  action to reduce the environmental impacts of the sector. Before describing their implementation in AeroMAPS, these  levers of action are identified.</p>"},{"location":"books/documentation_airtransport/#identification-of-the-main-levers-of-action","title":"Identification of the main levers of action","text":"<p>The different levers of action to reduce environmental impacts from air transport are identified and linked using an  approach based on an adaptation of the Kaya identity for CO<sub>2</sub> emissions. It allows for obtaining the three  main elements of the air transport system described in the AeroMAPS architecture.</p> <p>The Kaya identity allows decomposing the global CO<sub>2</sub> emissions through demographic (population \\(POP\\)),  economic (GDP per capita \\(GDP/POP\\)), and technological factors (energy intensity \\(E/GDP\\) which can be assimilated to  an output and the CO<sub>2</sub> content \\(CO_2/E\\)) <sup>1</sup>. The interest of this identity is that  it indicates different levers to act on CO<sub>2</sub> <sup>2</sup><sup>3</sup>. Different  studies, often based on specific decomposition methods, justify the choice of relevant parameters for decomposing  emissions <sup>4</sup><sup>5</sup>. Nevertheless, some parameters are interdependent and interpretations  can be complex <sup>6</sup>.</p> <p>\\(CO_2 = POP \\times \\frac{GDP}{POP} \\times \\frac{E}{GDP} \\times \\frac{CO_2}{E}\\)</p> <p>This identity can be adapted to air transport in many ways. In this work, a simplified decomposition is proposed via  the following equation. The different parameters are justified by other works related to transportation and aviation  <sup>7</sup><sup>8</sup><sup>9</sup><sup>10</sup>. The first factor \\(RPK\\)  corresponds to air traffic. The second factor \\(E/RPK\\) represents the ratio between the energy \\(E\\) consumed by the  sector and the air traffic. It corresponds to the average energy consumption of aircraft per passenger and  per kilometer. The last factor \\(CO_2/E\\) is the ratio between the sector's CO<sub>2</sub> emissions and the energy  it consumes. It represents the CO<sub>2</sub> content of the energy used by the aircraft. These parameters thus  represent different levers of action to decarbonize the aviation sector. </p> <p>\\(CO_2 = RPK \\times \\frac{E}{RPK} \\times \\frac{CO_2}{E}\\)</p> <p>This equation can be modified or expanded. For example, additional coefficients can be added to include indirect  CO<sub>2</sub> emissions or non-CO<sub>2</sub> climate effects. Similarly, the energy efficiency factor can be  decomposed to separate technological and operational levers (load factor, improved flight or ground operations).  Finally, as with the original Kaya identity, economic parameters can be incorporated.</p> <p>It is important to note that these different factors are not totally independent. For example, a change in energy  carrier may lead to an increase in energy consumption per passenger and per kilometer. Similarly, the level of air  traffic can affect the load factor. Only the main interactions are considered in the following.</p> <p>Before modeling the evolution of these different parameters, it is interesting to plot their historical evolution.  Fig.1 represents the factors of the Kaya decomposition for aviation by also integrating the load factor \\(RPK/ASK\\).  Despite significant improvements in fuel efficiency via technology and load factor, CO<sub>2</sub> emissions from the  sector have doubled due to the large increase in traffic. The CO<sub>2</sub> content of the energy has not changed due  to the almost exclusive use of fossil kerosene.</p> <p></p> <p>Fig.1 Historical evolution of the different parameters of Kaya identity for aviation.</p> <p>This work thus allows identifying and linking the different levers of action to reduce emissions from aviation.  In the following, deterministic models for estimating the following parameters are presented: - usage evolution through the evolution of air traffic ; - energy efficiency through improvements in energy intensity with various levers (fleet renewal for more efficient aircraft, operations, load factor) ; - energy decarbonization through the incorporation of alternative energy carriers to replace fossil fuel. These models are particularly focused on their links to the sector's CO<sub>2</sub> emissions, but some elements  concerning strategies against non-CO<sub>2</sub> effects are also provided.</p>"},{"location":"books/documentation_airtransport/#main-historical-data","title":"Main historical data","text":"<p>Before detailing the different models for representing the evolution of the different elements of air transport,  historical data used are briefly discussed. Various air traffic data used are derived from International Civil Aviation Organization (ICAO),  such as annual passenger numbers, RPK, RTK (Revenue Tonne Kilometer), ASK (Available Seat Kilometer) or aircraft load  factor. Then, the historical evolution of the term \\(\\frac{E}{RPK}\\) is obtained using the previous traffic data and data  on world kerosene consumption by the aviation sector, extracted and adapted from  International Energy Agency (IEA).  Indeed, not all kerosene is consumed by commercial aviation alone. According to <sup>11</sup>,  military aviation consumes 8% of kerosene and general and private aviation 4%. The consumption of alternative energy  carriers is considered as negligible in the last decades. Lastly, the term \\(\\frac{CO_2}{E}\\) is considered as constant  for the same reason. The values considered depend on the scope chosen, in particular the inclusion of emissions related  to fossil kerosene production. Here, mean values from a review paper <sup>12</sup> are used: a direct  emission factor of 74.0 gCO<sub>2</sub>-eq/MJ<sub>fuel</sub> and a global (including fuel production) emission factor  of 88.7 gCO<sub>2</sub>-eq/MJ<sub>fuel</sub>. The global emission factor is considered by default to facilitate the  comparison with alternative energy carriers. As a consequence, using these data and including indirect CO<sub>2</sub>  emissions, commercial aviation was for instance responsible for 2.6% of world CO<sub>2</sub> emissions in 2019  (compared with data from Global Carbon Project  including fossil fuel combustion and land use). See for instance <sup>13</sup> for more details. </p>"},{"location":"books/documentation_airtransport/#air-traffic-usage-evolution","title":"Air traffic: usage evolution","text":"<p>The parameter that represents the evolution of air traffic is the RPK. The air traffic modeling is based on  the study of worldwide historical data. The models presented in this section can be applied to the fleet as a whole or  to the different markets described below. Before detailing these models, the categorization and calibration of the  aviation market used in AeroMAPS is presented.</p>"},{"location":"books/documentation_airtransport/#categorization-and-calibration-of-the-aviation-market","title":"Categorization and calibration of the aviation market","text":"<p>In order to be able to model scenarios in detail, the aviation market is divided into several representative  categories, corresponding to aircraft fleet. Indeed, some market shares are likely to evolve differently. Moreover,  some aircraft architectures (hydrogen aircraft, electric aircraft) could only be available for short distance missions  in the medium term. </p> <p>Aircraft categories can be defined according to the distance flown (short, medium and long-haul) or the type of  aircraft (regional, single-aisle, wide-body, or other). In this work, the following categories are considered: - short-haul: passenger aircraft that fly less than 1,500 km ; - medium-haul: passenger aircraft that fly between 1,500 km and 4,000 km ; - long-haul: passenger aircraft that fly more than 4,000 km ; - freight: cargo aircraft (dedicated freighter aircraft) or passenger aircraft including freight (belly cargo).</p> <p>These different categories are heterogeneous because they include different types of aircraft. For simplicity,  representative aircraft types are considered in the following. It is assumed that the short-haul category is composed  of regional aircraft (with turbojets or turboprops) and narrow-body aircraft. It is also assumed that the medium-haul  category is composed of narrow-body aircraft while the long-haul category is composed of wide-body aircraft. Finally,  for freight, no representative aircraft are considered. It is assumed that aircraft in this category are a  weighted average of the previous representative aircraft.</p> <p>The aircraft fleet is then modeled, which will be useful for modeling the evolution of the aircraft fleet. In order to  calibrate the average characteristics of the different fleet categories in 2019, a specific procedure is adopted to  obtain a representative fleet. It is important to note that this approach is a model and that the aircraft fleet is  actually more complex. In the following, the method is illustrated for the passenger aircraft categories.</p> <p>First, the energy consumption per ASK is estimated for each category. The value per ASK is used to isolate the  influence of air traffic levels. For this purpose, emission factors in gCO<sub>2</sub>/RPK are used. These are  derived from the analysis of <sup>14</sup>. They are then converted to energy consumption per ASK  using the average aircraft load factor in 2019 and the emission factors from the previous section. The results are  given in Tab.1.</p> Category Emission factor Energy consumption Short-haul - Regional 172.8 gCO<sub>2</sub>/RPK 1.95 MJ/ASK Short-haul - Narrow-body 98.8 gCO<sub>2</sub>/RPK 1,11 MJ/ASK Medium-haul 76.9 gCO<sub>2</sub>/RPK 0.87 MJ/ASK Long-haul 89.9 gCO<sub>2</sub>/RPK 1.01 MJ/ASK <p>Tab.1 Average aircraft fleet characteristics in 2019.</p> <p>Then, for each category, two representative planes are considered: one for the old generation, another for the  most recent. The characteristics of these aircraft are constructed using a weighting of different aircraft on the  market. This is done using data on the number of aircraft in service, their performance and their missions  <sup>15</sup>. For example, for the medium-haul category, the older representative aircraft is a mix of Airbus and  Boeing aircraft (A319, A320, A321, B737-700, B737-800, B737-900), while the newer representative aircraft is the  Airbus A320neo. The results of energy consumption by ASK are then given in Tab.2.</p> Representative aircraft Energy consumption Representative distribution of the fleet Mean aircraft 0.87 MJ/ASK 100% Old aircraft 0.92 MJ/ASK 77% Recent aircraft 0.70 MJ/ASK 23% <p>Tab.2 Characteristics of representative aircraft for the medium-haul category.</p> <p>Finally, for each category, the representative distribution of old and recent aircraft is determined using the  following equation. The results for the medium-haul category are, for example, given in the previous table. The values  obtained are compared with the actual fleet to check the consistency of the selected representative aircraft.</p> <p>\\(E_{mean} = x~E_{old} + (1-x)~E_{recent}\\)</p> <p>where \\(E_{mean}\\) is the average energy consumption per ASK for the fleet in the category, \\(E_{old}\\) is the average  energy consumption per ASK for the older representative aircraft, \\(E_{recent}\\) is the average energy consumption  per ASK for the newer representative aircraft, and \\(x\\) is the representative share of older aircraft in the fleet.</p>"},{"location":"books/documentation_airtransport/#air-traffic-evolution-modeling","title":"Air traffic evolution modeling","text":"<p>Historical data is used to derive the air traffic evolution model. Fig.2 represents historical values since 1991 as well as a trend model.  The latter was obtained using an exponential function with a fixed growth rate. The model is given in  equation with \\(RPK_{1991}\\) the value of RPK in 1991, \\(x\\) the year and \\(\\tau\\) a  smoothed growth rate. To determine \\(\\tau\\), an optimization is performed using the SLSQP method to minimize the  Root Mean Square (RMS) error between the historical data and the model. This makes it possible to smooth out the  values due to various political crises (September 11 attacks in the United States in 2001, 2008 financial crisis).  The growth rate obtained is 5.5% over the period 1991--2019, with an RMS error of 0.032. By restricting the study  to the last ten years, the growth rate obtained is then 6.5%, which shows an acceleration of air traffic growth  in recent years.</p> <p>\\(RPK(x) = RPK_{1991} ~ (1+\\tau)^{x-1991}\\)</p> <p></p> <p>Fig.2 Modeling the historical evolution of air traffic.</p> <p>This model is therefore relevant for modeling the evolution of air traffic. Therefore, the following model, indexed  from 2019, is used to make projections on the evolution of air traffic. For more detailed scenarios, this model can  be applied by decade using  Compound Annual Growth Rates (CAGR).</p> <p>\\(RPK(x) = RPK_{2019} ~(1+\\tau)^{x-2019}\\)</p> <p>Nevertheless, the difficulty lies in estimating the future growth rate \\(\\tau\\). Indeed, the latter could be impacted for  different reasons. For example, due to the saturation of certain markets (e.g. Europe), the industry anticipates a  decline in this growth rate in the future. Similarly, this rate could become much lower or even negative (which  means a decrease in air traffic) due to crises and/or economic, political, environmental or health measures such  as the Covid-19 epidemic. Moreover, specific settings for the impact of the Covid-19 epidemic are proposed, defining a  year of air traffic recovery compared to a certain level of air traffic compared to 2019.</p> <p>Various industrial and institutional projections are available. Before the Covid-19 epidemic, Airbus and Boeing  respectively projected an annual growth of the total distance flown of 4.4% and 4.7% from 2017  <sup>16</sup>. The ICAO projected an air traffic growth of 4.1% per year between 2015 and 2045. However,  the Covid-19 epidemic has led to a downwards revision of these projections. ATAG now projects a 3.1% annual growth in  air passenger traffic between 2019 and 2050 in its median scenario <sup>17</sup>, while Airbus projects a 3.6%  annual growth for the period 2019-2041 <sup>18</sup>. Despite the Covid-19 health crisis, all the scenarios presented  thus forecast a growth in air traffic in the coming decades.</p>"},{"location":"books/documentation_airtransport/#aircraft-fleet-and-operations-energy-efficiency-improvements","title":"Aircraft fleet and operations: energy efficiency improvements","text":"<p>The parameter that represents the energy efficiency is the energy intensity per passenger per kilometer \\(E/RPK\\). In  this work, this parameter is influenced by three distinct levers: fleet renewal with more efficient aircraft,  operations and load factor. In addition to these levers, specific measures for reducing non-CO<sub>2</sub> effects are also modeled.</p>"},{"location":"books/documentation_airtransport/#improvements-of-aircraft-efficiency","title":"Improvements of aircraft efficiency","text":"<p>Here, efficiency improvements through the use of more efficient aircraft are studied. The parameter modeled is thus  the energy consumption per seat and per kilometer \\(E/ASK\\). Two approaches are presented in the following. On the one  hand, a so-called top-down approach is used to simply model the efficiency improvement via annual  technological gains. On the other hand, an approach called bottom-up is used to model more finely the  evolution of the fleet's energy efficiency by relying on gains per architecture and fleet renewal models. This more  complex approach makes it possible to directly link aircraft design and prospective technological scenarios.</p>"},{"location":"books/documentation_airtransport/#top-down-approach","title":"Top-down approach","text":"<p>In this approach, aircraft efficiency improvements are modelled via a gain in aircraft energy consumption per ASK.  A fixed rate of change is chosen as a parameter. A positive rate implies a reduction in aircraft consumption per RPK.  The negative case corresponding to a reduction in aircraft performance is not considered. This rate is expressed as  a percentage (%). Fleet renewal is considered as regular and is therefore included in this rate. </p> <p>Thus, noting \\(E_{ASK}\\) the energy consumed per ASK, \\(k\\) a given year and \\(\\tau\\) the rate of technological improvement,  the evolution of aircraft efficiency (per category) is given in the following equation.</p> <p>\\(E_{ASK_{k+1}} = E_{ASK_{k}} (1-\\tau)\\)</p> <p>Hydrogen aircraft are taken into account considering specific models. For this, hydrogen aircraft introductions via  logistic functions (detailed in the bottom-up approach) are used, correcting for the evolution of the energy efficiency  of these architectures compared to conventional aircraft.</p>"},{"location":"books/documentation_airtransport/#bottom-up-approach","title":"Bottom-up approach","text":"<p>In this second approach, the objective is to model the evolution of aircraft fleet energy efficiency using fleet  renewal models. This approach is particularly interesting because it facilitates the links with aircraft design.</p> <p>The fleet renewal models developed are based on logistic functions. A formulation of these functions is given  in the following equation, with \\(A\\), \\(k\\) and \\(x_0\\) parameters detailed in the following that allow to fit the model.</p> <p>\\(f(x) = \\frac{A}{1+e^{-k~(x-x_0)}}\\)</p> <p>These functions, also called sigmoids or S-shaped curves, are particularly relevant to model the introduction of a  product in a market. Consequently, they are used in multiple disciplinary fields  <sup>19</sup><sup>20</sup><sup>21</sup>: economics, sociology, demography, technology or even medicine. This type of functions has already been used in the scientific literature to study the  renewal of aircraft fleets <sup>22</sup><sup>23</sup><sup>24</sup><sup>25</sup>.</p> <p>In this work, the logistic functions correspond to the shares that different aircraft architectures represent in the  fleet. In order to use these functions, a calibration of the different coefficients is necessary. The initialization  of the data is performed using the approach with representative aircraft by category explained previously.</p> <p>The coefficient \\(A\\) represents the final value of the function. In this work, its value is initially set to 1 to model  the fact that in the long run, a new aircraft architecture is totally imposed on the market. Then, the coefficient  \\(k\\) allows setting the speed of renewal of the fleet. It can be related to the duration \\(D\\) to replace \\((100-l)\\)% of  the fleet using the following equation. Finally, the parameter \\(x_0\\) is used to define the timing of the introduction of the aircraft in the fleet. It can be computed from the following equation with \\(x_a\\) the year of introduction of  the aircraft, also called Entry-Into-Service (EIS).</p> <p>\\(k = \\frac{ln\\left(\\frac{100}{l}-1\\right)}{D/2}\\)</p> <p>\\(x_0 = x_a + D/2\\)</p> <p>A limitation of these basic models is that they can only be directly used for a single homogeneous category. Indeed,  it is not possible to model a category that is divided into two main architectures on the market. This aspect is  however important to integrate specific architectures such as hydrogen aircraft on the short and medium-haul markets  or narrow-body aircraft on the long-haul category (such as the Airbus A321XLR). Therefore, the models are adapted to  allow the creation of subcategories. To do so, the \\(A\\) coefficient is adjusted to vary the different market shares  within the whole category.</p> <p>Two examples of use are presented in the following. The medium-haul category is considered using representative  aircraft detailed previously. A first simple example is given in Fig.3 which represents the distribution of  different aircraft within a fleet. It is assumed that a new aircraft appears every 15 years with a period of 20 years  for a replacement of 98% of the fleet, i.e. \\(l=2\\). A second example is given in Fig.4. In addition to the previous  assumptions, it is assumed that a new aircraft, representing a new sub-category, appears in 2035 and will eventually  represent 50% of the market.</p> <p></p> <p>Fig.3 Basic use of fleet renewal models.</p> <p></p> <p>Fig.4 Use of fleet renewal models including a subcategory.</p> <p>Knowing how the fleet is renewed from these models, it is possible to estimate the average energy consumption per  seat and per kilometer of the \\(E_{mean}\\) aircraft fleet for year \\(x\\). The following equation is then used from the  performance of each aircraft \\(E_i\\) and the number of seat-kilometers achieved by each aircraft \\(ASK_i\\). The latter is obtained from the total ASK and the annual distribution from the fleet renewal models.</p> <p>\\(E_{mean}(x) = \\frac{\\sum_{i} E_i ~ ASK_i(x)}{\\sum_{i} ASK_i(x)}\\)</p> <p>In addition to fuel consumption, the previous model can also be applied to other characteristics such as NO<sub>x</sub>  or soot emissions. The fleet renewal models also allow to estimate the annual production of aircraft according to the  traffic evolution.</p>"},{"location":"books/documentation_airtransport/#improvements-in-aircraft-operations","title":"Improvements in aircraft operations","text":"<p>The improvement of operations concerns both the ground phases (taxiing, holding, etc.) and the flight phases (trajectory  optimization, air traffic management, formation flights, etc.). The potential gains in fuel consumption estimated  by the industry range from a few percent to about ten percent.</p> <p>Regarding their modeling, it is complex to use historical data since they are often included in data on energy  consumption per seat and per kilometer. Therefore, an approach based on estimates of future gains is considered using  logistic functions as for fleet renewal models. This time, the parameter \\(A\\) represents  the achievable consumption gain. The parameter \\(k\\) corresponds to the implementation speed of the operational measure,  while the parameter \\(x_0\\) allows to set the timing of the implementation. To model the improvement of the operations  more finely, it is possible to superimpose different sigmoid functions, for example when the implementation times or  the commissioning dates differ.</p>"},{"location":"books/documentation_airtransport/#improvements-in-aircraft-load-factor","title":"Improvements in aircraft load factor","text":"<p>To model the evolution of the load factor, a similar approach to the one used for the  energy consumption per ASK is used. The results are summarized in Fig.5. </p> <p></p> <p>Fig.5 Modeling the trend projection of aircraft load factors.</p> <p>Historical data are modeled from the function given in the following equation for year \\(x\\). The  coefficients, given to three significant figures, were determined to minimize the RMS error between the historical  data since 1991 and the model. A small value of 6.6.10<sup>-5</sup> is obtained. </p> <p>\\(LF(x) = 52.3 + \\frac{36.7}{1+e^{-0.0776~(x-2000)}}\\)</p> <p>The model is then used to obtain a trend projection of the load factor. It is interesting to note that the model  converges towards a load factor of 89%, an ambitious value already reached by some airlines.</p> <p>The projection finally is modeled using a second-order polynomial function because of its simplicity. The trend load  factor \\(LF\\) for year \\(x\\) is then modeled using the following equation with parameters \\(a=-5.3.10^{-3}\\) and \\(b=0.36\\)  (given with two significant figures). The RMS error obtained is then 5.3.10<sup>-7</sup>. </p> <p>\\(LF(x) = a~(x-2019)^2 + b~(x-2019) + 82.4\\)</p> <p>Scenarios can thus be defined as for the energy consumption by ASK. For this, this model is used by modifying the  parameters \\(a\\) and \\(b\\) in order to obtain the desired load factor in 2050.</p>"},{"location":"books/documentation_airtransport/#improvements-for-reducing-non-co2-effects","title":"Improvements for reducing non-CO<sub>2</sub> effects","text":"<p>Specific strategies for reducing non-CO<sub>2</sub> effects through aircraft and operation improvements  are also modeled. So far, only the main non-CO<sub>2</sub> effects (NO<sub>x</sub> and contrails) are studied.</p> <p>Regarding NO<sub>x</sub> emissions, their reduction could lead to a reduction of the aviation effective radiative  forcing, although there are still uncertainties about the future effect of NO<sub>x</sub> emissions on climate,  depending in particular on NO<sub>x</sub> and methane background concentrations  <sup>26</sup><sup>27</sup>. The reduction of emissions could nevertheless be achieved by reducing  fuel consumption and/or lowering the NO<sub>x</sub> emission factor. Models similar to those for energy efficiency via  fleet turnover are used to estimate the NO<sub>x</sub> emission factor. In particular, the equation for estimating the  energy consumption in the bottom-up approach can be adapted by replacing the energy consumptions \\(E_i\\) with the  NO<sub>x</sub> emission factors per aircraft.</p> <p>As far as contrails are concerned, several mitigation measures are studied. For instance, operational strategies, based  on trajectory modification, are modeled since they represent promising strategies <sup>28</sup>. These  strategies could be applied on a reduced number of flights. Indeed, a study in the Japanese airspace shows that 2% of  the flights are responsible for 80% of the contrails <sup>29</sup>. Another possibility is to modify  the engines, in particular for reducing the amount of particles emitted <sup>30</sup>. Overall, the implementation of operational strategies, possibly coupled with improved  engines, could reduce the radiative forcing induced by condensation trails from 20% to more than 90%, for marginal  additional fuel consumption <sup>31</sup><sup>29</sup>. In this work, simplified models,  based on logistic functions as in fleet renewal models, are used to model the reduction of contrail-induced radiative  forcing. This time, the parameter \\(A\\) represents the final reduction allowed by the adopted measures. The parameter  \\(k\\) corresponds to the speed of implementation of the strategies, while the parameter \\(x_0\\) allows to set the timing  of the implementation.</p>"},{"location":"books/documentation_airtransport/#aircraft-energy-decarbonization-of-energy","title":"Aircraft energy: decarbonization of energy","text":"<p>The parameter that represents the decarbonization of energy is the CO<sub>2</sub> content of the energy \\(CO_2/E\\).  Its evolution is based on the introduction of alternative energy carriers in the fleet to replace fossil kerosene. The  objective is therefore to estimate the emission factor of alternative energy carriers (only in the form of fuel so far)  over their entire life cycle. The latter is expressed in gCO<sub>2</sub>-eq/MJ<sub>fuel</sub>, but the emissions will  be directly assimilated to CO<sub>2</sub> for simplification purposes. In the following, two approaches are proposed.  The first one is based on a detailed modeling of the fuels and their integration in the fleet. The second is a  simplified approach based on a representative alternative energy carrier. However, the direct impact of alternative  energy carriers on non-CO<sub>2</sub>, which is complex to evaluate <sup>32</sup><sup>30</sup>,  is not directly considered so far because of the low maturity of the few models present in the literature  <sup>22</sup><sup>33</sup>.</p>"},{"location":"books/documentation_airtransport/#detailed-modeling","title":"Detailed modeling","text":"<p>First, the objective is to estimate the main characteristics of alternative energy carriers. These are obtained by  statistical analysis of data from the scientific literature. Many alternative energy carriers are considered to  decarbonize aviation fuel. In this work, three main alternatives are studied: biofuels, hydrogen and electrofuels.  Biofuels and electrofuels are drop-in fuels, while hydrogen requires specific aircraft architectures. The selectivity  of fuels during their production is not directly considered.</p> <p>Biofuels, also called BtL (Biomass-to-Liquid), are fuels derived from biomass. Estimating their emission factor is  complex. In this work, several representative biofuels (not exhaustive) have been defined according to the resource and  the production pathway. It is then possible to define a single representative biofuel by weighting. The resources  considered in this work are waste (household waste or used cooking oil), forest residues, agricultural residues,  dedicated energy crops (lignocellulose, sugar and starch-based materials or vegetable oils) and algae. Regarding the  production pathways, HEFA (Hydroprocessed Esters and Fatty Acids), FT (Fischer-Tropsch) and ATJ (Alcohol-to-Jet)  processes are considered. Not all routes and resources are directly compatible and the industrial production maturity  of the different biofuels differs. </p> <p>The characteristics of these representative biofuels are statistically estimated to obtain the first quartile Q1,  the median and the third quartile Q3. The data used are from  <sup>34</sup><sup>35</sup><sup>36</sup><sup>37</sup><sup>38</sup><sup>39</sup>  for emission factors, as well as from  <sup>40</sup><sup>41</sup><sup>42</sup><sup>43</sup><sup>44</sup><sup>45</sup>  for other data. Emission factors and energy efficiencies are given in Tab. 3 and Tab.4 respectively. In addition,  the HEFA process to convert oil to fuel requires the addition of hydrogen. A median value of  9 MJ<sub>H</sub>2<sub></sub>/MJfuel is used. </p> Pathway Resource Q1 Median Q3 FT Municipal waste - 27.6 - FT Lignocelullose and residues 0.3 7.7 12.6 ATJ Sugar and starch-based materials 33.7 52.2 68.4 HEFA Vegetable oils and algae 42.1 61 73.9 HEFA Used cooking oil - 20.7 - <p>Tab.3 Emission factors in gCO<sub>2</sub>-eq/MJ<sub>fuel</sub> for representative biofuels.</p> Pathway Q1 Median Q3 FT 0.4 0.46 0.49 ATJ 0.31 0.48 0.58 HEFA -- Biomass to oil 0.42 0.66 0.85 HEFA -- Oil to fuel 0.71 0.88 0.92 <p>Tab.4 Energy efficiencies in MJ<sub>fuel</sub>/MJ<sub>biomass</sub> for representative biofuels.</p> <p>Hydrogen can be produced in several ways. In this work, five main pathways are considered. The estimated characteristics  are derived from a statistical analysis of data from the references  <sup>46</sup><sup>47</sup><sup>48</sup><sup>49</sup><sup>50</sup>. On the one hand, its  production can be based on the use of fossil resources via the steam reformation of methane or the gasification of  coal. These are the two most commonly used production methods today. The median values of the emission factors of  these processes are respectively 100 gCO<sub>2</sub>-eq/MJ<sub>H<sub>2</sub></sub> and  192 gCO<sub>2</sub>-eq/MJ<sub>H<sub>2</sub></sub>. The impact of these processes can be reduced by using carbon  capture and storage solutions. In this case, the emission factors are respectively  31 gCO<sub>2</sub>-eq/MJ<sub>H<sub>2</sub></sub> and 41 gCO<sub>2</sub>-eq/MJ<sub>H<sub>2</sub></sub>. On the other  hand, hydrogen can be produced from electricity via the electrolysis of water. The emission factor of this hydrogen  then depends on the emission factor of the electric mix and on a production energy efficiency with a median value of  0.59. Finally, if the hydrogen is used in liquid state, additional losses must be taken into account for the  liquefaction stage. </p> <p>Finally, electrofuels or e-fuels, also called PtL (Power-to-Liquid), are produced from electricity. They require  hydrogen (obtained via electrolysis) and CO<sub>2</sub>, which could be captured directly from CO<sub>2</sub> emitting plants or directly into the atmosphere. In this work, the emission factor of this type of fuel is obtained from the emission factor of the electricity used and an energy efficiency of 0.4 <sup>51</sup>.</p> <p>In a second step, fleet introduction models are used for the drop-in fuels(biofuels and electrofuels). For this,  reference values for the incorporation rates of these fuels in the fleet are chosen (every 10 years, every 5 years...).  An interpolation with polynomial functions (linear, quadratic, cubic) is then performed to determine the annual values.  An application with a quadratic interpolation, based on old objectives of the ReFuelEU initiative, is proposed on  Fig.6. The knowledge of these incorporation rates and of the emission factors of the fuels thus makes it  possible to determine the decarbonization rate of the fleet and thus the CO<sub>2</sub> content of the average energy  used by the fleet annually. On the other hand, as far as hydrogen is concerned, specific models via the fleet renewal  models are used, but the principle remains the same.</p> <p></p> <p>Fig.6 Example scenario for introducing drop-in fuels into the fleet.</p>"},{"location":"books/documentation_airtransport/#simplified-modeling-awaiting-robust-implementation","title":"Simplified modeling (awaiting robust implementation)","text":"<p>A simplified approach is also possible. In the latter, an average alternative energy carrier is considered. The  disadvantage of this approach is that it does not allow to distinguish different types of fuel, and in particular  hydrogen which requires specific architectures. Moreover, it does not allow to easily model the evolution of the  emission factor of a fuel, especially for those based on electricity.</p> <p>First, the notion of decarbonization rate is introduced. The decarbonization rate of a fuel is defined as the reduction of its CO content compared to fossil kerosene. For example, taking the emission factor of fossil kerosene of  88.5 gCO<sub>2</sub>-eq/MJ<sub>fuel</sub> (including direct and indirect emissions), a decarbonization rate of a  fuel of 75% means that its emission factor is 22.1 gCO<sub>2</sub>-eq/MJ<sub>fuel</sub>. More generally, the  decarbonization rate of the aircraft fleet is defined as the reduction in the CO<sub>2</sub> content of the average  energy used by the fleet compared to that of a similar fleet operating on fossil kerosene. </p> <p>In this approach, to model the rate of decarbonization of the fleet, logistic functions are used. This time, the  parameter \\(A\\) represents the final decarbonization rate of the fleet. This parameter corresponds to the  decarbonization rate of the average alternative energy carrier considered. The parameter \\(k\\) corresponds to the  introduction speed of the alternative energy carriers in the fleet, while the parameter \\(x_0\\) allows to set the  integration timing.</p>"},{"location":"books/documentation_airtransport/#bibliography","title":"Bibliography","text":"<ol> <li> <p>Yoichi Kaya, Keiichi Yokobori, and others. Environment, energy, and economy: strategies for sustainability. United Nations University Press Tokyo, 1997.\u00a0\u21a9</p> </li> <li> <p>Birgit Friedl and Michael Getzner. Determinants of CO2 emissions in a small open economy. Ecological economics, 45(1):133\u2013148, 2003. doi:10.1016/S0921-8009(03)00008-9.\u00a0\u21a9</p> </li> <li> <p>William F Lamb, Thomas Wiedmann, Julia Pongratz, Robbie Andrew, Monica Crippa, Jos GJ Olivier, Dominik Wiedenhofer, Giulio Mattioli, Alaa Al Khourdajie, Jo House, and others. A review of trends and drivers of greenhouse gas emissions by sector from 1990 to 2018. Environmental research letters, 16(7):073005, 2021. doi:10.1088/1748-9326/abee4e.\u00a0\u21a9</p> </li> <li> <p>Beng Wah Ang and Fang Q Zhang. A survey of index decomposition analysis in energy and environmental studies. Energy, 25(12):1149\u20131176, 2000. doi:10.1016/S0360-5442(00)00039-6.\u00a0\u21a9</p> </li> <li> <p>Qunwei Wang, Yung-Ho Chiu, and Ching-Ren Chiu. Driving factors behind carbon dioxide emissions in China: A modified production-theoretical decomposition analysis. Energy Economics, 51:252\u2013260, 2015. doi:10.1016/j.eneco.2015.07.009.\u00a0\u21a9</p> </li> <li> <p>Heinz Schandl, Steve Hatfield-Dodds, Thomas Wiedmann, Arne Geschke, Yiyong Cai, James West, David Newth, Tim Baynes, Manfred Lenzen, and Anne Owen. Decoupling global environmental pressure and economic growth: scenarios for energy use, materials use and carbon emissions. Journal of Cleaner Production, 132:45\u201356, 2016. doi:10.1016/j.jclepro.2015.06.100.\u00a0\u21a9</p> </li> <li> <p>Valeria Andreoni and S Galmarini. European CO2 emission trends: A decomposition analysis for water and aviation transport sectors. Energy, 45(1):595\u2013602, 2012. doi:10.1016/j.energy.2012.07.039.\u00a0\u21a9</p> </li> <li> <p>Aure\u0301lien Bigo. Les transports face au d\u00e9fi de la transition \u00e9nerg\u00e9tique. Explorations entre pass\u00e9 et avenir, technologie et sobri\u00e9t\u00e9, acc\u00e9l\u00e9ration et ralentissement. PhD thesis, Institut Polytechnique de Paris, 2020. URL: https://www.theses.fr/2020IPPAX068.\u00a0\u21a9</p> </li> <li> <p>Xiao Liu, Dequn Zhou, Peng Zhou, and Qunwei Wang. What drives CO2 emissions from China\u2019s civil aviation? An exploration using a new generalized PDA method. Transportation Research Part A: Policy and Practice, 99:30\u201345, 2017. doi:10.1016/j.tra.2017.03.002.\u00a0\u21a9</p> </li> <li> <p>Maria Sharmina, Oreane Y Edelenbosch, Charlie Wilson, Rachel Freeman, DEHJ Gernaat, Paul Gilbert, Alice Larkin, EW Littleton, Michael Traut, Detlef P van Vuuren, and others. Decarbonising the critical sectors of aviation, shipping, road freight and industry to limit warming to 1.5-2\u00b0C. Climate Policy, 21(4):455\u2013474, 2021. doi:10.1080/14693062.2020.1831430.\u00a0\u21a9</p> </li> <li> <p>Stefan G\u00f6ssling and Andreas Humpe. The global scale, distribution and growth of aviation: implications for climate change. Global Environmental Change, 65:102194, 2020. doi:10.1016/j.gloenvcha.2020.102194.\u00a0\u21a9</p> </li> <li> <p>Liang Jing, Hassan M. El-Houjeiri, Jean-Christophe Monfort, James Littlefield, Amjaad Al-Qahtani, Yash Dixit, Raymond L. Speth, Adam R. Brandt, Mohammad S. Masnadi, Heather L. MacLean, William Peltier, Deborah Gordon, and Joule A. Bergerson. Understanding variability in petroleum jet fuel life cycle greenhouse gas emissions to inform aviation decarbonization. Nature Communications, 13(1):7853, 2022. doi:10.1038/s41467-022-35392-1.\u00a0\u21a9</p> </li> <li> <p>Scott Delbecq, J\u00e9r\u00f4me Fontane, Nicolas Gourdain, Hugo Mugnier, Thomas Plan\u00e8s, and Florian Simatos. Aviation and climate: a literature review. ISAE-SUPAERO, 2022. doi:10.34849/a66a-vv58.\u00a0\u21a9</p> </li> <li> <p>Brandon Graver, Dan Rutherford, and Sola Zheng. CO2 emissions from commercial aviation: 2013, 2018, and 2019. Technical Report, International Council on Clean Transportation, 2020. URL: https://theicct.org/publication/co2-emissions-from-commercial-aviation-2013-2018-and-2019/.\u00a0\u21a9</p> </li> <li> <p>International Civil Aviation Organization. ICAO Carbon Emissions Calculator Methodology. 2018.\u00a0\u21a9</p> </li> <li> <p>Frank Fichert, Peter Forsyth, and Hans-Martin Niemeier. Aviation and Climate Change: Economic Perspectives on Greenhouse Gas Reduction Policies. Routledge, 2020. doi:10.4324/9781315572406.\u00a0\u21a9</p> </li> <li> <p>Air Transport Action Group. Waypoint 2050. Technical Report, ATAG, 2021. URL: https://aviationbenefits.org/environmental-efficiency/climate-action/waypoint-2050/.\u00a0\u21a9</p> </li> <li> <p>Airbus. Global Market Forecast 2022. Technical Report, Airbus, 2022. URL: https://www.airbus.com/en/products-services/commercial-aircraft/market/global-market-forecast.\u00a0\u21a9</p> </li> <li> <p>Gloria Jarne, Julio Sanchez-Choliz, and Francisco Fatas-Villafranca. \u201cS-shaped\u201d curves in economic growth. A theoretical contribution and an application. Evolutionary and Institutional Economics Review, 3(2):239\u2013259, 2007. doi:10.14441/eier.3.239.\u00a0\u21a9</p> </li> <li> <p>Dmitry Kucharavy and Roland De Guio. Application of S-shaped curves. Procedia Engineering, 9:559\u2013572, 2011. doi:10.1016/j.proeng.2011.03.142.\u00a0\u21a9</p> </li> <li> <p>Dmitry Kucharavy and Roland De Guio. Application of logistic growth curve. Procedia engineering, 131:280\u2013290, 2015. doi:10.1016/j.proeng.2015.12.390.\u00a0\u21a9</p> </li> <li> <p>Volker Grewe, Arvind Gangoli Rao, Tomas Gr\u00f6nstedt, Carlos Xisto, Florian Linke, Joris Melkert, Jan Middel, Barbara Ohlenforst, Simon Blakey, Simon Christie, and others. Evaluating the climate impact of aviation emission scenarios towards the Paris agreement including COVID-19 effects. Nature Communications, 12(1):1\u201310, 2021. doi:10.1038/s41467-021-24091-y.\u00a0\u21a9\u21a9</p> </li> <li> <p>Mohammed Hassan. Quantifying the impacts of vehicle technologies and operational improvements on air transportation system performance. PhD thesis, Georgia Institute of Technology, 2017.\u00a0\u21a9</p> </li> <li> <p>Mohammed Hassan, Alexia Payan, Holger Pfaender, Dimitri N Mavris, Elena Garcia, and Jeff Schutte. Framework development for performance evaluation of the future national airspace system. In 15th AIAA Aviation Technology, Integration, and Operations Conference, 3187. 2015. doi:10.2514/6.2015-3187.\u00a0\u21a9</p> </li> <li> <p>Mohammed Hassan, Holger Pfaender, and Dimitri N Mavris. Impact of Aircraft Technologies on US Fleet CO2 Emissions. In 2018 Aviation Technology, Integration, and Operations Conference, 2870. 2018. doi:10.2514/6.2018-2870.\u00a0\u21a9</p> </li> <li> <p>Agnieszka Skowron, David S. Lee, Rub\u00e9n Rodr\u00edguez De Le\u00f3n, Ling L. Lim, and Bethan Owen. Greater fuel efficiency is potentially preferable to reducing no\\textsubscript x emissions for aviation's climate impacts. Nature Communications, 12(1):564, 2021. doi:10.1038/s41467-020-20771-3.\u00a0\u21a9</p> </li> <li> <p>Etienne Terrenoire, Didier A Hauglustaine, Yann Cohen, Anne Cozic, Richard Valorso, Franck Lef\u00e8vre, and Sigrun Matthes. Impact of present and future aircraft NOx and aerosol emissions on atmospheric composition and associated direct radiative forcing of climate. Atmospheric Chemistry and Physics, 22(18):11987\u201312023, 2022. doi:10.5194/acp-22-11987-2022.\u00a0\u21a9</p> </li> <li> <p>Klaus Martin Gierens, Ling Lim, and Kostas Eleftheratos. A review of various strategies for contrail avoidance. Open Atmospheric Science Journal, 2:1\u20137, 2008. doi:10.2174/1874282300802010001.\u00a0\u21a9</p> </li> <li> <p>Roger Teoh, Ulrich Schumann, Arnab Majumdar, and Marc EJ Stettler. Mitigating the climate forcing of aircraft contrails by small-scale diversions and technology adoption. Environmental Science &amp; Technology, 54(5):2941\u20132950, 2020. doi:10.1021/acs.est.9b05608.\u00a0\u21a9\u21a9</p> </li> <li> <p>Frank Noppel and Riti Singh. Overview on contrail and cirrus cloud avoidance technology. Journal of Aircraft, 44(5):1721\u20131726, 2007. doi:10.2514/1.28655.\u00a0\u21a9\u21a9</p> </li> <li> <p>Sigrun Matthes, Benjamin L\u00fchrs, Katrin Dahlmann, Volker Grewe, Florian Linke, Feijia Yin, Emma Klingaman, and Keith P Shine. Climate-optimized trajectories and robust mitigation potential: Flying ATM4E. Aerospace, 7(11):156, 2020. doi:10.3390/aerospace7110156.\u00a0\u21a9</p> </li> <li> <p>Susanne Marquart, Michael Ponater, Linda Str\u00f6m, and Klaus Gierens. An upgraded estimate of the radiative forcing of cryoplane contrails. Meteorologische Zeitschrift, 14(4):573\u2013582, 2005. doi:10.1127/0941-2948/2005/0057.\u00a0\u21a9</p> </li> <li> <p>Milan Kl\u00f6wer, MR Allen, DS Lee, SR Proud, Leo Gallagher, and Agnieszka Skowron. Quantifying aviation\u2019s contribution to global warming. Environmental Research Letters, 16(10):104027, 2021. doi:10.1088/1748-9326/ac286e.\u00a0\u21a9</p> </li> <li> <p>A. Elgowainy, J. Han, M. Wang, N. Carter, R. Stratton, J. Hileman, A. Malwitz, and S. Balasubramanian. Life-Cycle Analysis of Alternative Aviation Fuels in GREET. Technical Report, United States, Department of Energy Office of Scientific and Technical Information, 2012. URL: https://doi.org/10.2172/1255237.\u00a0\u21a9</p> </li> <li> <p>Matteo Prussi, Uisung Lee, Michael Wang, Robert Malina, Hugo Valin, Farzad Taheripour, C\u00e9sar Velarde, Mark D Staples, Laura Lonza, and James I Hileman. CORSIA: The first internationally adopted approach to calculate life-cycle GHG emissions for aviation fuels. Renewable and Sustainable Energy Reviews, 150:111398, 2021. doi:10.1016/j.rser.2021.111398.\u00a0\u21a9</p> </li> <li> <p>Mark D Staples, Robert Malina, Hakan Olcay, Matthew N Pearlson, James I Hileman, Adam Boies, and Steven RH Barrett. Lifecycle greenhouse gas footprint and minimum selling price of renewable diesel and jet fuel from fermentation and advanced fermentation production technologies. Energy &amp; Environmental Science, 7(5):1545\u20131554, 2014. doi:10.1039/C3EE43655A.\u00a0\u21a9</p> </li> <li> <p>Mark D Staples, Robert Malina, Pooja Suresh, James I Hileman, and Steven RH Barrett. Aviation CO2 emissions reductions from the use of alternative jet fuels. Energy Policy, 114:342\u2013354, 2018. doi:10.1016/j.enpol.2017.12.007.\u00a0\u21a9</p> </li> <li> <p>Russell Stratton, Hsin Min Wong, James Hileman, and others. Life cycle greenhouse gas emissions from alternative jet fuels. Technical Report, Partnership for AiR Transportation Noise and Emissions Reduction, 2010. URL: https://rosap.ntl.bts.gov/view/dot/66442/dot_66442_DS1.pdf.\u00a0\u21a9</p> </li> <li> <p>Xin Zhao, Farzad Taheripour, Robert Malina, Mark D Staples, and Wallace E Tyner. Estimating induced land use change emissions for sustainable aviation biofuel pathways. Science of the Total Environment, 779:146238, 2021. doi:10.1016/j.scitotenv.2021.146238.\u00a0\u21a9</p> </li> <li> <p>Sierk De Jong, Ric Hoefnagels, Andr\u00e9 Faaij, Raphael Slade, Rebecca Mawhood, and Martin Junginger. The feasibility of short-term production strategies for renewable jet fuels \u2013 A comprehensive techno-economic comparison. Biofuels, Bioproducts and Biorefining, 9(6):778\u2013800, 2015. doi:10.1002/bbb.1613.\u00a0\u21a9</p> </li> <li> <p>Jeongwoo Han, Amgad Elgowainy, Hao Cai, and Michael Q Wang. Life-cycle analysis of bio-based aviation fuels. Bioresource technology, 150:447\u2013456, 2013. doi:10.1016/j.biortech.2013.07.153.\u00a0\u21a9</p> </li> <li> <p>Thomas G Kreutz, Eric D Larson, Guangjian Liu, and Robert H Williams. Fischer-Tropsch fuels from coal and biomass. In 25th annual international Pittsburgh coal conference, volume 29. International Pittsburgh Coal Conference Pittsburgh, Pennsylvania, 2008.\u00a0\u21a9</p> </li> <li> <p>Jane O'Malley, Nikita Pavlenko, and Stephanie Searle. Estimating sustainable aviation fuel feedstock availability to meet growing European Union demand. Working paper 2021-13, ICCT, 2021.\u00a0\u21a9</p> </li> <li> <p>Matthew Pearlson, Christoph Wollersheim, and James Hileman. A techno-economic review of hydroprocessed renewable esters and fatty acids for jet fuel production. Biofuels, Bioproducts and Biorefining, 7(1):89\u201396, 2013. doi:10.1002/bbb.1378.\u00a0\u21a9</p> </li> <li> <p>Marshall Wise, Matteo Muratori, and Page Kyle. Biojet fuels and emissions mitigation in aviation: An integrated assessment modeling analysis. Transportation Research Part D: Transport and Environment, 52:244\u2013253, 2017. doi:10.1016/j.trd.2017.03.006.\u00a0\u21a9</p> </li> <li> <p>International Energy Agency. The Future of Hydrogen \u2013 Seizing today\u2019s opportunities. Technical Report, IEA, 2019. URL: https://www.iea.org/reports/the-future-of-hydrogen.\u00a0\u21a9</p> </li> <li> <p>Ibrahim Dincer and Canan Acar. Review and evaluation of hydrogen production methods for better sustainability. International Scientific Journal for Alternative Energy and Ecology (ISJAEE), 2495:14\u201336, 2016. doi:10.1016/j.ijhydene.2014.12.035.\u00a0\u21a9</p> </li> <li> <p>Mengdi Ji and Jianlong Wang. Review and comparison of various hydrogen production methods based on costs and life cycle impact assessment indicators. International Journal of Hydrogen Energy, 46(78):38612\u201338635, 2021. doi:10.1016/j.ijhydene.2021.09.142.\u00a0\u21a9</p> </li> <li> <p>B Parkinson, P Balcombe, JF Speirs, AD Hawkes, and K Hellgardt. Levelized cost of CO2 mitigation from hydrogen production routes. Energy &amp; environmental science, 12(1):19\u201340, 2019. doi:10.1039/C8EE02079E.\u00a0\u21a9</p> </li> <li> <p>Osamah Siddiqui and Ibrahim Dincer. A well to pump life cycle environmental impact assessment of some hydrogen production routes. International Journal of Hydrogen Energy, 44(12):5773\u20135786, 2019. doi:10.1016/j.ijhydene.2019.01.118.\u00a0\u21a9</p> </li> <li> <p>Falko Ueckerdt, Christian Bauer, Alois Dirnaichner, Jordan Everall, Romain Sacchi, and Gunnar Luderer. Potential and risks of hydrogen-based e-fuels in climate change mitigation. Nature Climate Change, 11(5):384\u2013393, 2021. doi:10.1038/s41558-021-01032-7.\u00a0\u21a9</p> </li> </ol>"},{"location":"books/documentation_architecture/","title":"Architecture","text":"<p>This part of the documentation is deprecated. It describes AeroMAPS in late 2023</p> <p>It will be updated soon.!</p> <p>The simplified current architecture of AeroMAPS is given in Fig.1.</p> <p> Fig.1 Simplified architecture of AeroMAPS.</p> <p>First, the future air transport system is modeled. Three main elements are considered to represent it: an air traffic  volume (freight or passengers), an aircraft fleet that operates the traffic, and that is powered by an energy mix. For each of these elements, exogenous data to represent future evolutions and developments are used.</p> <p>Secondly, the impacts associated with future air transport are assessed. Currently, only environmental assessments  are performed, estimating for example the climate impacts of aviation (via CO<sub>2</sub> emissions and  non-CO<sub>2</sub> effects) and the consumption of energy resources. A specific module for economic impacts,  such as fuel costs or direct operation costs, is currently under development. </p> <p>Lastly, these impacts are compared to different sustainability targets. For this purpose, exogenous choices  of environmental target allocations are considered, in order to directly compare the impacts of aviation with  sector-specific targets. </p>"},{"location":"books/documentation_gui/","title":"Use of the graphical user interface","text":"<p>This documentation supports the V1 graphical user interface (GUI) for AeroMAPS</p> <p>A new UI is now deployed, in which most of the advice presented here still apply. The documentation will be updated soon.</p> <p>This page guides the user through the handling of the AeroMAPS Graphical User Interface (GUI). It is recommended to use  it on a computer. First, a tutorial is provided for understanding the use of the GUI. Then, the  default settings used on the GUI are provided (for details concerning the models, refer to the dedicated sections of  this documentation). Finally, a procedure for using the GUI locally is presented.</p>"},{"location":"books/documentation_gui/#tutorial","title":"Tutorial","text":"<p>The AeroMAPS GUI is composed of 3 tabs:  - Simulator which is the integrated simulator to directly simulate prospective scenarios for air transport ; - Data which allows to visualize data and retrieve them in CSV format in order to post-process them ; - About AeroMAPS which provides brief information, explanations and documentation about the framework.</p> <p>Navigating on the tool and on the explanatory tabs is quite intuitive by clicking on the corresponding tabs. To adjust  the size of the tool to the size of his screen, the user can use the zoom (out) functionalities of his browser.  The display language can be chosen : English or French (coming soon).</p> <p>To use the AeroMAPS simulator, the user must select the Simulator tab. Two distinct blocks then appear on the  user's screen (see the following figure). </p> <p></p> <p>On the one hand, three different graphs are available in the upper part of the screen, with the possibility of  selecting specific figures using drop-down menus. A first graph allows plotting  CO<sub>2</sub> emissions or effective radiative forcing from aviation. A second one provide figures concerning the  assessment of the sustainability of a scenario, for instance in terms of climate. A last graph represents a set of  figures for analyzing scenarios more deeply.</p> <p>On the other hand, a set of sliders is available in the lower part of the screen to set scenario parameters. To facilitate the handling of the tool, the user can use three distinct modes of varying complexity. In the  Discovery mode, the user directly uses sliders: this mode provides a good understanding of the  sensitivities of the main levers of action. In the Scenarios mode, the user displays scenarios that have already been  defined and parameterized: this is the easiest mode to use which only allows analyzing scenarios. Finally, the  Advanced mode, not directly available on the GUI, links to the AeroMAPS GitHub to be able to manipulate in detail the  AeroMAPS framework using Jupyter Notebooks.</p> <p>NOTE:  Additional information on the different sliders on the Discovery mode is provided by hovering  the mouse over them (tooltip).</p> <p>To illustrate the handling of AeroMAPS, an animation is given below. In this animation, the user tries out different  AeroMAPS functionalities: moving on the tabs, using different simulator modes, displaying different figures, setting  scenario parameters.</p> <p></p>"},{"location":"books/documentation_gui/#reference-settings","title":"Reference settings","text":"<p>The different default settings for using the interface are detailed in the following, both for the Discovery mode and the Scenarios mode. To access the detailed data, the advanced user can directly check the values into the source code in the GUI section.</p>"},{"location":"books/documentation_gui/#discovery-mode","title":"Discovery mode","text":"<p>In this mode, the user can play with different sliders corresponding roughly to the AeroMAPS architecture. On the  one hand, aviation settings are provided for modeling the air transport evolution through air traffic, aircraft  fleet and operations, and aircraft energy. On the other hand, environmental settings are given via climate and energy  assumptions and allocations choices.</p>"},{"location":"books/documentation_gui/#air-traffic","title":"Air traffic","text":"<p>The user can first make assumptions on the evolution of air traffic.  By default, a modeling of Covid-19 epidemic is included. It significantly disrupted global air traffic in 2020 and its consequences are likely to disrupt global traffic for several years. To take account of this  epidemic, a 66% decline in air traffic in 2020 compared with 2019 and a return to the 2019 level by 2024 according to  IATA are considered. This modeling also takes into account the decrease aircraft load factor in 2020, which has dropped to  65.2%, against 82.4% in 2019. Similarly, due to the fact that more efficient aircraft did not fly, overall fleet  performance has dropped (energy intensity per ASK increased by 30.5%). Thus, due to these factors, a paradoxical  situation is obtained. Indeed, this drop in performance leads here to an increase in emissions compared to those  expected without modification of the efficiency levers of action.</p> <p>Overall, the user can directly define mean air traffic growth rates on the period 2020--2050 for the four considered  markets in the model: passenger short-range, passenger medium-range, passenger long-range and freight. By default,  these values are fixed to 3% per year, i.e. values close to aviation industry's projections <sup>1</sup>.</p> <p>Moreover, an option is proposed for modeling a reduction of short-range flights, which could be induced by modal shift (substitution with rail traffic for instance) or political air route ban. Therefore, an illustrative reduction of 50% of short-range flights is integrated. The implementation is based on a logistic function with a starting year in 2025 and  a duration of 5 years.</p> <p>Lastly, a last option is provided for studying societal aspects on the distribution of flights, based on  <sup>2</sup>. The authors show that only 11% of the world's population flies, and only between 2 and 4%  go abroad. Moreover,'frequent flyers', about 1% of the world's population, who fly an average of 56,000 km per year  (about 3 long-range trips), are responsible for about 50% of aviation CO<sub>2</sub> emissions, taking into account  their number of flights but also the more frequent use of upper classes. Therefore, an option for halving the number of flights of these people is present, by reducing by 25% the traffic (via RPK) for each market. The implementation is based on a logistic function with a starting year in 2025 and a duration of 5 years.</p>"},{"location":"books/documentation_gui/#aircraft-fleet-and-operations","title":"Aircraft fleet and operations","text":"<p>The user can improve the aircraft fleet and operations. </p> <p>For that, a first slider allows introducing new aircraft into the fleet, which can be improved in terms of propulsion (more efficient engines), aerodynamics, mass, systems or breakthrough architectures. Whereas an option corresponds to an efficiency improvement based on a basic fleet renewal with the current more efficient aircraft, others allow  integrating future more efficient architecture. A \"trend\" option includes a deployment similar to the previous one in  terms of efficiency gains, Entry-Into-Service (EIS) year and fleet renewal rate, which corresponds to an annual  efficiency gains of around 1%. A more \"optimistic\" solution considers the same assumptions with an accelerated fleet  turnover. Finally, an \"ambitious\" option takes into account the introduction of very efficient aircraft.</p> <p>Another slider represents the improvements in terms of operations through flight trajectories, air traffic management,  formation flights or ground operations evolution. The user can choose efficiency gains more or less ambitious, from 0% to 12% by 2050. For each option, the settings corresponding to the deployment of these solutions are similar, i.e. a  duration of deployment of 20 years (for reaching 98% of the total gains) from 2025.</p> <p>The user can also set the evolution of the mean aircraft load factor in 2050. The default setting corresponds to a  trend estimation of 89% by 2050, but other settings are available: 82.4%, 85%, 92%, 95%. The more pessimistic option  corresponds to 2019 value, whereas the more optimistic one is probably be hard to reach for all the fleet even if some airlines have  already reached this value in 2019.</p> <p>Lastly, two options can be activated by the user. On the one hand, the use of turboprop aircraft on short-range market is proposed for reducing fuel consumption (but at the cost of lower flight speed). The considered EIS is 2030 with a  20% reduction in fuel consumption per ASK compared with turbofan engines. On the other hand, another option consists of  dedicated operational measures for avoiding contrails. It is assumed a contrails climate impact reduction of 59.4% for a fuel overconsumption of 0.014%. The implementation is based on a logistic function with a starting year in 2030 and a  duration of 15 years.</p>"},{"location":"books/documentation_gui/#aircraft-energy","title":"Aircraft energy","text":"<p>The user can define the energy that will be use by the future aircraft fleet. Here, only three main alternative fuels  are considered as alternative energy carriers.</p> <p>On the one hand, the user can define the future mix of drop-in fuels, i.e. fuels that can (almost) directly replace  fossil kerosene such as biofuels and electrofuels. A default option corresponds to the exclusive use of fossil kerosene. Then, a biofuel option represents the exclusive use of biofuels by 2050, with a progressive replacement of fossil kerosene by biofuels from 2025. A similar one represents the exclusive use of electrofuels by 2050, with a progressive replacement of fossil kerosene by electrofuels from 2030. Finally, the ReFuelEU option corresponds to the implementation of the blending mandates at the european level, considering only drop-in fuels. This option considers the deployment of  biofuels from 2025 and electrofuels from 2030, with a final mix in 2050 of 35% biofuels, 35% electrofuels and 30% fossil kerosene.</p> <p>On the other hand, the user can also introduce hydrogen aircraft into the fleet. This type of aircraft also requires  dedicated architectures (unlike drop-in fuels) which will probably be limited to low ranges for structural reasons (low  gravimetric index for hydrogen tanks). As a consequence, the settings used are based on the fleet renewal values. The default option does not consider the use of hydrogen aircraft. A limited introduction considers a late EIS in 2040  only for 50% of the short-range market, whereas a moderate one considers a forecast EIS in 2035 for the same market.  Finally, an ambitious option includes the large deployment of hydrogen aircraft for all the short-range market from  2035 and 50% of the medium-range market from 2040.</p> <p>Concerning the production of these alternative fuels, the user can make assumptions on biofuel emission factors,  hydrogen production pathways and electric mix. For biofuels, the default value corresponds to the median value for HEFA pathway (20.7 gCO<sub>2</sub>-eq/MJ<sub>fuel</sub>), which is the most used pathway currently.  A high-carbon value of 52.2 gCO<sub>2</sub>-eq/MJ<sub>fuel</sub> (corresponding to AtJ pathway) and a low-carbon value of 7.7 gCO<sub>2</sub>-eq/MJ<sub>fuel</sub> (corresponding to FT pathway) can also be chosen. These values can be  compared to the value of 88.7 gCO<sub>2</sub>-eq/MJ<sub>fuel</sub> for fossil kerosene (including production emissions). Concerning hydrogen production, four options are proposed: a current one which is mainly a mix between steam reformation of methane or the gasification of coal, two other ones based on steam reformation of methane only with or without carbon capture and storage (CCS), a last one based on electrolysis whose emission factor depends on electricity mix. Finally,  the electric mix can be assumed as more or less low-carbon, with a default option corresponding to the current world  grid electric mix (429 gCO<sub>2</sub>-eq/kWh). In addition to an illustrative option with high-carbon intensive electricity (1100 gCO<sub>2</sub>-eq/kWh), two examples of power grid can be considered, assuming a transition reaching  medium- (240 gCO<sub>2</sub>-eq/kWh) or low-carbon (70 gCO<sub>2</sub>-eq/kWh) final mixes by 2050. Moreover, a last  option corresponds to dedicated electricity from renewable (20 gCO<sub>2</sub>-eq/kWh) from today.</p>"},{"location":"books/documentation_gui/#climate-energy","title":"Climate &amp; Energy","text":"<p>The user has to set environmental assumptions. </p> <p>On the one hand, several sliders are available concerning the climate settings. First, the user has to choose the  temperature target for the assessment of the climate sustainability (between +1.5\u00b0C and +2.0\u00b0C, corresponding to extreme values from Paris Agreement), as well as the chances of success for achieving this climate target. This last value  corresponds to the percentile considered for the TCRE coefficient used in climate sciences (for instance for estimating net carbon budgets). The default setting represents SBTi targets (+1.8\u00b0C with 67% of success). Moreover, the user can  assume Carbon Dioxide Removal (CDR), which corresponds to negative emissions through for instance reforestation,  bioenergy with capture and carbon storage (BECSS) or direct air capture with carbon storage (DACCS). By default, this  option is disabled but the user can select values obtained from a statistical analysis of IPCC AR6 (Q1, median, Q3). The  cumulative CDR over the period 2020--2100 ranges between 285 GtCO<sub>2</sub> and 733 GtCO<sub>2</sub> with a median  value of 527 GtCO<sub>2</sub>. It allows estimating gross carbon budget.</p> <p>On the other hand, two sliders are available concerning the energy settings. Indeed, the user can make assumptions on biomass and electricity availability in 2050. The biomass can be waste, agricultural or forrest residues, energy crops  and algae. The default value of 164 EJ of biomass available in 2050 corresponds to a median value obtained from a  statistical analysis of scientific papers and reports. The other values correspond to other statistical characteristics, ranging from 37 EJ to 557 EJ. For electricity, the values range from 100 EJ (current availability) to 300 EJ, based on  IPCC, IRENA and IEA data. A default and arbitrary value of 200 EJ is considered.</p>"},{"location":"books/documentation_gui/#allocations","title":"Allocations","text":"<p>Last, but not least, the user can assume allocation rules concerning the different environmental limits considered in the model. It finally allows comparing absolute impacts of aviation with dedicated targets/limits for the sector. The term allocation means here the result of complex mechanisms of negotiation, competition, arbitration and  regulation for resources access. Here, four budgets, that are estimated using the climate and energy settings, are  considered: the carbon budget, equivalent carbon budget (which corresponds roughly to temperature), biomass budget and  electricity budget. Each time, several allocations are proposed. More specifically, grandfathering allocations can be  assumed, which corresponds to the current impact of aviation on an environmental impact. For instance, aviation  representing currently 2.6% of CO<sub>2</sub> emissions, the grandfathering allocation for carbon budget corresponds to  2.6%. The justification of the default values are provided on the tooltips.</p>"},{"location":"books/documentation_gui/#scenarios-mode","title":"Scenarios mode","text":"<p>A database is under construction for the Scenarios mode. A first example is nevertheless provided on the GUI, based on a scenario published in an academic paper <sup>3</sup>.</p>"},{"location":"books/documentation_gui/#local-use-of-the-gui","title":"Local use of the GUI","text":"<p>The GUI can be used directly from the following website: https://aeromaps.isae-supaero.fr. However, it is also possible  to use the GUI locally. For this purpose, after installing AeroMAPS (see dedicated section), this command can be used:</p> <pre><code>aeromaps run\n</code></pre>"},{"location":"books/documentation_gui/#bibliography","title":"Bibliography","text":"<ol> <li> <p>Air Transport Action Group. Waypoint 2050. Technical Report, ATAG, 2021. URL: https://aviationbenefits.org/environmental-efficiency/climate-action/waypoint-2050/.\u00a0\u21a9</p> </li> <li> <p>Stefan G\u00f6ssling and Andreas Humpe. The global scale, distribution and growth of aviation: implications for climate change. Global Environmental Change, 65:102194, 2020. doi:10.1016/j.gloenvcha.2020.102194.\u00a0\u21a9</p> </li> <li> <p>Antoine Salgas, Thomas Plan\u00e8s, Scott Delbecq, Florian Simatos, and Gilles Lafforgue. Cost estimation of the use of low-carbon fuels in prospective scenarios for air transport. In AIAA SCITECH 2023 Forum, 2328. 2023. doi:10.2514/6.2023-2328.\u00a0\u21a9</p> </li> </ol>"},{"location":"books/documentation_impacts/","title":"Impact modeling and sustainability assessment","text":"<p>This part of the documentation is deprecated. It describes AeroMAPS in late 2023</p> <p>It will be updated soon.!</p> <p>After defining the evolution of air transport via dedicated models, specific models evaluate the associated  impacts, and then compare them with limits via a sustainability assessment.</p>"},{"location":"books/documentation_impacts/#impact-modeling","title":"Impact modeling","text":"<p>In the following, the models used for estimating the impacts induced by air transport are described. Currently, the  majority of impact modeling concern environmental impacts.</p>"},{"location":"books/documentation_impacts/#emissions-and-climate-impacts","title":"Emissions and climate impacts","text":""},{"location":"books/documentation_impacts/#co2-emissions","title":"CO<sub>2</sub> emissions","text":"<p>Based on the modeling of the air transport system through a Kaya decomposition, the estimation of the evolution of  CO<sub>2</sub> emissions is simple by multiplying the different factors. In addition, a coefficient corresponding to  other life cycle emissions (excluding combustion and fuel production) can also be applied, but it only represents a few  percent of the aviation environmental impacts <sup>1</sup>.</p>"},{"location":"books/documentation_impacts/#non-co2-emissions","title":"Non-CO<sub>2</sub> emissions","text":"<p>For estimating non-CO<sub>2</sub> emissions, the concept of Emission Index (EI) is used. They make it possible to  obtain different emissions (NO<sub>x</sub>, SO<sub>x</sub>...) depending on fuel consumption (or CO<sub>2</sub>  emissions). Values for fossil kerosene from <sup>2</sup> have been used and are provided in Tab.1. The values can be adapted for alternative energy carriers.</p> Emission Value Unit CO<sub>2</sub> 3.15 kgCO<sub>2</sub>/kg<sub>fuel</sub> H<sub>2</sub>O 1.23 kgH<sub>2</sub>O/kg<sub>fuel</sub> NO<sub>x</sub> 15.1 gNO<sub>x</sub>/kg<sub>fuel</sub> Aerosols (soot) 0.03 gBC/kg<sub>fuel</sub> Aerosols (sulfur) 1.2 gSO<sub>x</sub>/kg<sub>fuel</sub> <p>Tab.1 Emission Index for fossil kerosene combustion.</p> <p>Based on these data, the estimation of the climate impact of aviation is achieved by the calculation of the ERF  (Effective Radiative Forcing), which is based on the use of coefficients for the different impacts. These are obtained  through an analysis of the data from <sup>2</sup> and are summarized in Tab.2. CO<sub>2</sub> emissions are cumulative: therefore, at first order, the coefficient to estimate the ERF must be applied on the cumulative  CO<sub>2</sub> emissions. The impact of the other emissions is estimated from the annual emissions. Finally, the impact  of contrails is assumed to be correlated with the total annual distance flown.</p> Climate impact Value Unit CO<sub>2</sub> (cumulative) 0.88 mW/m<sup>2</sup>/GtCO<sub>2</sub> H<sub>2</sub>O 0.0052 mW/m<sup>2</sup>/TgH<sub>2</sub>O NO<sub>x</sub> 11.55 mW/m<sup>2</sup>/TgN Aerosols (soot) 100.7 mW/m<sup>2</sup>/TgBC Aerosols (sulfur) -19.9 mW/m<sup>2</sup>/TgSO<sub>2</sub> Condensation trails 1.058.10<sup>-9</sup> mW/m<sup>2</sup>/km <p>Tab.2 Coefficients for estimating the ERF of aviation climate impacts.</p> <p>Using the data and taking into account CO<sub>2</sub> and non-CO<sub>2</sub> effects, aviation (including private and  military) generated 3.8% of the effective radiative forcing between 1750 and 2018 and commercial aviation is  responsible for 5.1% of the increase in effective radiative forcing over a more recent period (2000--2018), compared to global ERF estimated in the IPCC AR6.</p> <p>Lastly, equivalent emissions can be estimated to simplify the comparison with CO<sub>2</sub> emissions, but also to  estimate the impacts on the temperature evolution in a second step. Multiple metrics are available in the scientific  literature to estimate them <sup>3</sup><sup>4</sup>: GWP, AGWP, GTP, AGTP, etc. GWP is the most known and used metric, often used with a 100-year time horizon. However, this metric is limited for representing the evolution in terms of temperature for Short-Lived Climate Pollutants (SLCPs) <sup>5</sup>, which is the case for aviation non-CO<sub>2</sub> effects. As a consequence, an alternative metric is used here. GWP* is an improved climate metric developed recently  <sup>6</sup><sup>7</sup><sup>8</sup>, one of the major interests of which is to better evaluate the effect of SLCPs. It allows to estimate the equivalent emissions in CO<sub>2</sub>-we for a better  match with the evolution in temperature (warming equivalent). In this sense, it thus represents a simplified  climate model compared to other more complex climate models that may require long computation times  <sup>9</sup>. Compared to GWP, it does not only take into account the absolute value of the emissions but also the variation of the emission rate. The following equation allows estimating the equivalent emissions, noted  \\(E_{CO_2\\text{-we}}\\), of a gas \\(G\\) for a time horizon \\(H\\), as a function of the absolute emissions \\(E_G\\)  and the variation of emissions \\(\\Delta E_G\\) over a period \\(\\Delta t\\). The parameters \\(r\\) and \\(s\\) depend on the gas and  represent the influence of cumulative or short-term effects.</p> <p>\\(E_{CO_2\\text{-we}} = \\text{GWP}_H ~ \\left(r ~\\frac{\\Delta E_G}{\\Delta t}~H + s~E_G \\right)\\)</p> <p>This equation can be modified to be used for aviation non-CO<sub>2</sub> effects, based on assumptions from <sup>6</sup><sup>2</sup>, with in particular \\(r=1\\) and \\(s=0\\). As a consequence, the following equation is used with \\(E_{CO_2\\text{-}we}\\) the equivalent emissions of a non-CO<sub>2</sub> effect for a given year, \\(\\Delta F\\) the corresponding variation of the ERF over a period \\(\\Delta t\\) of 20 years (smoothed over 5 years to better  represent global trends), a time horizon \\(H\\) of 100 years and the absolute global warming potential of CO<sub>2</sub>  over 100 years \\(AGWP_H\\) of 88 yr.mW/m<sup>2</sup>/GtCO<sub>2</sub>. </p> <p>\\(E_{CO_2\\text{-}we} = \\frac{\\Delta F}{\\Delta t} \\frac{H}{AGWP_H}\\)</p>"},{"location":"books/documentation_impacts/#temperature-estimation","title":"Temperature estimation","text":"<p>Based on the knowledge of the CO<sub>2</sub> emissions and non-CO<sub>2</sub> effects via equivalent emissions, it is  possible to estimate the temperature increase due to air transport \\(T_{k}\\) for the year \\(k\\). For this purpose, the  following equation is used with \\(T_{2019}\\) the temperature increase from air transport in 2019 (from <sup>10</sup>), \\(E_{CO_2, k}\\) the annual CO<sub>2</sub> emissions and \\(E_{CO_2\\text{-}we, k}\\) the annual equivalent emissions for non-CO<sub>2</sub> effects using GWP*. The value of the TCRE (Transient Climate  Response to cumulative carbon Emissions) depends on climate model settings, with median estimates on the order of  0.45\u00b0C/1000GtCO<sub>2</sub>. However, it is also possible to estimate the temperature increase from air transport using  dedicated climate models for more accurate results.</p> <p>\\(T_{k} = T_{2019} + TCRE ~ \\sum_{i=2020}^{k} (E_{CO_2, k} + E_{CO_2\\text{-}we, k})\\)</p>"},{"location":"books/documentation_impacts/#energy-resources","title":"Energy resources","text":"<p>The description of the energy carriers envisaged for air transport makes it possible to estimate the quantities of  fuels to be used (embarked energy), but also the quantities of energy required to produce them using conversion efficiencies. The quantities of biomass and electricity consumed are then directly calculated. The selectivity of the  pathways producing these energy carriers, defined as the proportion of kerosene in the fuel output (usually measured by  energy), can also be taken into account. It allows to estimate the amount of energy that has to be used to produce  kerosene and other outputs. However, in general, an allocation of consumption is made to other outputs for estimating  the \"real consumption\" due to kerosene (which means that selectivity is not taken into account). </p>"},{"location":"books/documentation_impacts/#economic","title":"Economic","text":"<p>The current cost models implemented in AeroMAPS are described in this section. A recap of the energy cost  models is first provided. Alternative energy cost models were presented in detail in <sup>11</sup>, with a model taking as an input each fuel pathway annual energy consumption to derive annual energy expenses and the required investments  chronology for the energy sector. A direct operating cost model adapted to AeroMAPS was recalibrated in <sup>12</sup> and adapted to AeroMAPS in <sup>13</sup>.</p>"},{"location":"books/documentation_impacts/#alternative-energy-cost-model","title":"Alternative energy cost model","text":"<p>As mentioned in the air transport modelling section, three biofuel production pathways are modelled within AeroMAPS: Hydroprocessed Esters and Fatty Acids  (HEFA), Fischer-Tropsch (FT), and Alcohol-To-Jet (AtJ). Regarding their production costs, three main drivers are  identified by the literature <sup>14</sup><sup>15</sup>: the capital required to build a conversion plant (Capital Expenditures \u001f CapEx), and the operational expenditures, in which we can distinguish between the supply of energy to be converted, referred  to as feedstock in the following, and other expenses (personnel, various inputs, maintenance, etc.), referred to as OpEx. Despite large new scale-up plans for theses fuels like ReFuelEU, these are still niche  markets, meaning that no mature price exists for the trade of these biofuels. A proxy metric used is the Minimal Fuel  Selling Price (MFSP). It is the fuel selling price at which the fuel production project has a null Net Present Value  (NPV). This value is the difference between the expenses and the revenues from a project during all its lifespan and considering the time value of money: a large investment immobilized in a project whose revenues occurs much latter  represents an opportunity cost. It is considered by the discount rate r, which discounts future cash flows. Overall, the MFSP can be determined using the following equation, where \\(CAPEX_t\\) are the capital expenditures at year \\(t\\), \\(OPEX_t\\) the operational  expenditure on the same year, feedstock expenditures \\(FEED_t\\) excluded. \\(P_t\\) is the quantity of fuel produced. One can  see that MFSP is indeed the minimal constant price at which the fuel should be sold to ensure the project profitability.</p> <p>\\(MFSP = \\frac{\\sum_{t=0}^{N-1}\\frac{CAPEX_t}{(1+r)^t}+\\frac{OPEX_t}{(1+r)^t}+\\frac{FEED_t}{(1+r)^t}}{\\sum_{t=0}^{N-1}\\frac{P_t}{(1+r)^t}}\\)</p> <p>In AeroMAPS, the biofuel MFSP were directly taken from a literature review <sup>16</sup><sup>14</sup><sup>15</sup>, and the CapEx values were also taken or estimated by reversing the previous equation under standard financial assumptions. It allows to estimate  the annual investment required in each production pathway besides computing the MFSP of the fuel used. Once this  MFSP is known, computing the extra cost for the airlines is straightforward by subtracting the cost incurred by  purchasing a similar amount of fossil kerosene, assuming both fuels are perfect substitutes.  A last metric is used: the carbon abatement cost \\(CAC\\). It combines the MFSP of a fuel with its environmental  benefit, which is modeled in the environmental impact module of the tool. For the biofuel  \\(i\\), it is the ratio between the cost difference \\(\\Delta_C\\) to the fossil reference and the emission factor difference \\(\\Delta_{EF}\\) with the same fossil reference, as shown below. It is used with \u001f/tCO2 as a unit and allows to evaluate the economic  efficiency of various alternative fuels. The concept can be generalized to any decarbonization measure.</p> <p>\\(CA_i =\\frac{\\Delta C}{\\Delta EF}= \\frac{C_i-C_{fossil}}{EF_{fossil} -EF_{i}}\\)</p> <p>Both electrofuels and hydrogen are modelled in an equivalent way as biofuels. Schematically, hydrogen can  be either used directly, burned in a gas turbine or as a fuel of a redox reaction in a fuel cell, or indirectly through the  production of a synthetic kerosene. In the latter case, it is combined with CO2 in a Fischer-Tropsch (amongst others) pathway to produce a drop-in fuel. The cost modelling follows a similar process as before, but the MFSP equation is this time  directly used as an explicit MFSP model. Besides, it is adapted to index the hydrogen price on the yearly  energy price (equivalent of feedstock for biofuels). For hydrogen production, electrolysis, steam methane reforming and coal gasification are modeled. Carbon Capture and Storage can be added to the fossil pathways. Reference technological values on CapEx, OpEx and efficiencies are taken from <sup>17</sup><sup>18</sup><sup>19</sup>. When hydrogen is directly used, the cost of other production steps has to be added to its total cost. For instance, for volume reasons, its use in  aircraft could require its liquefaction, and the supply chain (transport, storage and refuelling) would be modified as  well. Those costs are also modelled in the module. The carbon abatement cost is thus computed using the equation above as well. The economic modelling  of electrofuels is similar, though a last cost component should be accounted for: the CO2, whose direct air capture is a  major cost driver.</p> <p>Lastly, the expenses for kerosene are also modelled according to its market price specified by the user.  By default, it is set to its average historical price (0.41\u001f/L). Note that alternative fuel market is not modelled.  MFSPs are therefore a lower bound of their potential prices.  Kerosene production CapEx (plant renewal and/or expansion) is not modelled so far.</p> <p>The user is also able to specify a uniform carbon tax, that is applied to all energies (fossil, biofuel, e-fuel and hydrogen) using their emission factors. Two metrics are computed: a supplement to the previous MFSP and the total expenses (or fiscal revenue) for each pathway using the associated consumption as well. By default, a fictional carbon tax implementing in full the French Value for Climate Action <sup>20</sup> is used.</p>"},{"location":"books/documentation_impacts/#direct-operating-cost-doc-model","title":"Direct operating cost (DOC) model","text":"<p>Airline costs can be split into two informal categories: the costs directly related to operating an aircraft and  those related to general business operations named non-operating costs (administration, sales, ...). For the former  category, they can be further split between Direct Operating Cost (DOC) and indirect operating costs.  Like non-operating costs, indirect operating costs are not directly linked to the aircraft operation but rather to passenger service. With a simplified approach, there are five main categories in the DOC: capital (owning an aircraft), crew, fuel,  maintenance, and fees/taxes.  In AeroMAPS, a further simplification is made by using three categories: fuel (or energy), non-energy and carbon taxes.</p> <p>Explicit direct operating cost models are presented in <sup>21</sup>, on a per flight hour basis. These models depend directly on the aircraft characteristics. They were recalibrated using United States Bureau of Transportation Statistics data and adapted to a per flight basis in <sup>12</sup>. Since AeroMAPS uses a global top-down approach to model flights by simulating the evolution of the Revenue Passengers Kilometres (RPK) for different  markets rather than aggregating many flights, the direct use of these cost models would be of little interest. Therefore,  average values for selected aircraft and distance categories were extracted from the results of <sup>12</sup> based on the full simulation of a year (2019) of US airlines flight. Note that it introduces an obvious geographical bias, some costs being  widely dependent on the country or the airline (crew, capital structure, age of the fleet, \u001f). However, the lack of  reliable detailed financial data to recalibrate the cost model made this limitation necessary. </p> <p>For non-energy DOC, average costs per aircraft type (regional jet, single-aisle aircraft on short and medium-range routes and long-range), per Available Seat Kilometre (ASK) are used as a starting point. Their evolution is modelled using two different possibilities, like aircraft efficiency. Either simple models implement an annual, category-wide evolution in non-energy DOCs,  or bottom-up fleet renewal models are used with discrete DOC values for each aircraft introduced. </p> <p>Concerning the fuel DOC, it is directly linked to the energy cost module described before. Indeed, the fuel cost is simply obtained by  multiplying each aircraft category energy consumption by the average fuel price from the energy cost module. For the moment, each  aircraft type in the drop-in fleet is considered to use a blend of all the pathways of the scenario (for example, a situation  in which a new generation aircraft uses 100% SAFs while the older generation uses only fossil kerosene is not  considered).</p>"},{"location":"books/documentation_impacts/#manufacturing-cost-model","title":"Manufacturing cost model","text":"<p>This model is under implementation, but a beta version is described in <sup>13</sup>.</p>"},{"location":"books/documentation_impacts/#sustainability-assessment","title":"Sustainability assessment","text":"<p>In the following, the methodologies used to assess the environmental sustainability of scenarios are presented,  based on estimates of induced environmental impacts. Only climate and energy issues are considered. Indeed, these  two environmental issues are the most impacting when considering air transport (see for instance  <sup>22</sup>).</p>"},{"location":"books/documentation_impacts/#climate-sustainability","title":"Climate sustainability","text":"<p>Climate sustainability assessment can be performed using various methodologies. For example, carbon  budgets. It is an interesting concept used by the IPCC in the context of global warming mitigation strategies. It is  defined as the maximum remaining cumulative CO<sub>2</sub> emissions that can be emitted to limit the temperature  increase below a certain value (for example +1.5\u000b\u000b\u000b\u000b\u000bC). For instance, Tab.3 summarizes estimates of carbon budgets for  different temperature targets. The emissions considered are net emissions: they are  the difference between gross anthropogenic CO<sub>2</sub> emissions and anthropogenic carbon sinks. Cumulative  CO<sub>2</sub> emissions and mean temperature increase are linked by a quasi-linear relationship, which facilitates  the estimation of carbon budgets <sup>23</sup>. Therefore, the use of carbon budgets allows for example to simply evaluate the relevance of transition scenarios to reach climate objectives based on their  CO<sub>2</sub> emissions alone <sup>24</sup>.</p> Temperature [\u000b\u000b\u000b\u000b\u000bC] 17th 33rd 50th 67th 83rd 1.5 900 650 500 400 300 1.6 1200 850 650 550 400 1.7 1450 1050 850 700 550 1.8 1750 1250 1000 850 650 1.9 2000 1450 1200 1000 800 2.0 2300 1700 1350 1150 900 <p>Tab.3 Estimates of carbon budgets depending on TCRE percentile according to IPCC AR6 (in GtCO<sub>2</sub>).</p> <p>However, these carbon budgets are defined globally and not by country or sector (like aviation). In the following, a  method which can be applied to aviation CO<sub>2</sub> emissions is proposed. This later is also extended to include  non-CO<sub>2</sub> effects using two solutions. </p>"},{"location":"books/documentation_impacts/#co2-effects","title":"CO<sub>2</sub> effects","text":"<p>First, a global gross carbon budget \\(GCB\\) is considered. As a reminder, it is defined as the sum of a net carbon budget and a CDR (Carbon Dioxide Removal) capacity (afforestation, BECCS, DACCS...). It is assumed that this budget will be  entirely consumed by 2100. This constraint is expressed in the following equation via cumulative emissions, considering  \\(E_{CO_2,k}\\) emissions for year \\(k\\) from 2020.</p> <p>\\(GCB = \\sum_{k=2020}^{2100} E_{CO_2,k}\\)</p> <p>An infinite number of trajectories for CO<sub>2</sub> emissions can satisfy this constraint. In the following, a  simplified model of emissions decay at a fixed annual rate \\(x\\) is considered. The previous equation can then be  written as the following one. This is a geometric series which can then be expressed more simply. This equation can  then be solved implicitly to determine the annual rate of decrease of emissions \\(x\\).</p> <p>\\(GCB = \\sum_{k=2020}^{2100} E_{CO_2,2019}~(1-x)^{k-2019} = E_{CO_2,2019}~ \\frac{(1-x)-(1-x)^{82}}{x}\\)</p> <p>Here, the scope of the scenario studies is limited to 2050. Therefore, the following equation is used to determine the  adjusted global gross carbon budget to 2050 \\(GCB_c\\).</p> <p>\\(GCB_c = E_{CO_2,2019}~\\frac{(1-x)-(1-x)^{32}}{x}\\)</p> <p>Finally, it is necessary to allocate a share of this carbon budget to aviation. Thus, the carbon budget for aviation  (by 2050) \\(GCB_A\\) is simply calculated using the following equation via an allocated share \\(F\\).</p> <p>\\(GCB_A = F~GCB_c\\)</p> <p>The choice of the share allocated to the aviation sector is a political one and may involve multiple criteria  (technical, economic, societal, etc.). Discussions on this allocation are proposed in <sup>25</sup>. An interesting reference value is the recent contribution of aviation to CO<sub>2</sub> emissions (also called  grandfathering approach). For example, it is 2.6% on the perimeter of commercial aviation considering global  CO<sub>2</sub> emissions <sup>25</sup>. This value can be interpreted as the share that would be allocated to the aviation sector under a non-differentiated approach where all sectors reduce their emissions at the same rate.  Allocations below or above this value can also be considered. However, allocating a larger share mechanically requires  other sectors to reduce their emissions faster than the average to meet the global carbon budget. This type of  trade-off may require multi-sectoral approaches, as for example proposed in <sup>26</sup>. In this scenario, cumulative direct CO<sub>2</sub> emissions from aviation would represent 3.4% of the considered carbon budget of  1055 GtCO<sub>2</sub> over the period 2011--2050.</p> <p>Therefore, the climate sustainability of a scenario (regarding CO<sub>2</sub> emissions) can be assessed by comparing  the cumulative CO<sub>2</sub> emissions with the allocated carbon budget for aviation. If the cumulative emissions  are less than or equal to the carbon budget, the climate target is met.</p>"},{"location":"books/documentation_impacts/#co2-and-non-co2-effects","title":"CO<sub>2</sub> and non-CO<sub>2</sub> effects","text":"<p>For assessing the sustainability of aviation climate impact, a first solution is to directly compare the temperature increase from air transport to a climate objective (via an allocation or an absolute target) which is  for instance performed in <sup>10</sup><sup>27</sup>.</p> <p>Another solution is to extend the previous approach in order to maintain a methodology similar to that used for CO<sub>2</sub> emissions. So-called equivalent carbon budgets are then calculated.  For this purpose, a global equivalent gross carbon budget \\(EGCB\\) is calculated via the following equation, which has been adapted from simplified models for estimating carbon budgets described in <sup>28</sup>. The \\(T_{non-CO_2}\\) term depends on the temperature objective considered: it is for example equal to 0.1\u000b\u000b\u000b\u000b\u000bC for a +1.5\u000b\u000b\u000b\u000b\u000bC  target and to 0.2\u000b\u000b\u000b\u000b\u000bC for +2\u000b\u000b\u000b\u000b\u000bC.</p> <p>\\(EGCB = GCB + \\frac{T_{non-CO_2}}{TCRE}\\)</p> <p>The same approach as for CO<sub>2</sub> emissions is then used to define an equivalent carbon budget for aviation.  Allocation rules must also be defined. The reference value considered this time is 5.1%, on the perimeter of commercial  aviation, over a recent period and including global CO<sub>2</sub> emissions and non-CO<sub>2</sub> effects <sup>25</sup>.</p> <p>Therefore, as before, the climate sustainability of a scenario (for all effects) can be assessed by comparing the  cumulative equivalent emissions with the equivalent carbon budget calculated for aviation. As introduced previously,  the equivalent emissions are also calculated using the GWP<sup>*</sup> climate metric. The total cumulative equivalent  emissions are thus the sum of the cumulative emissions of CO<sub>2</sub> and the sum of these annual equivalent  emissions for each non-CO<sub>2</sub> effect from 2020 to 2050.</p>"},{"location":"books/documentation_impacts/#energy-resource-sustainability","title":"Energy resource sustainability","text":"<p>The assessment of energy resource sustainability is based on an approach similar to the one presented for climate  issues. This time, rather than comparing cumulative emissions to carbon budgets, the energy consumption of a scenario is  compared to available energy resource budgets. Only biomass and electricity energy resources are studied in this work.  To simplify the comparisons, the availabilities are checked in 2050. A more comprehensive approach would be to check  the availability of energy resources on an annual basis. </p> <p>In the same way as for carbon budgets, an arbitrary allocation of energy resources for aviation is assumed. The  choice of a reference value can, for example, be based on the contribution of the sector to world energy or oil  consumption (of the order of 2 to 3% or 7 to 8%). Thus, a scenario can be considered sustainable from an energy point  of view if the consumption of energy resources in 2050 does not exceed the energy resource budget considered.</p> <p>In the following, some examples of reasonable values are proposed.</p>"},{"location":"books/documentation_impacts/#biomass-availability","title":"Biomass availability","text":"<p>The estimation of the available biomass at the global level is complex and depends on several criteria. In this work,  a statistical analysis of IRENA (International Renewable ENergy Agency) data is performed. The resource categories  described for the biofuel pathways are used. The results are given in Tab.4. The lower and upper fences are determined  to exclude extreme values (outliers).</p> Resource Lower fence Q1 Median Q3 Upper fence Waste 9 10 12 20 27 Agricultural residues 10 30 57 103 204 Forest residues 5 15 17 39 59 Energy crops 8 37 63 109 217 Algae 5 8 15 31 50 Total 37 100 164 302 557 <p>Tab.4 Global biomass availability (in EJ) scenarios to 2050.</p> <p>The estimates in Tab.4 are refined using an analysis of the references <sup>29</sup><sup>30</sup> to obtain detailed results for different resources. Concerning waste, used cooking oil represents a deposit of about  1 EJ, the rest being municipal solid waste. Energy crops are divided into 63% lignocellulose, 9% vegetable oils and 28%  sugar or starch-based materials.</p> <p>The results obtained are consistent with <sup>31</sup>, which concludes that likely estimates are less than 300 EJ. Similarly, the results by resource type are of the same order of magnitude as those given in <sup>32</sup>.</p>"},{"location":"books/documentation_impacts/#electricity-availability","title":"Electricity availability","text":"<p>Concerning electricity at the global level, the estimation is also complex due to technical, economic or political  factors. Multiple availability scenarios are proposed by academic, industrial and institutional actors. Several  scenarios are thus represented on Fig.1, with the estimation of the availability but also of the emission factor of  the electricity mix. It is interesting to note the reference point in 2019 and the wide dispersion of the scenarios.  Moreover, all the scenarios forecast an increase in electricity production and a decrease in the emission  factor. For comparison, the emission factors at the global level for low-carbon production means are lower than  50 gCO<sub>2</sub>-eq/kWh, with values of the order of 10 gCO<sub>2</sub>-eq/kWh for wind or nuclear power <sup>33</sup>.</p>"},{"location":"books/documentation_impacts/#bibliography","title":"Bibliography","text":"<ol> <li> <p>Sofia Pinheiro Melo, Alexander Barke, Felipe Cerdas, Christian Thies, Mark Mennenga, Thomas S Spengler, and Christoph Herrmann. Sustainability assessment and engineering of emerging aircraft technologies \u2014 Challenges, methods and tools. Sustainability, 12(14):5663, 2020. doi:10.3390/su12145663.\u00a0\u21a9</p> </li> <li> <p>David S Lee, DW Fahey, Agnieszka Skowron, MR Allen, Ulrike Burkhardt, Q Chen, SJ Doherty, S Freeman, PM Forster, J Fuglestvedt, and others. The contribution of global aviation to anthropogenic climate forcing for 2000 to 2018. Atmospheric Environment, 244:117834, 2021. doi:10.1016/j.atmosenv.2020.117834.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>B Aamaas, GP Peters, and JS Fuglestvedt. Simple emission metrics for climate impacts. Earth System Dynamics, 4(1):145\u2013170, 2013. doi:10.5194/esd-4-145-2013.\u00a0\u21a9</p> </li> <li> <p>Keith P Shine, Jan S Fuglestvedt, Kinfe Hailemariam, and Nicola Stuber. Alternatives to the global warming potential for comparing climate impacts of emissions of greenhouse gases. Climatic Change, 68(3):281\u2013302, 2005. doi:10.1007/s10584-005-1146-9.\u00a0\u21a9</p> </li> <li> <p>John Lynch, Michelle Cain, Raymond Pierrehumbert, and Myles Allen. Demonstrating GWP*: A means of reporting warming-equivalent emissions that captures the contrasting impacts of short-and long-lived climate pollutants. Environmental Research Letters, 15(4):044023, 2020. doi:10.1088/1748-9326/ab6d7e.\u00a0\u21a9</p> </li> <li> <p>Myles R Allen, Keith P Shine, Jan S Fuglestvedt, Richard J Millar, Michelle Cain, David J Frame, and Adrian H Macey. A solution to the misrepresentations of CO2-equivalent emissions of short-lived climate pollutants under ambitious mitigation. Npj Climate and Atmospheric Science, 1(1):1\u20138, 2018. doi:10.1038/s41612-018-0026-8.\u00a0\u21a9\u21a9</p> </li> <li> <p>Michelle Cain, John Lynch, Myles R Allen, Jan S Fuglestvedt, David J Frame, and Adrian H Macey. Improved calculation of warming-equivalent emissions for short-lived climate pollutants. NPJ climate and atmospheric science, 2(1):1\u20137, 2019. doi:10.1038/s41612-019-0086-4.\u00a0\u21a9</p> </li> <li> <p>William J Collins, David J Frame, Jan S Fuglestvedt, and Keith P Shine. Stable climate metrics for emissions of short and long-lived species \u2013 Combining steps and pulses. Environmental Research Letters, 15(2):024018, 2020. doi:10.1088/1748-9326/ab6039.\u00a0\u21a9</p> </li> <li> <p>Malte Meinshausen and Zebedee Nicholls. GWP* is a model, not a metric. Environmental Research Letters, 17(4):041002, 2022. doi:10.1088/1748-9326/ac5930.\u00a0\u21a9</p> </li> <li> <p>Volker Grewe, Arvind Gangoli Rao, Tomas Gr\u00f6nstedt, Carlos Xisto, Florian Linke, Joris Melkert, Jan Middel, Barbara Ohlenforst, Simon Blakey, Simon Christie, and others. Evaluating the climate impact of aviation emission scenarios towards the Paris agreement including COVID-19 effects. Nature Communications, 12(1):1\u201310, 2021. doi:10.1038/s41467-021-24091-y.\u00a0\u21a9\u21a9</p> </li> <li> <p>Antoine Salgas, Thomas Plan\u00e8s, Scott Delbecq, Florian Simatos, and Gilles Lafforgue. Cost estimation of the use of low-carbon fuels in prospective scenarios for air transport. In AIAA SCITECH 2023 Forum, 2328. 2023. doi:10.2514/6.2023-2328.\u00a0\u21a9</p> </li> <li> <p>Antoine Salgas, Scott Delbecq, Thomas Plan\u00e8s, and Gilles Lafforgue. Top level aircraft requirements relaxation for a single-aisle aircraft: a case study on fleet-wide co2 emissions and economic impacts. In AIAA SCITECH 2023 Forum, 1357. 2023. doi:10.2514/6.2023-1357.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Antoine Salgas, Scott Delbecq, Thomas Plan\u00e8s, Gilles Lafforgue, and Jo\u00ebl J\u00e9z\u00e9gou. Modelling and simulation of new regulatory measures in prospective scenarios for air transport. In Aerospace Europe Conference. 2023.\u00a0\u21a9\u21a9</p> </li> <li> <p>Nikita Pavlenko. The cost of supporting alternative jet fuels in the European Union. Technical Report, ICCT, 2019.\u00a0\u21a9\u21a9</p> </li> <li> <p>Sierk de Jong. Green Horizons - On the production costs, climate impact and future supply of renewable jet fuels (PhD thesis), Sierk De Jong (2018). PhD thesis, N/A, June 2018.\u00a0\u21a9\u21a9</p> </li> <li> <p>IRENA. Reaching zero with renewables: Biojet fuels. Technical Report, International Renewable Energy Agency, 2021.\u00a0\u21a9</p> </li> <li> <p>Energy and industrial strategy UK department for Business. Hydrogen production costs 2021. Technical Report, UK Government, 2021.\u00a0\u21a9</p> </li> <li> <p>Potsdam PIK. Price of Hydrogen: CAPEX Data. 2022. URL: https://h2.pik-potsdam.de/H2Dash/#section-visualisations (visited on 2022-11-23).\u00a0\u21a9</p> </li> <li> <p>International Energy Agency. Global Hydrogen Review 2021: Assumptions. 2021. URL: https://iea.blob.core.windows.net/assets/2ceb17b8-474f-4154-aab5-4d898f735c17/IEAGHRassumptions_final.pdf (visited on 2023-08-23).\u00a0\u21a9</p> </li> <li> <p>Alain Quinet. What Value Do We Attach to Climate Action? Economie et Statistique / Economics and Statistics, pages 165\u2013179, January 2020. doi:10.24187/ecostat.2019.510t.1995.\u00a0\u21a9</p> </li> <li> <p>Kristof Risse, Katharina Sch\u00e4fer, Florian Sch\u00fcltke, and Eike Stumpf. Central Reference Aircraft data System (CeRAS) for research community. CEAS Aeronautical Journal, pages 121\u2013133, March 2016. doi:10.1007/s13272-015-0177-9.\u00a0\u21a9</p> </li> <li> <p>Thomas Plan\u00e8s. Du dimensionnement de syst\u00e8mes et d'architectures en conception avion \u00e0 la simulation de sc\u00e9narios prospectifs durables pour le transport a\u00e9rien. PhD thesis, Universit\u00e9 de Toulouse, Institut Sup\u00e9rieur de l\u2019A\u00e9ronautique et de l\u2019Espace, 2022. URL: https://www.theses.fr/2022ESAE0059.\u00a0\u21a9</p> </li> <li> <p>H Damon Matthews, Nathan P Gillett, Peter A Stott, and Kirsten Zickfeld. The proportionality of global warming to cumulative carbon emissions. Nature, 459(7248):829\u2013832, 2009. doi:10.1038/nature08047.\u00a0\u21a9</p> </li> <li> <p>Pierre Friedlingstein, Robbie M Andrew, Joeri Rogelj, Glen P Peters, Josep G Canadell, Reto Knutti, Gunnar Luderer, Michael R Raupach, Michiel Schaeffer, Detlef P van Vuuren, and others. Persistent growth of CO2 emissions and implications for reaching climate targets. Nature geoscience, 7(10):709\u2013715, 2014. doi:10.1038/ngeo2248.\u00a0\u21a9</p> </li> <li> <p>Scott Delbecq, J\u00e9r\u00f4me Fontane, Nicolas Gourdain, Hugo Mugnier, Thomas Plan\u00e8s, and Florian Simatos. Aviation and climate: a literature review. ISAE-SUPAERO, 2022. doi:10.34849/a66a-vv58.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Science Based Targets Initiative. Sectoral Decarbonization Approach (SDA): A method for setting corporate emission reduction targets in line with climate science. Technical Report, SBTI, 2015.\u00a0\u21a9</p> </li> <li> <p>Milan Kl\u00f6wer, MR Allen, DS Lee, SR Proud, Leo Gallagher, and Agnieszka Skowron. Quantifying aviation\u2019s contribution to global warming. Environmental Research Letters, 16(10):104027, 2021. doi:10.1088/1748-9326/ac286e.\u00a0\u21a9</p> </li> <li> <p>Joeri Rogelj, Piers M Forster, Elmar Kriegler, Christopher J Smith, and Roland S\u00e9f\u00e9rian. Estimating and tracking the remaining carbon budget for stringent climate targets. Nature, 571(7765):335\u2013342, 2019. doi:10.1038/s41586-019-1368-z.\u00a0\u21a9</p> </li> <li> <p>Mark D Staples, Robert Malina, and Steven RH Barrett. The limits of bioenergy for mitigating global life-cycle greenhouse gas emissions from fossil fuels. Nature Energy, 2(2):1\u20138, 2017. doi:10.1038/nenergy.2016.202.\u00a0\u21a9</p> </li> <li> <p>Mark D Staples, Robert Malina, Pooja Suresh, James I Hileman, and Steven RH Barrett. Aviation CO2 emissions reductions from the use of alternative jet fuels. Energy Policy, 114:342\u2013354, 2018. doi:10.1016/j.enpol.2017.12.007.\u00a0\u21a9</p> </li> <li> <p>Raphael Slade, Ausilio Bauen, and Robert Gross. Global bioenergy resources. Nature Climate Change, 4(2):99\u2013105, 2014.\u00a0\u21a9</p> </li> <li> <p>Jane O'Malley, Nikita Pavlenko, and Stephanie Searle. Estimating sustainable aviation fuel feedstock availability to meet growing European Union demand. Working paper 2021-13, ICCT, 2021.\u00a0\u21a9</p> </li> <li> <p>T.F. Stocker, Dahe Qin, G.-K. Plattner, M. Tignor, S.K. Allen, J. Boschung, A. Nauels, Y. Xia, V. Bex, and P.M. Midgley. Climate Change 2013: The Physical Science Basis. Contribution of Working Group I to the Fifth Assessment Report of the Intergovernmental Panel on Climate Change. Cambridge University Press, 2013.\u00a0\u21a9</p> </li> </ol>"},{"location":"books/documentation_software/","title":"Software developments","text":"<p>Regarding the software developments of the framework, AeroMAPS is developed using the Python programming language.  The data and models are mainly manipulated and implemented using the Pandas package but also use other scientific  computing package like GEMSEO and SciPy for solving implicit models for instance. The user interface uses ipywidgets  for the widgets and ipympl for the graphs. The AeroMAPS software is deployed as a web application thanks to Voil\u00e0.</p>"},{"location":"books/examples/","title":"Examples","text":"<p>In addition to the direct use of the graphical user interface of AeroMAPS, different examples are provided using  Jupyter notebooks for achieving more complete scenario analyses.</p>"},{"location":"books/installation/","title":"Installation","text":""},{"location":"books/installation/#quick-start","title":"Quick start","text":"<p>For a quick start in order to discover the different features of AeroMAPS, a graphical user interface has been developed for facilitating the first uses. It is available at the following address: https://aeromaps.isae-supaero.fr</p>"},{"location":"books/installation/#installation-from-the-python-package-index-pypi","title":"Installation from the Python Package Index (PyPI)","text":"<p>The Python Package Index (PyPI) can be used for installing AeroMAPS.</p> <p>Prerequisite: AeroMAPS needs at least Python 3.9.0.</p> <p>It is recommended (but not required) to install AeroMAPS in a virtual environment (conda, venv, ...)</p> <p>Once Python is installed, AeroMAPS can be installed using pip.</p> <p>Note: If your network uses a proxy, you may have to do some settings for pip to work correctly</p> <p>You can install the latest version with this command:</p> <pre><code>pip install --upgrade aeromaps\n</code></pre>"},{"location":"books/installation/#installation-from-github","title":"Installation from GitHub","text":"<p>Another solution is to install AeroMAPS from GitHub.</p> <p>Note: This solution has to be used if you want to perform developing of AeroMAPS.</p>"},{"location":"books/other_examples/","title":"Other examples and tutorials","text":"<p>This page references links to other AeroMAPS example notebooks.</p> <p>For maintenance simplicity, the notebooks are hosted in our github repository instead of being duplicated in the documentation. They can be opened directly in your browser or downloaded and run locally in a Jupyter environment, alternatively using our Binder.</p>"},{"location":"books/other_examples/#tutorials-notebooks","title":"Tutorials (notebooks)","text":"<ul> <li> <p>Create a custom process</p> </li> <li> <p>Use the detailed fleet model</p> </li> <li> <p>Climate application</p> </li> <li> <p>Partitioning analysis to a region</p> </li> <li> <p>Use variable demand</p> </li> <li> <p>Optimization of a scenario</p> </li> <li> <p>Notebooks used in research publications</p> </li> </ul> <p>If the branch or file layout changes in the repository, update these links accordingly.</p>"},{"location":"books/references/","title":"Citations","text":"<p>This part of the documentation is deprecated. It describes AeroMAPS in late 2023</p> <p>It will be updated soon.!</p>"},{"location":"books/references/#main-reference","title":"Main reference","text":"<p>Please cite this article when using AeroMAPS in your research works:</p> <p>Plan\u00e8s, T., Delbecq, S., Salgas, A. (2023). AeroMAPS: a framework for performing multidisciplinary assessment of prospective scenarios for air transport. Submitted to Journal of Open Aviation Science.</p> <pre><code>@article{planes2021simulation,\n    title={AeroMAPS: a framework for performing multidisciplinary assessment of prospective scenarios for air transport},\n    author={Plan{\\`e}s, Thomas and Delbecq, Scott and Salgas, Antoine},\n    journal={Submitted to Journal of Open Aviation Science},\n    year={2023},\n}\n</code></pre>"},{"location":"books/references/#other-references","title":"Other references","text":"<p>To refer to specific methods or models of AeroMAPS, you can cite the following references:</p> <ul> <li>Publication dedicated to initial methods and models: Plan\u00e8s, T., Delbecq, S., Pommier-Budinger, V., and B\u00e9nard, E. (2021). Simulation and evaluation of sustainable climate trajectories for aviation. Journal of Environmental Management, 295, 113079. https://doi.org/10.1016/j.jenvman.2021.113079</li> </ul> <pre><code>@article{planes2021simulation,\n    title={Simulation and evaluation of sustainable climate trajectories for aviation},\n    author={Plan{\\`e}s, Thomas and Delbecq, Scott and Pommier-Budinger, Val{\\'e}rie and B{\\'e}nard, Emmanuel},\n    journal={Journal of Environmental Management},\n    volume={295},\n    pages={113079},\n    year={2021},\n    publisher={Elsevier},\n    doi={10.1016/j.jenvman.2021.113079}\n}\n</code></pre> <ul> <li>Publication dedicated to the description of main methods and models (in French): Plan\u00e8s, T. (2022). Du dimensionnement de syst\u00e8mes et d'architectures en conception avion \u00e0 la simulation de sc\u00e9narios  prospectifs durables pour le transport a\u00e9rien. Ph.D. Thesis. Universit\u00e9 de Toulouse, Institut Sup\u00e9rieur de l\u2019A\u00e9ronautique et de l\u2019Espace. https://www.theses.fr/2022ESAE0059</li> </ul> <pre><code>@phdthesis{planes2022dimensionnement,\n  title={Du dimensionnement de syst{\\`e}mes et d'architectures en conception avion {\\`a} la simulation de sc{\\'e}narios prospectifs durables pour le transport a{\\'e}rien},\n  author={Plan{\\`e}s, Thomas},\n  year={2022},\n  school={{Universit\u00e9 de Toulouse, Institut Sup\u00e9rieur de l\u2019A\u00e9ronautique et de l\u2019Espace}},\n  url={https://www.theses.fr/2022ESAE0059}\n}\n</code></pre> <ul> <li>Publication dedicated to aircraft fleet models: Delbecq, S., Plan\u00e8s, T., Delavenne, M., Pommier-Budinger, V., and Joksimovic, A. (2022). Aircraft fleet models using a bottom-up approach for simulating aviation technological prospective scenarios. In 33rd Congress of the International Council of the Aeronautical Sciences.</li> </ul> <pre><code>@inproceedings{delbecq2022aircraft,\n    title={Aircraft fleet models using a bottom-up approach for simulating aviation technological prospective scenarios},\n    author={Delbecq, Scott and Plan{\\`e}s, Thomas and Delavenne, Martin and Pommier-Budinger, Val{\\'e}rie and Joksimovi{\\'c}, Aleksandar},\n    booktitle={33rd Congress of the International Council of the Aeronautical Sciences},\n    year={2022}\n}\n</code></pre> <ul> <li>Publication dedicated to cost models for low-carbon fuels: Salgas, A., Plan\u00e8s, T., Delbecq, S., and Lafforgue, G. (2023). Cost estimation of the use of low-carbon fuels in prospective scenarios for air transport. In AIAA SCITECH 2023 Forum. https://doi.org/10.2514/6.2023-2328</li> </ul> <pre><code>@inproceedings{salgas2023cost,\n    title={Cost estimation of the use of low-carbon fuels in prospective scenarios for air transport},\n    author={Salgas, Antoine and Plan{\\`e}s, Thomas and Delbecq, Scott and Simatos, Florian and Lafforgue, Gilles},\n    booktitle={AIAA SCITECH 2023 Forum},\n    pages={2328},\n    year={2023},\n    doi={10.2514/6.2023-2328}\n}\n</code></pre> <ul> <li>Publication dedicated to direct operating cost model recalibration: Salgas, A., Delbecq, S., Plan\u00e8s, T., Lafforgue, G. (2023). Top Level Aircraft Requirements relaxation for a single-aisle aircraft: a case study on fleet-wide CO2 emissions and economic impacts. In AIAA SCITECH 2023 Forum. https://doi.org/10.2514/6.2023-1357</li> </ul> <pre><code>@inproceedings{salgas2023tlars,\n    title={Top Level Aircraft Requirements relaxation for a single-aisle aircraft: a case study on fleet-wide CO2 emissions and economic impacts.},\n    author={Salgas, Antoine and Delbecq, Scott and Plan{\\`e}s, Thomas and Lafforgue, Gilles},\n    booktitle={AIAA SCITECH 2023 Forum},\n    pages={1357},\n    year={2023},\n    doi={10.2514/6.2023-1357}\n}\n</code></pre> <ul> <li>Publication dedicated to other cost models: Salgas, A., Delbecq, S., Plan\u00e8s, T., Lafforgue, G. and J\u00e9z\u00e9gou, J. (2023). Modelling and simulation of new regulatory measures for prospective scenarios for air transport. In Aerospace Europe Conference.</li> </ul> <pre><code>@inproceedings{salgas2023regulations,\n    title={Modelling and simulation of new regulatory measures in prospective scenarios for air transport},\n    author={Salgas, Antoine and Delbecq, Scott and Plan{\\`e}s, Thomas and Lafforgue, Gilles and J\u00e9z\u00e9gou, Jo\u00ebl},\n    booktitle={Aerospace Europe Conference},\n    year={2023},\n}\n</code></pre>"},{"location":"full_doc/","title":"AeroMAPS Models","text":"<p>This section describes all the AeroMAPS models implemented in the framework.</p> <p>Nota bene</p> <p>A simpler API reference, covering only user-facing functions and classes, can be found in the API Reference section of the documentation.</p> <p>The navigation in this documentation is organized by package:</p> <ul> <li>Package</li> <li>Core: AeroMAPSProcess execution-related methods, GEMSEO integration, and   configuration file handling.</li> <li>GUI: graphical user interface-related methods.</li> <li>Utils: utility functions for data handling, other   general-purpose methods.</li> <li>AeroMAPS Models: disciplinary models implemented in AeroMAPS, organized   into subpackages:<ul> <li>Base, constants, parameters: common building blocks shared across models.</li> <li>Air transport: traffic, aircraft fleet and operations, and related submodels.</li> <li>Impacts: emissions, climate impacts, costs, life cycle assessment, and   other impact models.</li> <li>Sustainability assessment: climate and equivalent carbon budgets.</li> <li>Optimisation: elementary models to define constraints used in optimisation problems.</li> </ul> </li> </ul> <p>Each subpage is auto-generated from the Python docstrings using mkdocstrings.</p>"},{"location":"full_doc/aeromaps.core.gemseo/","title":"<code>aeromaps.core.gemseo</code>","text":"<p>A discipline interfacing a Python function.</p>"},{"location":"full_doc/aeromaps.core.gemseo/#aeromaps.core.gemseo.CustomDataConverter","title":"CustomDataConverter","text":"<p>               Bases: <code>SimpleGrammarDataConverter</code></p>"},{"location":"full_doc/aeromaps.core.gemseo/#aeromaps.core.gemseo.CustomDataConverter.get_value_size","title":"get_value_size  <code>classmethod</code>","text":"<pre><code>get_value_size(name, value)\n</code></pre> <p>Return the size of a data value.</p> <p>The size is typically what is returned by <code>ndarray.size</code> or <code>len(list)</code>. The size of a number is 1.</p> <p>Args:     name: The data name.     value: The data value to get the size from.</p> <p>Returns:     The size.</p> Source code in <code>aeromaps/core/gemseo.py</code> <pre><code>@classmethod\ndef get_value_size(cls, name: str, value: ValueType) -&gt; int:\n    \"\"\"Return the size of a data value.\n\n    The size is typically what is returned by ``ndarray.size`` or ``len(list)``.\n    The size of a number is 1.\n\n\n    Args:\n        name: The data name.\n        value: The data value to get the size from.\n\n    Returns:\n        The size.\n    \"\"\"\n    if isinstance(value, cls._NON_ARRAY_TYPES):\n        return 1\n    elif isinstance(value, (list, tuple)):\n        return len(value)\n    return cast(\"NumberArray\", value).size\n</code></pre>"},{"location":"full_doc/aeromaps.core.gemseo/#aeromaps.core.gemseo.AeroMAPSAutoModelWrapper","title":"AeroMAPSAutoModelWrapper","text":"<pre><code>AeroMAPSAutoModelWrapper(model)\n</code></pre> <p>               Bases: <code>AutoPyDiscipline</code></p> <p>Wraps the AeroMAPSModel class into a discipline. Inputs and outputs are automatically declared from the model's compute() function signature.</p> Source code in <code>aeromaps/core/gemseo.py</code> <pre><code>def __init__(self, model):\n    self.model: AeroMAPSModel = model\n\n    self.default_grammar_type = Discipline.GrammarType.SIMPLE\n\n    super(AeroMAPSAutoModelWrapper, self).__init__(\n        py_func=self.model.compute,\n    )\n    # self.io.data_processor = AutoDiscDataProcessor()\n\n    self.name = model.__class__.__name__\n\n    self.update_defaults()\n</code></pre>"},{"location":"full_doc/aeromaps.core.gemseo/#aeromaps.core.gemseo.AeroMAPSCustomModelWrapper","title":"AeroMAPSCustomModelWrapper","text":"<pre><code>AeroMAPSCustomModelWrapper(model)\n</code></pre> <p>               Bases: <code>Discipline</code></p> <p>Wraps the AeroMAPSModel class into a discipline. Inputs and outputs are declared through the attributes 'input_names' and 'output_names' of the model.</p> Source code in <code>aeromaps/core/gemseo.py</code> <pre><code>def __init__(self, model):\n    super().__init__()\n\n    # Whether to skip data type validation (at your own risk)\n    if getattr(model, \"_skip_data_type_validation\", False):\n        # self.input_grammar = SimplerGrammar(\"InputGrammar\")\n        # self.output_grammar = SimplerGrammar(\"OutputGrammar\")\n        self.input_grammar._validate = lambda data, msg: True\n        self.output_grammar._validate = lambda data, msg: True\n\n    # Set input and output grammars from model attributes\n    if isinstance(model.input_names, dict):\n        self.input_grammar.update_from_data(model.input_names)\n    else:  # assume list of names\n        self.input_grammar.update_from_names(model.input_names)\n\n    if isinstance(model.output_names, dict):\n        self.output_grammar.update_from_data(model.output_names)\n    else:  # assume list of names\n        self.output_grammar.update_from_names(model.output_names)\n\n    # Set the model\n    self.model: AeroMAPSModel = model\n    self.name = model.__class__.__name__\n\n    # Initialize default input data\n    self.update_defaults()\n</code></pre>"},{"location":"full_doc/aeromaps.core/","title":"<code>aeromaps.core</code>","text":"<p>This module initializes the core package of the AeroMaps library. It provides essential components and functions to create and manage AeroMAPS processes and to integrate GEMSEO functionalities.</p>"},{"location":"full_doc/aeromaps.core.models/","title":"<code>aeromaps.core.models</code>","text":"<p>This module creates dictionaries of default models for various AeroMAPS configurations.</p>"},{"location":"full_doc/aeromaps.core.process/","title":"<code>aeromaps.core.process</code>","text":"<p>High-level AeroMAPS process orchestration.</p> <p>This module defines the main process class that orchestrates parameter initialization, model instantiation, GEMSEO configuration, generic energy carrier handling, and data export for the AeroMAPS framework.</p>"},{"location":"full_doc/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess","title":"AeroMAPSProcess","text":"<pre><code>AeroMAPSProcess(configuration_file=None, models=default_models_top_down, use_fleet_model=False, add_examples_aircraft_and_subcategory=True, optimisation=False)\n</code></pre> <p>               Bases: <code>object</code></p> <p>High-level AeroMAPS process driver.</p> <p>This class configures parameters, instantiates discipline models, builds GMESEO objects, handles generic energy carrier pathways, and manages input and output data structures for AeroMAPS studies.</p> <p>Parameters:</p> Name Type Description Default <code>configuration_file</code> <p>Path to a configuration JSON file overriding default settings.</p> <code>None</code> <code>models</code> <p>Dictionary of model instances to be used in the process.</p> <code>default_models_top_down</code> <code>use_fleet_model</code> <p>Whether to instantiate and use the bottom-up fleet model.</p> <code>False</code> <code>add_examples_aircraft_and_subcategory</code> <p>Whether to populate the fleet with example aircraft and subcategories when the fleet model is used.</p> <code>True</code> <code>optimisation</code> <p>Whether to configure GEMSEO for optimisation instead of a pure MDA chain.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>configuration_file</code> <p>Path of the active configuration JSON file.</p> <code>use_fleet_model</code> <p>Flag indicating if the bottom-up fleet model is used.</p> <code>models</code> <p>Dictionary of discipline and auxiliary models used in the process.</p> <code>parameters</code> <p>Central parameter container used by all models and disciplines.</p> <code>disciplines</code> <p>List of wrapped discipline objects used by GEMSEO or the MDA chain.</p> <code>data</code> <p>Dictionary storing structured inputs and outputs, including scalar, string, vector, climate, and LCA results.</p> <code>json</code> <p>Dictionary reserved for JSON-compatible representations of results.</p> <code>add_examples_aircraft_and_subcategory</code> <p>Flag controlling insertion of example fleet content.</p> <code>mda_chain</code> <p>GEMSEO MDAChain instance used when running pure MDA analyses.</p> <code>scenario</code> <p>GEMSEO scenario instance for conventional MDO.</p> <code>scenario_adapted</code> <p>GEMSEO scenario of scenario instance for the bilevel optimization problem.</p> <code>gemseo_settings</code> <p>Dictionary containing all GEMSEO-related configuration options.</p> <code>fleet</code> <p>Fleet instance when the bottom-up fleet model is activated, else None.</p> <code>fleet_model</code> <p>FleetModel instance wrapping the fleet when the bottom-up model is used.</p> <code>energy_resources_data</code> <p>Parsed configuration data for generic energy resources.</p> <code>energy_processes_data</code> <p>Parsed configuration data for generic energy processes.</p> <code>energy_carriers_data</code> <p>Parsed configuration data for aviation energy carrier pathways.</p> <code>pathways_manager</code> <p>EnergyCarrierManager instance describing available energy pathways.</p> <code>climate_historical_data</code> <p>Historical climate dataset used by climate-related models.</p> <p>Initialize an AeroMAPSProcess instance.</p> <p>This method loads configuration settings, initializes parameters, deep-copies the provided models dictionary when needed, and performs the common setup. It then configures either an MDA chain or an optimization scenario depending on the specified mode.</p> <p>Parameters:</p> Name Type Description Default <code>configuration_file</code> <p>Path to a configuration JSON file overriding default settings.</p> <code>None</code> <code>models</code> <p>Dictionary of model instances to be used in the process.</p> <code>default_models_top_down</code> <code>use_fleet_model</code> <p>Whether to instantiate and use the bottom-up fleet model.</p> <code>False</code> <code>add_examples_aircraft_and_subcategory</code> <p>Whether to populate the fleet with example aircraft and subcategories when the fleet model is used.</p> <code>True</code> <code>optimisation</code> <p>Whether to configure GEMSEO for optimization instead of a pure MDA chain.</p> <code>False</code> Source code in <code>aeromaps/core/process.py</code> <pre><code>def __init__(\n    self,\n    configuration_file=None,\n    models=default_models_top_down,\n    use_fleet_model=False,\n    add_examples_aircraft_and_subcategory=True,\n    optimisation=False,\n):\n    \"\"\"Initialize an AeroMAPSProcess instance.\n\n    This method loads configuration settings, initializes parameters,\n    deep-copies the provided models dictionary when needed, and\n    performs the common setup. It then configures either an MDA chain\n    or an optimization scenario depending on the specified mode.\n\n    Parameters\n    ----------\n    configuration_file\n        Path to a configuration JSON file overriding default\n        settings.\n    models\n        Dictionary of model instances to be used in the process.\n    use_fleet_model\n        Whether to instantiate and use the bottom-up fleet model.\n    add_examples_aircraft_and_subcategory\n        Whether to populate the fleet with example aircraft and\n        subcategories when the fleet model is used.\n    optimisation\n        Whether to configure GEMSEO for optimization instead of a\n        pure MDA chain.\n    \"\"\"\n    self.configuration_file = configuration_file\n    self._initialize_configuration()\n    self.use_fleet_model = use_fleet_model\n\n    # Recopy models to avoid shared state between instances.\n    # For specific models that would be too heavy to deepcopy, set attribute `deepcopy_at_init` to False.\n    # E.g., models that load large datasets that are read-only (c.f. LCA model).\n    self.models = {\n        k: deepcopy(v) if getattr(v, \"deepcopy_at_init\", True) else v for k, v in models.items()\n    }\n\n    # Initialize inputs\n    self._initialize_inputs()\n\n    self.common_setup(add_examples_aircraft_and_subcategory)\n    if not optimisation:\n        self.setup_mda()\n    else:\n        self.setup_optimisation()\n</code></pre>"},{"location":"full_doc/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.common_setup","title":"common_setup","text":"<pre><code>common_setup(add_examples_aircraft_and_subcategory)\n</code></pre> <p>Perform common setup steps independent of analysis type.</p> <p>This method initializes the disciplines list, the main data container, and JSON storage, and computes index structures and climate data. It also stores the flag indicating whether to add example aircraft and subcategories to the fleet.</p> Warning <p>This method should be called only if end year was modified, otherwise it is called in init.</p> <p>Parameters:</p> Name Type Description Default <code>add_examples_aircraft_and_subcategory</code> <p>Whether to populate the fleet with example aircraft and subcategories when the fleet model is used.</p> required Source code in <code>aeromaps/core/process.py</code> <pre><code>def common_setup(self, add_examples_aircraft_and_subcategory):\n    \"\"\"Perform common setup steps independent of analysis type.\n\n    This method initializes the disciplines list, the main data\n    container, and JSON storage, and computes index structures and\n    climate data. It also stores the flag indicating whether to add\n    example aircraft and subcategories to the fleet.\n\n    Warning\n    ---------\n    This method should be called only if end year was modified, otherwise it is called in __init__.\n\n    Parameters\n    ----------\n    add_examples_aircraft_and_subcategory\n        Whether to populate the fleet with example aircraft and\n        subcategories when the fleet model is used.\n    \"\"\"\n    self.disciplines = []\n    self.data = {}\n    self.json = {}\n    self._initialize_data()\n    self.add_examples_aircraft_and_subcategory = add_examples_aircraft_and_subcategory\n</code></pre>"},{"location":"full_doc/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.setup_mda","title":"setup_mda","text":"<pre><code>setup_mda()\n</code></pre> <p>Configure the process for a standalone MDA chain.</p> <p>This method initializes generic energy inputs and disciplines, then builds a GEMSEO MDAChain with default convergence settings for multidisciplinary analysis execution of AeroMAPS.</p> Warning <p>This method should be called only if end year was modified, otherwise it is called in init.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def setup_mda(self):\n    \"\"\"Configure the process for a standalone MDA chain.\n\n    This method initializes generic energy inputs and disciplines,\n    then builds a GEMSEO MDAChain with default convergence settings\n    for multidisciplinary analysis execution of AeroMAPS.\n\n    Warning\n    ---------\n    This method should be called only if end year was modified, otherwise it is called in __init__.\n    \"\"\"\n    # Initialize energy carriers\n    self._initialize_generic_energy()\n\n    self._initialize_disciplines(self.add_examples_aircraft_and_subcategory)\n\n    self.mda_chain = MDAChain(\n        disciplines=self.disciplines,\n        tolerance=1e-5,\n        initialize_defaults=True,\n        inner_mda_name=\"MDAGaussSeidel\",\n        log_convergence=True,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.setup_optimisation","title":"setup_optimisation","text":"<pre><code>setup_optimisation()\n</code></pre> <p>Configure the process for GEMSEO-based optimization.</p> <p>This method initializes the internal GEMSEO settings dictionary so that optimization scenarios can be defined and executed later.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def setup_optimisation(self):\n    \"\"\"Configure the process for GEMSEO-based optimization.\n\n    This method initializes the internal GEMSEO settings dictionary\n    so that optimization scenarios can be defined and executed later.\n    \"\"\"\n    self._initialize_gemseo_settings()\n</code></pre>"},{"location":"full_doc/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.create_gemseo_scenario","title":"create_gemseo_scenario","text":"<pre><code>create_gemseo_scenario()\n</code></pre> <p>Build a single-level GEMSEO MDO scenario.</p> <p>This method initializes generic energy inputs and disciplines, and then creates a GEMSEO scenario using the current <code>gemseo_settings</code> for objective, design space, scenario type, and formulation.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def create_gemseo_scenario(self):\n    \"\"\"Build a single-level GEMSEO MDO scenario.\n\n    This method initializes generic energy inputs and disciplines,\n    and then creates a GEMSEO scenario using the current\n    ``gemseo_settings`` for objective, design space, scenario type,\n    and formulation.\n    \"\"\"\n    self._initialize_generic_energy()\n    self._initialize_disciplines(self.add_examples_aircraft_and_subcategory)\n\n    self.scenario = create_scenario(\n        disciplines=self.disciplines,\n        objective_name=self.gemseo_settings[\"objective_name\"],\n        design_space=self.gemseo_settings[\"design_space\"],\n        scenario_type=self.gemseo_settings[\"scenario_type\"],\n        formulation_name=self.gemseo_settings[\"formulation\"],\n        main_mda_settings={\n            \"inner_mda_name\": \"MDAGaussSeidel\",\n            \"max_mda_iter\": 12,\n            \"initialize_defaults\": True,\n            \"tolerance\": 1e-4,\n        },\n        # grammar_type=self.gemseo_settings[\"grammar_type\"],\n        # input_data=self.input_data,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.create_gemseo_bilevel","title":"create_gemseo_bilevel","text":"<pre><code>create_gemseo_bilevel()\n</code></pre> <p>Build a GEMSEO bilevel optimization formulation.</p> <p>This method wraps an inner GEMSEO scenario in an <code>MDOScenarioAdapter</code> and creates an outer scenario that optimizes over the adapter. If the inner scenario is not yet defined, it is created using the current <code>gemseo_settings</code>.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def create_gemseo_bilevel(self):\n    \"\"\"Build a GEMSEO bilevel optimization formulation.\n\n    This method wraps an inner GEMSEO scenario in an\n    ``MDOScenarioAdapter`` and creates an outer scenario that\n    optimizes over the adapter. If the inner scenario is not yet\n    defined, it is created using the current ``gemseo_settings``.\n    \"\"\"\n    # if no scenario is created raise an error create_gemseo_scenario needs to be called first\n    if self.scenario is None:\n        logging.warning(\n            f\"Inner scenario of the bilevel formulation was not fully defined. Creating it with the following settings:\"\n            f\"Arguments used: disciplines={self.disciplines}, \"\n            f\"objective_name={self.gemseo_settings['objective_name']}, \"\n            f\"design_space={self.gemseo_settings['design_space']}, \"\n            f\"scenario_type={self.gemseo_settings['scenario_type']}, \"\n            f\"formulation_name={self.gemseo_settings['formulation']}\"\n        )\n        self.create_gemseo_scenario()\n\n    self.scenario.set_algorithm(self.gemseo_settings[\"algorithm_inner\"])\n\n    # dv_names = self.scenario.formulation.design_variables.keys()\n    self.adapter = MDOScenarioAdapter(\n        # TODO make generic --&gt; ?\n        self.scenario,\n        input_names=self.gemseo_settings[\"doe_input_names\"],\n        output_names=self.gemseo_settings[\"doe_output_names\"],\n        reset_x0_before_opt=True,\n        set_x0_before_opt=False,\n    )\n\n    self.scenario_adapted = create_scenario(\n        self.adapter,\n        formulation_name=self.gemseo_settings[\"formulation\"],\n        objective_name=self.gemseo_settings[\"objective_name_outer\"],\n        design_space=self.gemseo_settings[\"design_space_outer\"],\n        scenario_type=\"MDO\",\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.compute","title":"compute","text":"<pre><code>compute()\n</code></pre> <p>Run the configured analysis or optimization.</p> <p>This method prepares input data, then executes either a bilevel optimization, a single-level GEMSEO scenario, or an MDA chain depending on the current configuration. After execution, it updates the internal data structures with model outputs.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def compute(self):\n    \"\"\"Run the configured analysis or optimization.\n\n    This method prepares input data, then executes either a bilevel\n    optimization, a single-level GEMSEO scenario, or an MDA chain\n    depending on the current configuration. After execution, it\n    updates the internal data structures with model outputs.\n    \"\"\"\n    input_data = self._pre_compute()\n    if hasattr(self, \"scenario\") and self.scenario:\n        if hasattr(self, \"scenario_adapted\") and self.scenario_adapted:\n            print(\"Running bi-level MDO\")\n            # self.scenario.default_inputs.update(self.scenario.options)\n            self.scenario_adapted.execute(self.gemseo_settings[\"algorithm_outer\"])\n        else:\n            print(\"Running MDO\")\n            self.scenario.execute(self.gemseo_settings[\"algorithm\"])\n    else:\n        if not hasattr(self, \"mda_chain\") or self.mda_chain is None:\n            raise ValueError(\"MDA chain not created. Please call setup_mda() first.\")\n        else:\n            print(\"Running MDA\")\n            self.mda_chain.execute(input_data=input_data)\n\n    self._update_data_from_model()\n</code></pre>"},{"location":"full_doc/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.get_dataframes","title":"get_dataframes","text":"<pre><code>get_dataframes()\n</code></pre> <p>Return all main DataFrames as a dictionary, generated on demand.</p> <p>This method generates and returns a dictionary of key DataFrames representing inputs, outputs, and climate-related quantities in a tabular form suitable for inspection or export.</p> <p>Returns:</p> Type Description <code>dataframes</code> <p>Dictionary mapping DataFrame names to pandas DataFrame instances for data information, inputs, and outputs.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def get_dataframes(self):\n    \"\"\"Return all main DataFrames as a dictionary, generated on demand.\n\n    This method generates and returns a dictionary of key DataFrames\n    representing inputs, outputs, and climate-related quantities in a\n    tabular form suitable for inspection or export.\n\n    Returns\n    -------\n    dataframes\n        Dictionary mapping DataFrame names to pandas DataFrame\n        instances for data information, inputs, and outputs.\n    \"\"\"\n    return {\n        \"data_information\": self._get_data_information_df(),\n        \"vector_inputs\": self._get_vector_inputs_df(),\n        \"float_inputs\": self._get_float_inputs_df(),\n        \"str_inputs\": self._get_str_inputs_df(),\n        \"vector_outputs\": self._get_vector_outputs_df(),\n        \"float_outputs\": self._get_float_outputs_df(),\n        \"climate_outputs\": self._get_climate_outputs_df(),\n        # Add more if needed\n    }\n</code></pre>"},{"location":"full_doc/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.get_json","title":"get_json","text":"<pre><code>get_json()\n</code></pre> <p>Return the model outputs as a JSON-serializable dictionary.</p> <p>Returns:</p> Type Description <code>json_data</code> <p>Dictionary containing JSON-compatible inputs and outputs.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def get_json(self):\n    \"\"\"\n    Return the model outputs as a JSON-serializable dictionary.\n\n    Returns\n    -------\n    json_data\n        Dictionary containing JSON-compatible inputs and outputs.\n    \"\"\"\n    return self._data_to_json()\n</code></pre>"},{"location":"full_doc/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.write_json","title":"write_json","text":"<pre><code>write_json(file_name=None)\n</code></pre> <p>Write model inputs and outputs to a JSON file.</p> <p>This method builds the JSON-compatible data and writes it to disk, using either the provided file name or the path defined in the configuration.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <p>Path to the output JSON file. If None, the path from the configuration is used.</p> <code>None</code> Source code in <code>aeromaps/core/process.py</code> <pre><code>def write_json(self, file_name=None):\n    \"\"\"Write model inputs and outputs to a JSON file.\n\n    This method builds the JSON-compatible data and writes it to\n    disk, using either the provided file name or the path defined in\n    the configuration.\n\n    Parameters\n    ----------\n    file_name\n        Path to the output JSON file. If None, the path from the\n        configuration is used.\n    \"\"\"\n    if (\n        file_name is None\n        and self.configuration_file is not None\n        and \"OUTPUTS_JSON_DATA_FILE\" in self.config\n    ):\n        configuration_directory = os.path.dirname(self.configuration_file)\n        new_output_file_path = os.path.join(\n            configuration_directory, self.config[\"OUTPUTS_JSON_DATA_FILE\"]\n        )\n        file_name = new_output_file_path\n    elif file_name is None:\n        file_name = self.config[\"OUTPUTS_JSON_DATA_FILE\"]\n\n    # Ensure the directory exists\n    os.makedirs(os.path.dirname(file_name), exist_ok=True)\n\n    # Retrieve the data from the model\n    json_data = self.get_json()\n\n    with open(file_name, \"w\", encoding=\"utf-8\") as f:\n        dump(json_data, f, ensure_ascii=False, indent=4)\n</code></pre>"},{"location":"full_doc/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.write_excel","title":"write_excel","text":"<pre><code>write_excel(file_name=None)\n</code></pre> <p>Write main result tables to an Excel workbook.</p> <p>This method exports data information, inputs, and outputs into separate sheets of a single Excel file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <p>Path to the output Excel file. If None, the path from the configuration is used.</p> <code>None</code> Source code in <code>aeromaps/core/process.py</code> <pre><code>def write_excel(self, file_name=None):\n    \"\"\"Write main result tables to an Excel workbook.\n\n    This method exports data information, inputs, and outputs into\n    separate sheets of a single Excel file.\n\n    Parameters\n    ----------\n    file_name\n        Path to the output Excel file. If None, the path from the\n        configuration is used.\n    \"\"\"\n    if file_name is None:\n        file_name = self.config[\"EXCEL_DATA_FILE\"]\n    with pd.ExcelWriter(file_name) as writer:\n        self._get_data_information_df().to_excel(writer, sheet_name=\"Data Information\")\n        self._get_vector_inputs_df().to_excel(writer, sheet_name=\"Vector Inputs\")\n        self._get_float_inputs_df().to_excel(writer, sheet_name=\"Float Inputs\")\n        self._get_str_inputs_df().to_excel(writer, sheet_name=\"String Inputs\")\n        self._get_vector_outputs_df().to_excel(writer, sheet_name=\"Vector Outputs\")\n        self._get_float_outputs_df().to_excel(writer, sheet_name=\"Float Outputs\")\n        self._get_climate_outputs_df().to_excel(writer, sheet_name=\"Climate Outputs\")\n</code></pre>"},{"location":"full_doc/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.generate_n2","title":"generate_n2","text":"<pre><code>generate_n2()\n</code></pre> <p>Generate an N2 diagram for the current disciplines.</p> <p>This method calls GEMSEO to create an N2 plot describing the coupling structure between the configured disciplines.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def generate_n2(self):\n    \"\"\"Generate an N2 diagram for the current disciplines.\n\n    This method calls GEMSEO to create an N2 plot describing the\n    coupling structure between the configured disciplines.\n    \"\"\"\n    generate_n2_plot(self.disciplines)\n</code></pre>"},{"location":"full_doc/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.list_available_plots","title":"list_available_plots","text":"<pre><code>list_available_plots()\n</code></pre> <p>List the names of supported plots.</p> <p>Returns:</p> Type Description <code>plot_names</code> <p>List of strings identifying available plot functions.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def list_available_plots(self):\n    \"\"\"List the names of supported plots.\n\n    Returns\n    -------\n    plot_names\n        List of strings identifying available plot functions.\n    \"\"\"\n    return list(available_plots.keys())\n</code></pre>"},{"location":"full_doc/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.list_float_inputs","title":"list_float_inputs","text":"<pre><code>list_float_inputs()\n</code></pre> <p>Return the current scalar input values.</p> <p>Returns:</p> Type Description <code>float_inputs</code> <p>Dictionary of scalar input names and their values.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def list_float_inputs(self):\n    \"\"\"Return the current scalar input values.\n\n    Returns\n    -------\n    float_inputs\n        Dictionary of scalar input names and their values.\n    \"\"\"\n    return self.data[\"float_inputs\"]\n</code></pre>"},{"location":"full_doc/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.list_str_inputs","title":"list_str_inputs","text":"<pre><code>list_str_inputs()\n</code></pre> <p>Return the current string input values.</p> <p>Returns:</p> Type Description <code>str_inputs</code> <p>Dictionary of string input names and their values.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def list_str_inputs(self):\n    \"\"\"Return the current string input values.\n\n    Returns\n    -------\n    str_inputs\n        Dictionary of string input names and their values.\n    \"\"\"\n    return self.data[\"str_inputs\"]\n</code></pre>"},{"location":"full_doc/aeromaps.core.process/#aeromaps.core.process.AeroMAPSProcess.plot","title":"plot","text":"<pre><code>plot(name, save=False, size_inches=None, remove_title=False)\n</code></pre> <p>Generate a predefined AeroMAPS plot.</p> <p>Depending on the plot name, this method uses either generic or fleet-specific plotting functions and optionally saves the figure to a PDF file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Identifier of the plot to generate, possible to obtain from list_available_plots().</p> required <code>save</code> <p>Whether to save the generated plot as a PDF file.</p> <code>False</code> <code>size_inches</code> <p>Optional figure size in inches as a tuple or list.</p> <code>None</code> <code>remove_title</code> <p>Whether to remove the plot title before saving.</p> <code>False</code> <p>Returns:</p> Type Description <code>fig</code> <p>Object holding the created plot, as returned by the plot function.</p> Source code in <code>aeromaps/core/process.py</code> <pre><code>def plot(self, name, save=False, size_inches=None, remove_title=False):\n    \"\"\"Generate a predefined AeroMAPS plot.\n\n    Depending on the plot name, this method uses either generic or\n    fleet-specific plotting functions and optionally saves the figure\n    to a PDF file.\n\n    Parameters\n    ----------\n    name\n        Identifier of the plot to generate, possible to obtain from list_available_plots().\n    save\n        Whether to save the generated plot as a PDF file.\n    size_inches\n        Optional figure size in inches as a tuple or list.\n    remove_title\n        Whether to remove the plot title before saving.\n\n    Returns\n    -------\n    fig\n        Object holding the created plot, as returned by the plot\n        function.\n    \"\"\"\n    if name in available_plots_fleet:\n        try:\n            # todo: if we pass the process to the plot, fleet_model is no longer needed as an argument.\n            fig = available_plots_fleet[name](self, self.fleet_model)\n            if save:\n                if size_inches is not None:\n                    fig.fig.set_size_inches(size_inches)\n                if remove_title:\n                    fig.fig.gca().set_title(\"\")\n                fig.fig.savefig(f\"{name}.pdf\", bbox_inches=\"tight\")\n        except AttributeError as e:\n            raise NameError(\n                f\"Plot {name} requires using bottom up fleet model. Original error: {e}\"\n            )\n    elif name in available_plots:\n        fig = available_plots[name](self)\n        if save:\n            if size_inches is not None:\n                fig.fig.set_size_inches(size_inches)\n            if remove_title:\n                fig.fig.gca().set_title(\"\")\n            fig.fig.savefig(f\"{name}.pdf\", bbox_inches=\"tight\")\n    else:\n        raise NameError(\n            f\"Plot {name} is not available. List of available plots: {list(available_plots.keys()), list(available_plots_fleet.keys())}\"\n        )\n    return fig\n</code></pre>"},{"location":"full_doc/aeromaps.gui.graphical_user_interface/","title":"<code>aeromaps.gui.graphical_user_interface</code>","text":""},{"location":"full_doc/aeromaps.gui/","title":"<code>aeromaps.gui</code>","text":""},{"location":"full_doc/aeromaps.gui.plots/","title":"<code>aeromaps.gui.plots</code>","text":""},{"location":"full_doc/aeromaps/","title":"<code>AeroMAPS</code>","text":"<p>Initialization module for the AeroMAPS package, which provides the function to create an AeroMAPSProcess.</p>"},{"location":"full_doc/aeromaps/#aeromaps.create_process","title":"create_process","text":"<pre><code>create_process(configuration_file=None, models=default_models_top_down, use_fleet_model=False, add_examples_aircraft_and_subcategory=True, optimisation=False)\n</code></pre> <p>Create an AeroMAPS process.</p> <p>Parameters:</p> Name Type Description Default <code>configuration_file</code> <code>str</code> <p>Path to the configuration file (default is None).</p> <code>None</code> <code>models</code> <code>dict</code> <p>Dictionary of models to be used (default is default_models_top_down).</p> <code>default_models_top_down</code> <code>use_fleet_model</code> <code>bool</code> <p>Whether to use the fleet model (default is False).</p> <code>False</code> <code>add_examples_aircraft_and_subcategory</code> <code>bool</code> <p>Whether to add example aircraft and subcategories (default is True).</p> <code>True</code> <code>optimisation</code> <code>bool</code> <p>Whether to enable optimisation (default is False).</p> <code>False</code> <p>Returns:</p> Type Description <code>AeroMAPSProcess</code> <p>An instance of the AeroMAPSProcess class.</p> Source code in <code>aeromaps/__init__.py</code> <pre><code>def create_process(\n    configuration_file=None,\n    models=default_models_top_down,\n    use_fleet_model=False,\n    add_examples_aircraft_and_subcategory=True,\n    optimisation=False,\n) -&gt; AeroMAPSProcess:\n    \"\"\"\n    Create an AeroMAPS process.\n\n    Parameters\n    ----------\n    configuration_file : str, optional\n        Path to the configuration file (default is None).\n    models : dict, optional\n        Dictionary of models to be used (default is default_models_top_down).\n    use_fleet_model : bool, optional\n        Whether to use the fleet model (default is False).\n    add_examples_aircraft_and_subcategory : bool, optional\n        Whether to add example aircraft and subcategories (default is True).\n    optimisation : bool, optional\n        Whether to enable optimisation (default is False).\n\n    Returns\n    -------\n    AeroMAPSProcess\n        An instance of the AeroMAPSProcess class.\n    \"\"\"\n\n    return AeroMAPSProcess(\n        configuration_file=configuration_file,\n        models=models,\n        use_fleet_model=use_fleet_model,\n        add_examples_aircraft_and_subcategory=add_examples_aircraft_and_subcategory,\n        optimisation=optimisation,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.ask/","title":"<code>aeromaps.models.air_transport.air_traffic.ask</code>","text":""},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.ask/#aeromaps.models.air_transport.air_traffic.ask--ask","title":"ask","text":"<p>Module for computing Available Seat Kilometers (ASK).</p>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.ask/#aeromaps.models.air_transport.air_traffic.ask.ASK","title":"ASK","text":"<pre><code>ASK(name='ask', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute Available Seat Kilometers (ASK) and its breakdown by range for passenger aircraft, based on load factor and revenue passenger kilometers [RPK].</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('ask' by default).</p> <code>'ask'</code> Source code in <code>aeromaps/models/air_transport/air_traffic/ask.py</code> <pre><code>def __init__(self, name=\"ask\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.ask/#aeromaps.models.air_transport.air_traffic.ask.ASK.compute","title":"compute","text":"<pre><code>compute(load_factor, rpk, rpk_short_range, rpk_medium_range, rpk_long_range)\n</code></pre> <p>Execute the computation of Available Seat Kilometers (ASK) and its breakdown by range.</p> <p>Parameters:</p> Name Type Description Default <code>load_factor</code> <code>Series</code> <p>Annual passenger load factor [%].</p> required <code>rpk</code> <code>Series</code> <p>Annual RPKs [RPK].</p> required <code>rpk_short_range</code> <code>Series</code> <p>Annual RPKs for short-range flights [RPK].</p> required <code>rpk_medium_range</code> <code>Series</code> <p>Annual RPKs for medium-range flights [RPK].</p> required <code>rpk_long_range</code> <code>Series</code> <p>Annual RPKs for long-range flights [RPK].</p> required <p>Returns:</p> Type Description <code>ask</code> <p>Annual ASKs [ASK].</p> <code>ask_short_range</code> <p>ASKs for short-range flights [ASK].</p> <code>ask_medium_range</code> <p>ASKs for medium-range flights [ASK].</p> <code>ask_long_range</code> <p>ASKs for long-range flights [ASK].</p> Source code in <code>aeromaps/models/air_transport/air_traffic/ask.py</code> <pre><code>def compute(\n    self,\n    load_factor: pd.Series,\n    rpk: pd.Series,\n    rpk_short_range: pd.Series,\n    rpk_medium_range: pd.Series,\n    rpk_long_range: pd.Series,\n) -&gt; Tuple[pd.Series, pd.Series, pd.Series, pd.Series]:\n    \"\"\"\n    Execute the computation of Available Seat Kilometers (ASK) and its breakdown by range.\n\n    Parameters\n    ----------\n    load_factor\n        Annual passenger load factor [%].\n    rpk\n        Annual RPKs [RPK].\n    rpk_short_range\n        Annual RPKs for short-range flights [RPK].\n    rpk_medium_range\n        Annual RPKs for medium-range flights [RPK].\n    rpk_long_range\n        Annual RPKs for long-range flights [RPK].\n\n    Returns\n    -------\n    ask\n        Annual ASKs [ASK].\n    ask_short_range\n        ASKs for short-range flights [ASK].\n    ask_medium_range\n        ASKs for medium-range flights [ASK].\n    ask_long_range\n        ASKs for long-range flights [ASK].\n    \"\"\"\n\n    # ASK calculation\n    ask = rpk / (load_factor / 100)\n    self.df.loc[:, \"ask\"] = ask\n\n    # Short range\n    for k in range(self.historic_start_year, self.end_year + 1):\n        self.df.loc[k, \"ask_short_range\"] = rpk_short_range.loc[k] / (load_factor.loc[k] / 100)\n\n    # Medium range\n    for k in range(self.historic_start_year, self.end_year + 1):\n        self.df.loc[k, \"ask_medium_range\"] = rpk_medium_range.loc[k] / (\n            load_factor.loc[k] / 100\n        )\n\n    # Long range\n    for k in range(self.historic_start_year, self.end_year + 1):\n        self.df.loc[k, \"ask_long_range\"] = rpk_long_range.loc[k] / (load_factor.loc[k] / 100)\n\n    ask_short_range = self.df[\"ask_short_range\"]\n    ask_medium_range = self.df[\"ask_medium_range\"]\n    ask_long_range = self.df[\"ask_long_range\"]\n\n    return ask, ask_short_range, ask_medium_range, ask_long_range\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic/","title":"<code>aeromaps.models.air_transport.air_traffic</code>","text":""},{"location":"full_doc/aeromaps.models.air_transport.air_traffic/#aeromaps.models.air_transport.air_traffic--air_traffic","title":"air_traffic","text":"<p>This package contains models and utilities related to air traffic computations, such as ASK, RPK, and RTK.</p>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.price_elasticity/","title":"<code>aeromaps.models.air_transport.air_traffic.price_elasticity</code>","text":""},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.price_elasticity/#aeromaps.models.air_transport.air_traffic.price_elasticity--price_elasticity","title":"price_elasticity","text":"<p>Module for computing air traffic (RPK) with price elasticity effects.</p>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.price_elasticity/#aeromaps.models.air_transport.air_traffic.price_elasticity.RPKWithElasticity","title":"RPKWithElasticity","text":"<pre><code>RPKWithElasticity(name='rpk_with_elasticity', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute Revenue Passenger Kilometers (RPK) with price elasticity and COVID-19 impact, considering exogenous growth rates by segment.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name of the model instance ('rpk_with_elasticity' by default).</p> <code>'rpk_with_elasticity'</code> Source code in <code>aeromaps/models/air_transport/air_traffic/price_elasticity.py</code> <pre><code>def __init__(self, name=\"rpk_with_elasticity\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.price_elasticity/#aeromaps.models.air_transport.air_traffic.price_elasticity.RPKWithElasticity.compute","title":"compute","text":"<pre><code>compute(rpk_init, short_range_rpk_share_2019, medium_range_rpk_share_2019, long_range_rpk_share_2019, covid_start_year, covid_rpk_drop_start_year, covid_end_year_passenger, covid_end_year_reference_rpk_ratio, cagr_passenger_short_range_reference_periods, cagr_passenger_short_range_reference_periods_values, cagr_passenger_medium_range_reference_periods, cagr_passenger_medium_range_reference_periods_values, cagr_passenger_long_range_reference_periods, cagr_passenger_long_range_reference_periods_values, rpk_short_range_measures_impact, rpk_medium_range_measures_impact, rpk_long_range_measures_impact, airfare_per_rpk, price_elasticity)\n</code></pre> <p>Execute the computation of prospective air traffic.</p> <p>Parameters:</p> Name Type Description Default <code>rpk_init</code> <code>Series</code> <p>Historical number of Revenue Passenger Kilometer (RPK) over 2000-2019 [RPK].</p> required <code>short_range_rpk_share_2019</code> <code>float</code> <p>Share of RPK from short-range market in 2019 [%].</p> required <code>medium_range_rpk_share_2019</code> <code>float</code> <p>Share of RPK from medium-range market in 2019 [%].</p> required <code>long_range_rpk_share_2019</code> <code>float</code> <p>Share of RPK from long-range market in 2019 [%].</p> required <code>covid_start_year</code> <code>Number</code> <p>Covid-19 start year [yr].</p> required <code>covid_rpk_drop_start_year</code> <code>float</code> <p>Drop in RPK due to Covid-19 for the start year [%].</p> required <code>covid_end_year_passenger</code> <code>Number</code> <p>Covid-19 end year [yr].</p> required <code>covid_end_year_reference_rpk_ratio</code> <code>float</code> <p>Percentage of traffic level reached in Covid-19 end year compared with the one in Covid-19 start year [%].</p> required <code>cagr_passenger_short_range_reference_periods</code> <code>list</code> <p>Reference periods for the CAGR for passenger short-range market [yr].</p> required <code>cagr_passenger_short_range_reference_periods_values</code> <code>list</code> <p>CAGR for passenger short-range market for the reference periods [%].</p> required <code>cagr_passenger_medium_range_reference_periods</code> <code>list</code> <p>Reference periods for the CAGR for passenger medium-range market [yr].</p> required <code>cagr_passenger_medium_range_reference_periods_values</code> <code>list</code> <p>CAGR for passenger medium-range market for the reference periods [%].</p> required <code>cagr_passenger_long_range_reference_periods</code> <code>list</code> <p>Reference periods for the CAGR for passenger long-range market [yr].</p> required <code>cagr_passenger_long_range_reference_periods_values</code> <code>list</code> <p>CAGR for passenger long-range market for the reference periods [%].</p> required <code>rpk_short_range_measures_impact</code> <code>Series</code> <p>Traffic reduction impact of specific measures for passenger short-range market [%].</p> required <code>rpk_medium_range_measures_impact</code> <code>Series</code> <p>Traffic reduction impact of specific measures for passenger medium-range market [%].</p> required <code>rpk_long_range_measures_impact</code> <code>Series</code> <p>Traffic reduction impact of specific measures for passenger long-range market [%].</p> required <code>airfare_per_rpk</code> <code>Series</code> <p>Airfare per RPK [\u20ac/RPK].</p> required <code>price_elasticity</code> <code>float</code> <p>Price elasticity of demand [-].</p> required <p>Returns:</p> Type Description <code>rpk_short_range</code> <p>Number of Revenue Passenger Kilometer (RPK) for passenger short-range market [RPK].</p> <code>rpk_medium_range</code> <p>Number of Revenue Passenger Kilometer (RPK) for passenger medium-range market [RPK].</p> <code>rpk_long_range</code> <p>Number of Revenue Passenger Kilometer (RPK) for passenger long-range market [RPK].</p> <code>rpk</code> <p>Number of Revenue Passenger Kilometer (RPK) for total passenger air transport [RPK].</p> <code>rpk_no_elasticity</code> <p>RPKs without considering price elasticity [RPK].</p> <code>rpk_short_range_no_elasticity</code> <p>Short-range RPKs without considering price elasticity [RPK].</p> <code>rpk_medium_range_no_elasticity</code> <p>Medium-range RPKs without considering price elasticity [RPK].</p> <code>rpk_long_range_no_elasticity</code> <p>Long-range RPKs without considering price elasticity [RPK].</p> <code>annual_growth_rate_passenger_short_range</code> <p>Annual growth rate for short-range passengers [%/year].</p> <code>annual_growth_rate_passenger_medium_range</code> <p>Annual growth rate for medium-range passengers [%/year].</p> <code>annual_growth_rate_passenger_long_range</code> <p>Annual growth rate for long-range passengers [%/year].</p> <code>annual_growth_rate_passenger</code> <p>Annual growth rate for total passengers [%/year].</p> <code>cagr_rpk_short_range</code> <p>Air traffic CAGR over prospective_years for passenger short-range market [%].</p> <code>cagr_rpk_medium_range</code> <p>Air traffic CAGR over prospective_years for passenger medium-range market [%].</p> <code>cagr_rpk_long_range</code> <p>Air traffic CAGR over prospective_years for passenger long-range market [%].</p> <code>cagr_rpk</code> <p>Air traffic CAGR over prospective_years for total passenger market [%].</p> <code>prospective_evolution_rpk_short_range</code> <p>Evolution in percentage of Revenue Passenger Kilometer (RPK) for passenger short-range market between prospection_start_year and end_year [%].</p> <code>prospective_evolution_rpk_medium_range</code> <p>Evolution in percentage of Revenue Passenger Kilometer (RPK) for passenger medium-range market between prospection_start_year and end_year [%].</p> <code>prospective_evolution_rpk_long_range</code> <p>Evolution in percentage of Revenue Passenger Kilometer (RPK) for passenger long-range market between prospection_start_year and end_year [%].</p> <code>prospective_evolution_rpk</code> <p>Evolution in percentage of Revenue Passenger Kilometer (RPK) for total passenger market between prospection_start_year and end_year [%].</p> Source code in <code>aeromaps/models/air_transport/air_traffic/price_elasticity.py</code> <pre><code>def compute(\n    self,\n    rpk_init: pd.Series,\n    short_range_rpk_share_2019: float,\n    medium_range_rpk_share_2019: float,\n    long_range_rpk_share_2019: float,\n    covid_start_year: Number,\n    covid_rpk_drop_start_year: float,\n    covid_end_year_passenger: Number,\n    covid_end_year_reference_rpk_ratio: float,\n    cagr_passenger_short_range_reference_periods: list,\n    cagr_passenger_short_range_reference_periods_values: list,\n    cagr_passenger_medium_range_reference_periods: list,\n    cagr_passenger_medium_range_reference_periods_values: list,\n    cagr_passenger_long_range_reference_periods: list,\n    cagr_passenger_long_range_reference_periods_values: list,\n    rpk_short_range_measures_impact: pd.Series,\n    rpk_medium_range_measures_impact: pd.Series,\n    rpk_long_range_measures_impact: pd.Series,\n    airfare_per_rpk: pd.Series,\n    price_elasticity: float,\n) -&gt; Tuple[\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    float,\n    float,\n    float,\n    float,\n    float,\n    float,\n    float,\n    float,\n]:\n    \"\"\"\n    Execute the computation of prospective air traffic.\n\n    Parameters\n    ----------\n    rpk_init\n        Historical number of Revenue Passenger Kilometer (RPK) over 2000-2019 [RPK].\n    short_range_rpk_share_2019\n        Share of RPK from short-range market in 2019 [%].\n    medium_range_rpk_share_2019\n        Share of RPK from medium-range market in 2019 [%].\n    long_range_rpk_share_2019\n        Share of RPK from long-range market in 2019 [%].\n    covid_start_year\n        Covid-19 start year [yr].\n    covid_rpk_drop_start_year\n        Drop in RPK due to Covid-19 for the start year [%].\n    covid_end_year_passenger\n        Covid-19 end year [yr].\n    covid_end_year_reference_rpk_ratio\n        Percentage of traffic level reached in Covid-19 end year compared with the one in Covid-19 start year [%].\n    cagr_passenger_short_range_reference_periods\n        Reference periods for the CAGR for passenger short-range market [yr].\n    cagr_passenger_short_range_reference_periods_values\n        CAGR for passenger short-range market for the reference periods [%].\n    cagr_passenger_medium_range_reference_periods\n        Reference periods for the CAGR for passenger medium-range market [yr].\n    cagr_passenger_medium_range_reference_periods_values\n        CAGR for passenger medium-range market for the reference periods [%].\n    cagr_passenger_long_range_reference_periods\n        Reference periods for the CAGR for passenger long-range market [yr].\n    cagr_passenger_long_range_reference_periods_values\n        CAGR for passenger long-range market for the reference periods [%].\n    rpk_short_range_measures_impact\n        Traffic reduction impact of specific measures for passenger short-range market [%].\n    rpk_medium_range_measures_impact\n        Traffic reduction impact of specific measures for passenger medium-range market [%].\n    rpk_long_range_measures_impact\n        Traffic reduction impact of specific measures for passenger long-range market [%].\n    airfare_per_rpk\n        Airfare per RPK [\u20ac/RPK].\n    price_elasticity\n        Price elasticity of demand [-].\n\n    Returns\n    -------\n    rpk_short_range\n        Number of Revenue Passenger Kilometer (RPK) for passenger short-range market [RPK].\n    rpk_medium_range\n        Number of Revenue Passenger Kilometer (RPK) for passenger medium-range market [RPK].\n    rpk_long_range\n        Number of Revenue Passenger Kilometer (RPK) for passenger long-range market [RPK].\n    rpk\n        Number of Revenue Passenger Kilometer (RPK) for total passenger air transport [RPK].\n    rpk_no_elasticity\n        RPKs without considering price elasticity [RPK].\n    rpk_short_range_no_elasticity\n        Short-range RPKs without considering price elasticity [RPK].\n    rpk_medium_range_no_elasticity\n        Medium-range RPKs without considering price elasticity [RPK].\n    rpk_long_range_no_elasticity\n        Long-range RPKs without considering price elasticity [RPK].\n    annual_growth_rate_passenger_short_range\n        Annual growth rate for short-range passengers [%/year].\n    annual_growth_rate_passenger_medium_range\n        Annual growth rate for medium-range passengers [%/year].\n    annual_growth_rate_passenger_long_range\n        Annual growth rate for long-range passengers [%/year].\n    annual_growth_rate_passenger\n        Annual growth rate for total passengers [%/year].\n    cagr_rpk_short_range\n        Air traffic CAGR over prospective_years for passenger short-range market [%].\n    cagr_rpk_medium_range\n        Air traffic CAGR over prospective_years for passenger medium-range market [%].\n    cagr_rpk_long_range\n        Air traffic CAGR over prospective_years for passenger long-range market [%].\n    cagr_rpk\n        Air traffic CAGR over prospective_years for total passenger market [%].\n    prospective_evolution_rpk_short_range\n        Evolution in percentage of Revenue Passenger Kilometer (RPK) for passenger short-range market between prospection_start_year and end_year [%].\n    prospective_evolution_rpk_medium_range\n        Evolution in percentage of Revenue Passenger Kilometer (RPK) for passenger medium-range market between prospection_start_year and end_year [%].\n    prospective_evolution_rpk_long_range\n        Evolution in percentage of Revenue Passenger Kilometer (RPK) for passenger long-range market between prospection_start_year and end_year [%].\n    prospective_evolution_rpk\n        Evolution in percentage of Revenue Passenger Kilometer (RPK) for total passenger market between prospection_start_year and end_year [%].\n    \"\"\"\n\n    hist_index = range(self.historic_start_year, self.prospection_start_year)\n    covid_years = range(covid_start_year, covid_end_year_passenger + 1)\n    proj_years = range(covid_end_year_passenger + 1, self.end_year + 1)\n    # all_years = range(self.historic_start_year, self.end_year + 1)\n\n    self.df.loc[hist_index, \"rpk_short_range\"] = (\n        short_range_rpk_share_2019 / 100 * rpk_init.loc[hist_index]\n    )\n    self.df.loc[hist_index, \"rpk_medium_range\"] = (\n        medium_range_rpk_share_2019 / 100 * rpk_init.loc[hist_index]\n    )\n    self.df.loc[hist_index, \"rpk_long_range\"] = (\n        long_range_rpk_share_2019 / 100 * rpk_init.loc[hist_index]\n    )\n\n    # Covid functions\n    reference_years = [covid_start_year, covid_end_year_passenger]\n    reference_values_covid = [\n        1 - covid_rpk_drop_start_year / 100,\n        covid_end_year_reference_rpk_ratio / 100,\n    ]\n    covid_function = interp1d(reference_years, reference_values_covid, kind=\"linear\")\n    covid_factors = pd.Series(\n        [float(covid_function(k)) for k in covid_years], index=covid_years, dtype=float\n    )\n\n    # CAGR function\n    ## Short range\n    annual_growth_rate_passenger_short_range_prospective = aeromaps_leveling_function(\n        self,\n        cagr_passenger_short_range_reference_periods,\n        cagr_passenger_short_range_reference_periods_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"annual_growth_rate_passenger_short_range\"] = (\n        annual_growth_rate_passenger_short_range_prospective\n    )\n    ## Medium range\n    annual_growth_rate_passenger_medium_range_prospective = aeromaps_leveling_function(\n        self,\n        cagr_passenger_medium_range_reference_periods,\n        cagr_passenger_medium_range_reference_periods_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"annual_growth_rate_passenger_medium_range\"] = (\n        annual_growth_rate_passenger_medium_range_prospective\n    )\n    ## Long range\n    annual_growth_rate_passenger_long_range_prospective = aeromaps_leveling_function(\n        self,\n        cagr_passenger_long_range_reference_periods,\n        cagr_passenger_long_range_reference_periods_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"annual_growth_rate_passenger_long_range\"] = (\n        annual_growth_rate_passenger_long_range_prospective\n    )\n\n    # Covid p\u00e9riode vectoris\u00e9e\n    prev_short = self.df.loc[covid_start_year - 1, \"rpk_short_range\"]\n    prev_medium = self.df.loc[covid_start_year - 1, \"rpk_medium_range\"]\n    prev_long = self.df.loc[covid_start_year - 1, \"rpk_long_range\"]\n    self.df.loc[covid_years, \"rpk_short_range\"] = prev_short * covid_factors\n    self.df.loc[covid_years, \"rpk_medium_range\"] = prev_medium * covid_factors\n    self.df.loc[covid_years, \"rpk_long_range\"] = prev_long * covid_factors\n\n    # Prospective p\u00e9riode vectoris\u00e9e (hors covid)\n    # Short\n    growth_short = 1 + self.df.loc[proj_years, \"annual_growth_rate_passenger_short_range\"] / 100\n    self.df.loc[proj_years, \"rpk_short_range\"] = (\n        self.df.loc[covid_end_year_passenger, \"rpk_short_range\"] * growth_short.cumprod()\n    )\n    # Medium\n    growth_medium = (\n        1 + self.df.loc[proj_years, \"annual_growth_rate_passenger_medium_range\"] / 100\n    )\n    self.df.loc[proj_years, \"rpk_medium_range\"] = (\n        self.df.loc[covid_end_year_passenger, \"rpk_medium_range\"] * growth_medium.cumprod()\n    )\n    # Long\n    growth_long = 1 + self.df.loc[proj_years, \"annual_growth_rate_passenger_long_range\"] / 100\n    self.df.loc[proj_years, \"rpk_long_range\"] = (\n        self.df.loc[covid_end_year_passenger, \"rpk_long_range\"] * growth_long.cumprod()\n    )\n\n    rpk_short_range_no_elasticity = self.df[\"rpk_short_range\"].copy()\n    rpk_medium_range_no_elasticity = self.df[\"rpk_medium_range\"].copy()\n    rpk_long_range_no_elasticity = self.df[\"rpk_long_range\"].copy()\n\n    # rpk_no_elasticity\n    self.df.loc[hist_index, \"rpk_no_elasticity\"] = rpk_init.loc[hist_index]\n    self.df.loc[self.prospection_start_year : self.end_year, \"rpk_no_elasticity\"] = (\n        self.df.loc[self.prospection_start_year : self.end_year, \"rpk_short_range\"].fillna(0)\n        + self.df.loc[self.prospection_start_year : self.end_year, \"rpk_medium_range\"].fillna(0)\n        + self.df.loc[self.prospection_start_year : self.end_year, \"rpk_long_range\"].fillna(0)\n    )\n    rpk_no_elasticity = self.df[\"rpk_no_elasticity\"]\n\n    self.df.loc[self.historic_start_year : covid_end_year_passenger, \"rpk\"] = (\n        rpk_no_elasticity.loc[self.historic_start_year : covid_end_year_passenger]\n    )\n\n    airfare_init = 0.09236379319842411\n\n    self.df.loc[covid_end_year_passenger + 1 : self.end_year, \"rpk\"] = (\n        rpk_no_elasticity\n        / (airfare_init**price_elasticity)\n        * (\n            airfare_per_rpk.loc[covid_end_year_passenger + 1 : self.end_year]\n            ** price_elasticity\n        )\n    )\n\n    # R\u00e9partition par segment vectoris\u00e9e\n    rpk_short_range = self.df[\"rpk_short_range\"] * self.df[\"rpk\"] / rpk_no_elasticity\n    rpk_medium_range = self.df[\"rpk_medium_range\"] * self.df[\"rpk\"] / rpk_no_elasticity\n    rpk_long_range = self.df[\"rpk_long_range\"] * self.df[\"rpk\"] / rpk_no_elasticity\n\n    # TODO discuss if that should be considered for surplus destruction. I think so =&gt; not inlcluded in rpk_no_elasticity\n    rpk_short_range = rpk_short_range * rpk_short_range_measures_impact\n    rpk_medium_range = rpk_medium_range * rpk_medium_range_measures_impact\n    rpk_long_range = rpk_long_range * rpk_long_range_measures_impact\n\n    self.df.loc[:, \"rpk_short_range\"] = rpk_short_range\n    self.df.loc[:, \"rpk_medium_range\"] = rpk_medium_range\n    self.df.loc[:, \"rpk_long_range\"] = rpk_long_range\n\n    # Total RPK vectoris\u00e9\n    self.df.loc[hist_index, \"rpk\"] = rpk_init.loc[hist_index]\n    self.df.loc[self.prospection_start_year : self.end_year, \"rpk\"] = (\n        self.df.loc[self.prospection_start_year : self.end_year, \"rpk_short_range\"].fillna(0)\n        + self.df.loc[self.prospection_start_year : self.end_year, \"rpk_medium_range\"].fillna(0)\n        + self.df.loc[self.prospection_start_year : self.end_year, \"rpk_long_range\"].fillna(0)\n    )\n    rpk = self.df[\"rpk\"]\n\n    # Annual growth rates vectoris\u00e9s\n    idx_growth = range(self.historic_start_year + 1, self.end_year + 1)\n    self.df.loc[idx_growth, \"annual_growth_rate_passenger_short_range\"] = (\n        self.df[\"rpk_short_range\"].loc[idx_growth].values\n        / self.df[\"rpk_short_range\"].shift(1).loc[idx_growth].values\n        - 1\n    ) * 100\n    self.df.loc[idx_growth, \"annual_growth_rate_passenger_medium_range\"] = (\n        self.df[\"rpk_medium_range\"].loc[idx_growth].values\n        / self.df[\"rpk_medium_range\"].shift(1).loc[idx_growth].values\n        - 1\n    ) * 100\n    self.df.loc[idx_growth, \"annual_growth_rate_passenger_long_range\"] = (\n        self.df[\"rpk_long_range\"].loc[idx_growth].values\n        / self.df[\"rpk_long_range\"].shift(1).loc[idx_growth].values\n        - 1\n    ) * 100\n    self.df.loc[idx_growth, \"annual_growth_rate_passenger\"] = (\n        self.df[\"rpk\"].loc[idx_growth].values / self.df[\"rpk\"].shift(1).loc[idx_growth].values\n        - 1\n    ) * 100\n\n    annual_growth_rate_passenger_short_range = self.df[\n        \"annual_growth_rate_passenger_short_range\"\n    ]\n    annual_growth_rate_passenger_medium_range = self.df[\n        \"annual_growth_rate_passenger_medium_range\"\n    ]\n    annual_growth_rate_passenger_long_range = self.df[\"annual_growth_rate_passenger_long_range\"]\n    annual_growth_rate_passenger = self.df[\"annual_growth_rate_passenger\"]\n\n    # Compound Annual Growth Rate (CAGR)\n    cagr_rpk_short_range = 100 * (\n        (\n            self.df.loc[self.end_year, \"rpk_short_range\"]\n            / self.df.loc[self.prospection_start_year - 1, \"rpk_short_range\"]\n        )\n        ** (1 / (self.end_year - self.prospection_start_year))\n        - 1\n    )\n    cagr_rpk_medium_range = 100 * (\n        (\n            self.df.loc[self.end_year, \"rpk_medium_range\"]\n            / self.df.loc[self.prospection_start_year - 1, \"rpk_medium_range\"]\n        )\n        ** (1 / (self.end_year - self.prospection_start_year))\n        - 1\n    )\n    cagr_rpk_long_range = 100 * (\n        (\n            self.df.loc[self.end_year, \"rpk_long_range\"]\n            / self.df.loc[self.prospection_start_year - 1, \"rpk_long_range\"]\n        )\n        ** (1 / (self.end_year - self.prospection_start_year))\n        - 1\n    )\n    cagr_rpk = 100 * (\n        (\n            self.df.loc[self.end_year, \"rpk\"]\n            / self.df.loc[self.prospection_start_year - 1, \"rpk\"]\n        )\n        ** (1 / (self.end_year - self.prospection_start_year))\n        - 1\n    )\n\n    # Prospective evolution of RPK (between prospection_start_year-1 and end_year)\n    prospective_evolution_rpk_short_range = 100 * (\n        self.df.loc[self.end_year, \"rpk_short_range\"]\n        / self.df.loc[self.prospection_start_year - 1, \"rpk_short_range\"]\n        - 1\n    )\n    prospective_evolution_rpk_medium_range = 100 * (\n        self.df.loc[self.end_year, \"rpk_medium_range\"]\n        / self.df.loc[self.prospection_start_year - 1, \"rpk_medium_range\"]\n        - 1\n    )\n    prospective_evolution_rpk_long_range = 100 * (\n        self.df.loc[self.end_year, \"rpk_long_range\"]\n        / self.df.loc[self.prospection_start_year - 1, \"rpk_long_range\"]\n        - 1\n    )\n    prospective_evolution_rpk = 100 * (\n        self.df.loc[self.end_year, \"rpk\"] / self.df.loc[self.prospection_start_year - 1, \"rpk\"]\n        - 1\n    )\n\n    self.float_outputs[\"cagr_rpk_short_range\"] = cagr_rpk_short_range\n    self.float_outputs[\"cagr_rpk_medium_range\"] = cagr_rpk_medium_range\n    self.float_outputs[\"cagr_rpk_long_range\"] = cagr_rpk_long_range\n    self.float_outputs[\"cagr_rpk\"] = cagr_rpk\n    self.float_outputs[\"prospective_evolution_rpk_short_range\"] = (\n        prospective_evolution_rpk_short_range\n    )\n    self.float_outputs[\"prospective_evolution_rpk_medium_range\"] = (\n        prospective_evolution_rpk_medium_range\n    )\n    self.float_outputs[\"prospective_evolution_rpk_long_range\"] = (\n        prospective_evolution_rpk_long_range\n    )\n    self.float_outputs[\"prospective_evolution_rpk\"] = prospective_evolution_rpk\n\n    return (\n        rpk_short_range,\n        rpk_medium_range,\n        rpk_long_range,\n        rpk,\n        rpk_no_elasticity,\n        rpk_short_range_no_elasticity,\n        rpk_medium_range_no_elasticity,\n        rpk_long_range_no_elasticity,\n        annual_growth_rate_passenger_short_range,\n        annual_growth_rate_passenger_medium_range,\n        annual_growth_rate_passenger_long_range,\n        annual_growth_rate_passenger,\n        cagr_rpk_short_range,\n        cagr_rpk_medium_range,\n        cagr_rpk_long_range,\n        cagr_rpk,\n        prospective_evolution_rpk_short_range,\n        prospective_evolution_rpk_medium_range,\n        prospective_evolution_rpk_long_range,\n        prospective_evolution_rpk,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.rpk/","title":"<code>aeromaps.models.air_transport.air_traffic.rpk</code>","text":""},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.rpk/#aeromaps.models.air_transport.air_traffic.rpk--rpk","title":"rpk","text":"<p>Module for computing air traffic (RPK) without price elasticity and effect of ad-hoc measures to reduce traffic.</p>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.rpk/#aeromaps.models.air_transport.air_traffic.rpk.RPK","title":"RPK","text":"<pre><code>RPK(name='rpk', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute traffic (RPK) without price elasticity considering COVID-19 impact and exogenous growth rates by segment.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('rpk' by default).</p> <code>'rpk'</code> Source code in <code>aeromaps/models/air_transport/air_traffic/rpk.py</code> <pre><code>def __init__(self, name=\"rpk\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.rpk/#aeromaps.models.air_transport.air_traffic.rpk.RPK.compute","title":"compute","text":"<pre><code>compute(rpk_init, short_range_rpk_share_2019, medium_range_rpk_share_2019, long_range_rpk_share_2019, covid_start_year, covid_rpk_drop_start_year, covid_end_year_passenger, covid_end_year_reference_rpk_ratio, cagr_passenger_short_range_reference_periods, cagr_passenger_short_range_reference_periods_values, cagr_passenger_medium_range_reference_periods, cagr_passenger_medium_range_reference_periods_values, cagr_passenger_long_range_reference_periods, cagr_passenger_long_range_reference_periods_values, rpk_short_range_measures_impact, rpk_medium_range_measures_impact, rpk_long_range_measures_impact)\n</code></pre> <p>RPK calculation.</p> <p>Parameters:</p> Name Type Description Default <code>rpk_init</code> <code>Series</code> <p>Historical number of Revenue Passenger Kilometer (RPK) over 2000-2019 [RPK].</p> required <code>short_range_rpk_share_2019</code> <code>float</code> <p>Share of RPK from short-range market in 2019 [%].</p> required <code>medium_range_rpk_share_2019</code> <code>float</code> <p>Share of RPK from medium-range market in 2019 [%].</p> required <code>long_range_rpk_share_2019</code> <code>float</code> <p>Share of RPK from long-range market in 2019 [%].</p> required <code>covid_start_year</code> <code>Number</code> <p>Covid-19 start year [yr].</p> required <code>covid_rpk_drop_start_year</code> <code>float</code> <p>Drop in RPK due to Covid-19 for the start year [%].</p> required <code>covid_end_year_passenger</code> <code>Number</code> <p>Covid-19 end year [yr].</p> required <code>covid_end_year_reference_rpk_ratio</code> <code>float</code> <p>Percentage of traffic level reached in Covid-19 end year compared with the one in Covid-19 start year [%].</p> required <code>cagr_passenger_short_range_reference_periods</code> <code>list</code> <p>Reference periods for the CAGR for passenger short-range market [yr].</p> required <code>cagr_passenger_short_range_reference_periods_values</code> <code>list</code> <p>CAGR for passenger short-range market for the reference periods [%].</p> required <code>cagr_passenger_medium_range_reference_periods</code> <code>list</code> <p>Reference periods for the CAGR for passenger medium-range market [yr].</p> required <code>cagr_passenger_medium_range_reference_periods_values</code> <code>list</code> <p>CAGR for passenger medium-range market for the reference periods [%].</p> required <code>cagr_passenger_long_range_reference_periods</code> <code>list</code> <p>Reference periods for the CAGR for passenger long-range market [yr].</p> required <code>cagr_passenger_long_range_reference_periods_values</code> <code>list</code> <p>CAGR for passenger long-range market for the reference periods [%].</p> required <code>rpk_short_range_measures_impact</code> <code>Series</code> <p>Traffic reduction impact of specific measures for passenger short-range market [%].</p> required <code>rpk_medium_range_measures_impact</code> <code>Series</code> <p>Traffic reduction impact of specific measures for passenger medium-range market [%].</p> required <code>rpk_long_range_measures_impact</code> <code>Series</code> <p>Traffic reduction impact of specific measures for passenger long-range market [%].</p> required <p>Returns:</p> Name Type Description <code>rpk_short_range</code> <code>Series</code> <p>Number of Revenue Passenger Kilometer (RPK) for passenger short-range market [RPK].</p> <code>rpk_medium_range</code> <code>Series</code> <p>Number of Revenue Passenger Kilometer (RPK) for passenger medium-range market [RPK].</p> <code>rpk_long_range</code> <code>Series</code> <p>Number of Revenue Passenger Kilometer (RPK) for passenger long-range market [RPK].</p> <code>rpk</code> <code>Series</code> <p>Number of Revenue Passenger Kilometer (RPK) for total passenger air transport [RPK].</p> <code>annual_growth_rate_passenger_short_range</code> <code>Series</code> <p>Annual growth rate for short-range passengers [%/year].</p> <code>annual_growth_rate_passenger_medium_range</code> <code>Series</code> <p>Annual growth rate for medium-range passengers [%/year].</p> <code>annual_growth_rate_passenger_long_range</code> <code>Series</code> <p>Annual growth rate for long-range passengers [%/year].</p> <code>annual_growth_rate_passenger</code> <code>Series</code> <p>Annual growth rate for total passengers [%/year].</p> <code>cagr_rpk_short_range</code> <code>float</code> <p>Air traffic CAGR over prospective_years for passenger short-range market [%].</p> <code>cagr_rpk_medium_range</code> <code>float</code> <p>Air traffic CAGR over prospective_years for passenger medium-range market [%].</p> <code>cagr_rpk_long_range</code> <code>float</code> <p>Air traffic CAGR over prospective_years for passenger long-range market [%].</p> <code>cagr_rpk</code> <code>float</code> <p>Air traffic CAGR over prospective_years for total passenger market [%].</p> <code>prospective_evolution_rpk_short_range</code> <code>float</code> <p>Evolution in percentage of Revenue Passenger Kilometer (RPK) for passenger short-range market between prospection_start_year and end_year [%].</p> <code>prospective_evolution_rpk_medium_range</code> <code>float</code> <p>Evolution in percentage of Revenue Passenger Kilometer (RPK) for passenger medium-range market between prospection_start_year and end_year [%].</p> <code>prospective_evolution_rpk_long_range</code> <code>float</code> <p>Evolution in percentage of Revenue Passenger Kilometer (RPK) for passenger long-range market between prospection_start_year and end_year [%].</p> <code>prospective_evolution_rpk</code> <code>float</code> <p>Evolution in percentage of Revenue Passenger Kilometer (RPK) for total passenger market between prospection_start_year and end_year [%].</p> Source code in <code>aeromaps/models/air_transport/air_traffic/rpk.py</code> <pre><code>def compute(\n    self,\n    rpk_init: pd.Series,\n    short_range_rpk_share_2019: float,\n    medium_range_rpk_share_2019: float,\n    long_range_rpk_share_2019: float,\n    covid_start_year: Number,\n    covid_rpk_drop_start_year: float,\n    covid_end_year_passenger: Number,\n    covid_end_year_reference_rpk_ratio: float,\n    cagr_passenger_short_range_reference_periods: list,\n    cagr_passenger_short_range_reference_periods_values: list,\n    cagr_passenger_medium_range_reference_periods: list,\n    cagr_passenger_medium_range_reference_periods_values: list,\n    cagr_passenger_long_range_reference_periods: list,\n    cagr_passenger_long_range_reference_periods_values: list,\n    rpk_short_range_measures_impact: pd.Series,\n    rpk_medium_range_measures_impact: pd.Series,\n    rpk_long_range_measures_impact: pd.Series,\n) -&gt; Tuple[\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    float,\n    float,\n    float,\n    float,\n    float,\n    float,\n    float,\n    float,\n]:\n    \"\"\"\n    RPK calculation.\n\n    Parameters\n    ----------\n    rpk_init : pd.Series\n        Historical number of Revenue Passenger Kilometer (RPK) over 2000-2019 [RPK].\n    short_range_rpk_share_2019 : float\n        Share of RPK from short-range market in 2019 [%].\n    medium_range_rpk_share_2019 : float\n        Share of RPK from medium-range market in 2019 [%].\n    long_range_rpk_share_2019 : float\n        Share of RPK from long-range market in 2019 [%].\n    covid_start_year : Number\n        Covid-19 start year [yr].\n    covid_rpk_drop_start_year : float\n        Drop in RPK due to Covid-19 for the start year [%].\n    covid_end_year_passenger : Number\n        Covid-19 end year [yr].\n    covid_end_year_reference_rpk_ratio : float\n        Percentage of traffic level reached in Covid-19 end year compared with the one in Covid-19 start year [%].\n    cagr_passenger_short_range_reference_periods : list\n        Reference periods for the CAGR for passenger short-range market [yr].\n    cagr_passenger_short_range_reference_periods_values : list\n        CAGR for passenger short-range market for the reference periods [%].\n    cagr_passenger_medium_range_reference_periods : list\n        Reference periods for the CAGR for passenger medium-range market [yr].\n    cagr_passenger_medium_range_reference_periods_values : list\n        CAGR for passenger medium-range market for the reference periods [%].\n    cagr_passenger_long_range_reference_periods : list\n        Reference periods for the CAGR for passenger long-range market [yr].\n    cagr_passenger_long_range_reference_periods_values : list\n        CAGR for passenger long-range market for the reference periods [%].\n    rpk_short_range_measures_impact : pd.Series\n        Traffic reduction impact of specific measures for passenger short-range market [%].\n    rpk_medium_range_measures_impact : pd.Series\n        Traffic reduction impact of specific measures for passenger medium-range market [%].\n    rpk_long_range_measures_impact : pd.Series\n        Traffic reduction impact of specific measures for passenger long-range market [%].\n\n    Returns\n    -------\n    rpk_short_range : pd.Series\n        Number of Revenue Passenger Kilometer (RPK) for passenger short-range market [RPK].\n    rpk_medium_range : pd.Series\n        Number of Revenue Passenger Kilometer (RPK) for passenger medium-range market [RPK].\n    rpk_long_range : pd.Series\n        Number of Revenue Passenger Kilometer (RPK) for passenger long-range market [RPK].\n    rpk : pd.Series\n        Number of Revenue Passenger Kilometer (RPK) for total passenger air transport [RPK].\n    annual_growth_rate_passenger_short_range : pd.Series\n        Annual growth rate for short-range passengers [%/year].\n    annual_growth_rate_passenger_medium_range : pd.Series\n        Annual growth rate for medium-range passengers [%/year].\n    annual_growth_rate_passenger_long_range : pd.Series\n        Annual growth rate for long-range passengers [%/year].\n    annual_growth_rate_passenger : pd.Series\n        Annual growth rate for total passengers [%/year].\n    cagr_rpk_short_range : float\n        Air traffic CAGR over prospective_years for passenger short-range market [%].\n    cagr_rpk_medium_range : float\n        Air traffic CAGR over prospective_years for passenger medium-range market [%].\n    cagr_rpk_long_range : float\n        Air traffic CAGR over prospective_years for passenger long-range market [%].\n    cagr_rpk : float\n        Air traffic CAGR over prospective_years for total passenger market [%].\n    prospective_evolution_rpk_short_range : float\n        Evolution in percentage of Revenue Passenger Kilometer (RPK) for passenger short-range market between prospection_start_year and end_year [%].\n    prospective_evolution_rpk_medium_range : float\n        Evolution in percentage of Revenue Passenger Kilometer (RPK) for passenger medium-range market between prospection_start_year and end_year [%].\n    prospective_evolution_rpk_long_range : float\n        Evolution in percentage of Revenue Passenger Kilometer (RPK) for passenger long-range market between prospection_start_year and end_year [%].\n    prospective_evolution_rpk : float\n        Evolution in percentage of Revenue Passenger Kilometer (RPK) for total passenger market between prospection_start_year and end_year [%].\n    \"\"\"\n    # Initialization based on 2019 share\n    for k in range(self.historic_start_year, self.prospection_start_year):\n        self.df.loc[k, \"rpk_short_range\"] = short_range_rpk_share_2019 / 100 * rpk_init.loc[k]\n        self.df.loc[k, \"rpk_medium_range\"] = medium_range_rpk_share_2019 / 100 * rpk_init.loc[k]\n        self.df.loc[k, \"rpk_long_range\"] = long_range_rpk_share_2019 / 100 * rpk_init.loc[k]\n\n    # Covid functions\n    reference_years = [covid_start_year, covid_end_year_passenger]\n    reference_values_covid = [\n        1 - covid_rpk_drop_start_year / 100,\n        covid_end_year_reference_rpk_ratio / 100,\n    ]\n    covid_function = interp1d(reference_years, reference_values_covid, kind=\"linear\")\n\n    # CAGR function\n    ## Short range\n    annual_growth_rate_passenger_short_range_prospective = aeromaps_leveling_function(\n        self,\n        cagr_passenger_short_range_reference_periods,\n        cagr_passenger_short_range_reference_periods_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"annual_growth_rate_passenger_short_range\"] = (\n        annual_growth_rate_passenger_short_range_prospective\n    )\n    ## Medium range\n    annual_growth_rate_passenger_medium_range_prospective = aeromaps_leveling_function(\n        self,\n        cagr_passenger_medium_range_reference_periods,\n        cagr_passenger_medium_range_reference_periods_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"annual_growth_rate_passenger_medium_range\"] = (\n        annual_growth_rate_passenger_medium_range_prospective\n    )\n    ## Long range\n    annual_growth_rate_passenger_long_range_prospective = aeromaps_leveling_function(\n        self,\n        cagr_passenger_long_range_reference_periods,\n        cagr_passenger_long_range_reference_periods_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"annual_growth_rate_passenger_long_range\"] = (\n        annual_growth_rate_passenger_long_range_prospective\n    )\n\n    # Short range\n    for k in range(covid_start_year, covid_end_year_passenger + 1):\n        self.df.loc[k, \"rpk_short_range\"] = self.df.loc[\n            covid_start_year - 1, \"rpk_short_range\"\n        ] * covid_function(k)\n    for k in range(covid_end_year_passenger + 1, self.end_year + 1):\n        self.df.loc[k, \"rpk_short_range\"] = self.df.loc[k - 1, \"rpk_short_range\"] * (\n            1 + self.df.loc[k, \"annual_growth_rate_passenger_short_range\"] / 100\n        )\n\n    # Medium range\n    for k in range(covid_start_year, covid_end_year_passenger + 1):\n        self.df.loc[k, \"rpk_medium_range\"] = self.df.loc[\n            covid_start_year - 1, \"rpk_medium_range\"\n        ] * covid_function(k)\n    for k in range(covid_end_year_passenger + 1, self.end_year + 1):\n        self.df.loc[k, \"rpk_medium_range\"] = self.df.loc[k - 1, \"rpk_medium_range\"] * (\n            1 + self.df.loc[k, \"annual_growth_rate_passenger_medium_range\"] / 100\n        )\n\n    # Long range\n    for k in range(covid_start_year, covid_end_year_passenger + 1):\n        self.df.loc[k, \"rpk_long_range\"] = self.df.loc[\n            covid_start_year - 1, \"rpk_long_range\"\n        ] * covid_function(k)\n    for k in range(covid_end_year_passenger + 1, self.end_year + 1):\n        self.df.loc[k, \"rpk_long_range\"] = self.df.loc[k - 1, \"rpk_long_range\"] * (\n            1 + self.df.loc[k, \"annual_growth_rate_passenger_long_range\"] / 100\n        )\n\n    rpk_short_range = self.df[\"rpk_short_range\"]\n    rpk_medium_range = self.df[\"rpk_medium_range\"]\n    rpk_long_range = self.df[\"rpk_long_range\"]\n\n    rpk_short_range = rpk_short_range * rpk_short_range_measures_impact\n    rpk_medium_range = rpk_medium_range * rpk_medium_range_measures_impact\n    rpk_long_range = rpk_long_range * rpk_long_range_measures_impact\n\n    self.df.loc[:, \"rpk_short_range\"] = rpk_short_range\n    self.df.loc[:, \"rpk_medium_range\"] = rpk_medium_range\n    self.df.loc[:, \"rpk_long_range\"] = rpk_long_range\n\n    # Total\n    for k in range(self.historic_start_year, self.prospection_start_year):\n        self.df.loc[k, \"rpk\"] = rpk_init.loc[k]\n    for k in range(self.prospection_start_year, self.end_year + 1):\n        self.df.loc[k, \"rpk\"] = (\n            self.df.loc[k, \"rpk_short_range\"]\n            + self.df.loc[k, \"rpk_medium_range\"]\n            + self.df.loc[k, \"rpk_long_range\"]\n        )\n    rpk = self.df[\"rpk\"]\n\n    # Annual growth rate\n    for k in range(self.historic_start_year + 1, self.prospection_start_year):\n        self.df.loc[k, \"annual_growth_rate_passenger_short_range\"] = (\n            self.df.loc[k, \"rpk_short_range\"] / self.df.loc[k - 1, \"rpk_short_range\"] - 1\n        ) * 100\n    for k in range(self.historic_start_year + 1, self.prospection_start_year):\n        self.df.loc[k, \"annual_growth_rate_passenger_medium_range\"] = (\n            self.df.loc[k, \"rpk_medium_range\"] / self.df.loc[k - 1, \"rpk_medium_range\"] - 1\n        ) * 100\n    for k in range(self.historic_start_year + 1, self.prospection_start_year):\n        self.df.loc[k, \"annual_growth_rate_passenger_long_range\"] = (\n            self.df.loc[k, \"rpk_long_range\"] / self.df.loc[k - 1, \"rpk_long_range\"] - 1\n        ) * 100\n    for k in range(self.historic_start_year + 1, self.end_year + 1):\n        self.df.loc[k, \"annual_growth_rate_passenger\"] = (\n            self.df.loc[k, \"rpk\"] / self.df.loc[k - 1, \"rpk\"] - 1\n        ) * 100\n\n    annual_growth_rate_passenger_short_range = self.df[\n        \"annual_growth_rate_passenger_short_range\"\n    ]\n    annual_growth_rate_passenger_medium_range = self.df[\n        \"annual_growth_rate_passenger_medium_range\"\n    ]\n    annual_growth_rate_passenger_long_range = self.df[\"annual_growth_rate_passenger_long_range\"]\n    annual_growth_rate_passenger = self.df[\"annual_growth_rate_passenger\"]\n\n    # Compound Annual Growth Rate (CAGR)\n    cagr_rpk_short_range = 100 * (\n        (\n            self.df.loc[self.end_year, \"rpk_short_range\"]\n            / self.df.loc[self.prospection_start_year - 1, \"rpk_short_range\"]\n        )\n        ** (1 / (self.end_year - self.prospection_start_year))\n        - 1\n    )\n    cagr_rpk_medium_range = 100 * (\n        (\n            self.df.loc[self.end_year, \"rpk_medium_range\"]\n            / self.df.loc[self.prospection_start_year - 1, \"rpk_medium_range\"]\n        )\n        ** (1 / (self.end_year - self.prospection_start_year))\n        - 1\n    )\n    cagr_rpk_long_range = 100 * (\n        (\n            self.df.loc[self.end_year, \"rpk_long_range\"]\n            / self.df.loc[self.prospection_start_year - 1, \"rpk_long_range\"]\n        )\n        ** (1 / (self.end_year - self.prospection_start_year))\n        - 1\n    )\n    cagr_rpk = 100 * (\n        (\n            self.df.loc[self.end_year, \"rpk\"]\n            / self.df.loc[self.prospection_start_year - 1, \"rpk\"]\n        )\n        ** (1 / (self.end_year - self.prospection_start_year))\n        - 1\n    )\n\n    # Prospective evolution of RPK (between prospection_start_year-1 and end_year)\n    prospective_evolution_rpk_short_range = 100 * (\n        self.df.loc[self.end_year, \"rpk_short_range\"]\n        / self.df.loc[self.prospection_start_year - 1, \"rpk_short_range\"]\n        - 1\n    )\n    prospective_evolution_rpk_medium_range = 100 * (\n        self.df.loc[self.end_year, \"rpk_medium_range\"]\n        / self.df.loc[self.prospection_start_year - 1, \"rpk_medium_range\"]\n        - 1\n    )\n    prospective_evolution_rpk_long_range = 100 * (\n        self.df.loc[self.end_year, \"rpk_long_range\"]\n        / self.df.loc[self.prospection_start_year - 1, \"rpk_long_range\"]\n        - 1\n    )\n    prospective_evolution_rpk = 100 * (\n        self.df.loc[self.end_year, \"rpk\"] / self.df.loc[self.prospection_start_year - 1, \"rpk\"]\n        - 1\n    )\n\n    self.float_outputs[\"cagr_rpk_short_range\"] = cagr_rpk_short_range\n    self.float_outputs[\"cagr_rpk_medium_range\"] = cagr_rpk_medium_range\n    self.float_outputs[\"cagr_rpk_long_range\"] = cagr_rpk_long_range\n    self.float_outputs[\"cagr_rpk\"] = cagr_rpk\n    self.float_outputs[\"prospective_evolution_rpk_short_range\"] = (\n        prospective_evolution_rpk_short_range\n    )\n    self.float_outputs[\"prospective_evolution_rpk_medium_range\"] = (\n        prospective_evolution_rpk_medium_range\n    )\n    self.float_outputs[\"prospective_evolution_rpk_long_range\"] = (\n        prospective_evolution_rpk_long_range\n    )\n    self.float_outputs[\"prospective_evolution_rpk\"] = prospective_evolution_rpk\n\n    return (\n        rpk_short_range,\n        rpk_medium_range,\n        rpk_long_range,\n        rpk,\n        annual_growth_rate_passenger_short_range,\n        annual_growth_rate_passenger_medium_range,\n        annual_growth_rate_passenger_long_range,\n        annual_growth_rate_passenger,\n        cagr_rpk_short_range,\n        cagr_rpk_medium_range,\n        cagr_rpk_long_range,\n        cagr_rpk,\n        prospective_evolution_rpk_short_range,\n        prospective_evolution_rpk_medium_range,\n        prospective_evolution_rpk_long_range,\n        prospective_evolution_rpk,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.rpk/#aeromaps.models.air_transport.air_traffic.rpk.RPKReference","title":"RPKReference","text":"<pre><code>RPKReference(name='rpk_reference', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute reference Revenue Passenger Kilometers (RPK) with baseline air traffic growth.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('rpk_reference' by default).</p> <code>'rpk_reference'</code> Source code in <code>aeromaps/models/air_transport/air_traffic/rpk.py</code> <pre><code>def __init__(self, name=\"rpk_reference\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.rpk/#aeromaps.models.air_transport.air_traffic.rpk.RPKReference.compute","title":"compute","text":"<pre><code>compute(rpk, reference_cagr_passenger_reference_periods, reference_cagr_passenger_reference_periods_values, covid_start_year, covid_rpk_drop_start_year, covid_end_year_passenger, covid_end_year_reference_rpk_ratio)\n</code></pre> <p>RPK reference calculation.</p> <p>Parameters:</p> Name Type Description Default <code>rpk</code> <code>Series</code> <p>Number of Revenue Passenger Kilometer (RPK) for all passenger air transport [RPK].</p> required <code>reference_cagr_passenger_reference_periods</code> <code>list</code> <p>Reference periods for the reference CAGR for passenger market [yr].</p> required <code>reference_cagr_passenger_reference_periods_values</code> <code>list</code> <p>Reference CAGR for passenger market for the reference periods [%].</p> required <code>covid_start_year</code> <code>Number</code> <p>Covid-19 start year [yr].</p> required <code>covid_rpk_drop_start_year</code> <code>float</code> <p>Drop in RPK due to Covid-19 for the start year [%].</p> required <code>covid_end_year_passenger</code> <code>Number</code> <p>Covid-19 end year [yr].</p> required <code>covid_end_year_reference_rpk_ratio</code> <code>float</code> <p>Percentage of traffic level reached in Covid-19 end year compared with the one in Covid-19 start year [%].</p> required <p>Returns:</p> Name Type Description <code>rpk_reference</code> <code>Series</code> <p>Number of Revenue Passenger Kilometer (RPK) for all passenger air transport with a baseline air traffic growth [RPK].</p> <code>reference_annual_growth_rate_passenger</code> <code>Series</code> <p>Reference annual growth rate for passenger market [%/year].</p> Source code in <code>aeromaps/models/air_transport/air_traffic/rpk.py</code> <pre><code>def compute(\n    self,\n    rpk: pd.Series,\n    reference_cagr_passenger_reference_periods: list,\n    reference_cagr_passenger_reference_periods_values: list,\n    covid_start_year: Number,\n    covid_rpk_drop_start_year: float,\n    covid_end_year_passenger: Number,\n    covid_end_year_reference_rpk_ratio: float,\n) -&gt; Tuple[pd.Series, pd.Series]:\n    \"\"\"\n    RPK reference calculation.\n\n    Parameters\n    ----------\n    rpk : pd.Series\n        Number of Revenue Passenger Kilometer (RPK) for all passenger air transport [RPK].\n    reference_cagr_passenger_reference_periods : list\n        Reference periods for the reference CAGR for passenger market [yr].\n    reference_cagr_passenger_reference_periods_values : list\n        Reference CAGR for passenger market for the reference periods [%].\n    covid_start_year : Number\n        Covid-19 start year [yr].\n    covid_rpk_drop_start_year : float\n        Drop in RPK due to Covid-19 for the start year [%].\n    covid_end_year_passenger : Number\n        Covid-19 end year [yr].\n    covid_end_year_reference_rpk_ratio : float\n        Percentage of traffic level reached in Covid-19 end year compared with the one in Covid-19 start year [%].\n\n    Returns\n    -------\n    rpk_reference : pd.Series\n        Number of Revenue Passenger Kilometer (RPK) for all passenger air transport with a baseline air traffic growth [RPK].\n    reference_annual_growth_rate_passenger : pd.Series\n        Reference annual growth rate for passenger market [%/year].\n    \"\"\"\n    for k in range(self.historic_start_year, self.prospection_start_year):\n        self.df.loc[k, \"rpk_reference\"] = rpk.loc[k]\n\n    covid_start_year = int(covid_start_year)\n    covid_rpk_drop_start_year = int(covid_rpk_drop_start_year)\n    covid_end_year_passenger = int(covid_end_year_passenger)\n    covid_end_year_reference_rpk_ratio = int(covid_end_year_reference_rpk_ratio)\n\n    self.df.loc[covid_start_year - 1, \"rpk_reference\"] = rpk.loc[covid_start_year - 1]\n\n    # Covid functions\n    reference_years = [covid_start_year, covid_end_year_passenger]\n    reference_values_covid = [\n        1 - covid_rpk_drop_start_year / 100,\n        covid_end_year_reference_rpk_ratio / 100,\n    ]\n    covid_function = interp1d(reference_years, reference_values_covid, kind=\"linear\")\n\n    # CAGR function\n    reference_annual_growth_rate_passenger = aeromaps_leveling_function(\n        self,\n        reference_cagr_passenger_reference_periods,\n        reference_cagr_passenger_reference_periods_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"reference_annual_growth_rate_passenger\"] = (\n        reference_annual_growth_rate_passenger\n    )\n\n    # Main\n    for k in range(covid_start_year, covid_end_year_passenger + 1):\n        self.df.loc[k, \"rpk_reference\"] = self.df.loc[\n            covid_start_year - 1, \"rpk_reference\"\n        ] * covid_function(k)\n    for k in range(covid_end_year_passenger + 1, self.end_year + 1):\n        self.df.loc[k, \"rpk_reference\"] = self.df.loc[k - 1, \"rpk_reference\"] * (\n            1 + self.df.loc[k, \"reference_annual_growth_rate_passenger\"] / 100\n        )\n\n    rpk_reference = self.df[\"rpk_reference\"]\n\n    return (rpk_reference, reference_annual_growth_rate_passenger)\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.rpk/#aeromaps.models.air_transport.air_traffic.rpk.RPKMeasures","title":"RPKMeasures","text":"<pre><code>RPKMeasures(name='rpk_measures', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute the impact of ad-hoc measures to reduce short, medium, and long-range traffic.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('rpk_measures' by default).</p> <code>'rpk_measures'</code> Source code in <code>aeromaps/models/air_transport/air_traffic/rpk.py</code> <pre><code>def __init__(self, name=\"rpk_measures\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.rpk/#aeromaps.models.air_transport.air_traffic.rpk.RPKMeasures.compute","title":"compute","text":"<pre><code>compute(rpk_short_range_measures_final_impact, rpk_medium_range_measures_final_impact, rpk_long_range_measures_final_impact, rpk_short_range_measures_start_year, rpk_medium_range_measures_start_year, rpk_long_range_measures_start_year, rpk_short_range_measures_duration, rpk_medium_range_measures_duration, rpk_long_range_measures_duration)\n</code></pre> <p>RPK measures impact calculation.</p> <p>Parameters:</p> Name Type Description Default <code>rpk_short_range_measures_final_impact</code> <code>float</code> <p>Final impact of specific measures in terms of percentage reduction in RPK for short-range market [%].</p> required <code>rpk_medium_range_measures_final_impact</code> <code>float</code> <p>Final impact of specific measures in terms of percentage reduction in RPK for medium-range market [%].</p> required <code>rpk_long_range_measures_final_impact</code> <code>float</code> <p>Final impact of specific measures in terms of percentage reduction in RPK for long-range market [%].</p> required <code>rpk_short_range_measures_start_year</code> <code>Number</code> <p>Start year for implementing specific measures to reduce RPK on short-range market [yr].</p> required <code>rpk_medium_range_measures_start_year</code> <code>Number</code> <p>Start year for implementing specific measures to reduce RPK on medium-range market [yr].</p> required <code>rpk_long_range_measures_start_year</code> <code>Number</code> <p>Start year for implementing specific measures to reduce RPK on long-range market [yr].</p> required <code>rpk_short_range_measures_duration</code> <code>float</code> <p>Duration for implementing 98% of specific measures to reduce RPK on short-range market [yr].</p> required <code>rpk_medium_range_measures_duration</code> <code>float</code> <p>Duration for implementing 98% of specific measures to reduce RPK on medium-range market [yr].</p> required <code>rpk_long_range_measures_duration</code> <code>float</code> <p>Duration for implementing 98% of specific measures to reduce RPK on long-range market [yr].</p> required <p>Returns:</p> Name Type Description <code>rpk_short_range_measures_impact</code> <code>Series</code> <p>Traffic reduction impact of specific measures for passenger short-range market [%].</p> <code>rpk_medium_range_measures_impact</code> <code>Series</code> <p>Traffic reduction impact of specific measures for passenger medium-range market [%].</p> <code>rpk_long_range_measures_impact</code> <code>Series</code> <p>Traffic reduction impact of specific measures for passenger long-range market [%].</p> Source code in <code>aeromaps/models/air_transport/air_traffic/rpk.py</code> <pre><code>def compute(\n    self,\n    rpk_short_range_measures_final_impact: float,\n    rpk_medium_range_measures_final_impact: float,\n    rpk_long_range_measures_final_impact: float,\n    rpk_short_range_measures_start_year: Number,\n    rpk_medium_range_measures_start_year: Number,\n    rpk_long_range_measures_start_year: Number,\n    rpk_short_range_measures_duration: float,\n    rpk_medium_range_measures_duration: float,\n    rpk_long_range_measures_duration: float,\n) -&gt; Tuple[pd.Series, pd.Series, pd.Series]:\n    \"\"\"\n    RPK measures impact calculation.\n\n    Parameters\n    ----------\n    rpk_short_range_measures_final_impact : float\n        Final impact of specific measures in terms of percentage reduction in RPK for short-range market [%].\n    rpk_medium_range_measures_final_impact : float\n        Final impact of specific measures in terms of percentage reduction in RPK for medium-range market [%].\n    rpk_long_range_measures_final_impact : float\n        Final impact of specific measures in terms of percentage reduction in RPK for long-range market [%].\n    rpk_short_range_measures_start_year : Number\n        Start year for implementing specific measures to reduce RPK on short-range market [yr].\n    rpk_medium_range_measures_start_year : Number\n        Start year for implementing specific measures to reduce RPK on medium-range market [yr].\n    rpk_long_range_measures_start_year : Number\n        Start year for implementing specific measures to reduce RPK on long-range market [yr].\n    rpk_short_range_measures_duration : float\n        Duration for implementing 98% of specific measures to reduce RPK on short-range market [yr].\n    rpk_medium_range_measures_duration : float\n        Duration for implementing 98% of specific measures to reduce RPK on medium-range market [yr].\n    rpk_long_range_measures_duration : float\n        Duration for implementing 98% of specific measures to reduce RPK on long-range market [yr].\n\n    Returns\n    -------\n    rpk_short_range_measures_impact : pd.Series\n        Traffic reduction impact of specific measures for passenger short-range market [%].\n    rpk_medium_range_measures_impact : pd.Series\n        Traffic reduction impact of specific measures for passenger medium-range market [%].\n    rpk_long_range_measures_impact : pd.Series\n        Traffic reduction impact of specific measures for passenger long-range market [%].\n    \"\"\"\n    short_range_transition_year = (\n        rpk_short_range_measures_start_year + rpk_short_range_measures_duration / 2\n    )\n    medium_range_transition_year = (\n        rpk_medium_range_measures_start_year + rpk_medium_range_measures_duration / 2\n    )\n    long_range_transition_year = (\n        rpk_long_range_measures_start_year + rpk_long_range_measures_duration / 2\n    )\n    rpk_short_range_measures_limit = 0.02 * rpk_short_range_measures_final_impact\n    rpk_medium_range_measures_limit = 0.02 * rpk_medium_range_measures_final_impact\n    rpk_long_range_measures_limit = 0.02 * rpk_long_range_measures_final_impact\n    rpk_short_range_measures_parameter = np.log(100 / 2 - 1) / (\n        rpk_short_range_measures_duration / 2\n    )\n    rpk_medium_range_measures_parameter = np.log(100 / 2 - 1) / (\n        rpk_medium_range_measures_duration / 2\n    )\n    rpk_long_range_measures_parameter = np.log(100 / 2 - 1) / (\n        rpk_long_range_measures_duration / 2\n    )\n\n    for k in range(self.historic_start_year, self.prospection_start_year):\n        self.df.loc[k, \"rpk_short_range_measures_impact\"] = 1\n        self.df.loc[k, \"rpk_medium_range_measures_impact\"] = 1\n        self.df.loc[k, \"rpk_long_range_measures_impact\"] = 1\n\n    for k in range(self.prospection_start_year - 1, self.end_year + 1):\n        if (\n            rpk_short_range_measures_final_impact\n            / (\n                1\n                + np.exp(\n                    -rpk_short_range_measures_parameter * (k - short_range_transition_year)\n                )\n            )\n            &lt; rpk_short_range_measures_limit\n        ):\n            self.df.loc[k, \"rpk_short_range_measures_impact\"] = 1\n        else:\n            self.df.loc[k, \"rpk_short_range_measures_impact\"] = (\n                1\n                - rpk_short_range_measures_final_impact\n                / 100\n                / (\n                    1\n                    + np.exp(\n                        -rpk_short_range_measures_parameter * (k - short_range_transition_year)\n                    )\n                )\n            )\n        if (\n            rpk_medium_range_measures_final_impact\n            / (\n                1\n                + np.exp(\n                    -rpk_medium_range_measures_parameter * (k - medium_range_transition_year)\n                )\n            )\n            &lt; rpk_medium_range_measures_limit\n        ):\n            self.df.loc[k, \"rpk_medium_range_measures_impact\"] = 1\n        else:\n            self.df.loc[k, \"rpk_medium_range_measures_impact\"] = (\n                1\n                - rpk_medium_range_measures_final_impact\n                / 100\n                / (\n                    1\n                    + np.exp(\n                        -rpk_medium_range_measures_parameter\n                        * (k - medium_range_transition_year)\n                    )\n                )\n            )\n        if (\n            rpk_long_range_measures_final_impact\n            / (\n                1\n                + np.exp(-rpk_long_range_measures_parameter * (k - long_range_transition_year))\n            )\n            &lt; rpk_long_range_measures_limit\n        ):\n            self.df.loc[k, \"rpk_long_range_measures_impact\"] = 1\n        else:\n            self.df.loc[k, \"rpk_long_range_measures_impact\"] = (\n                1\n                - rpk_long_range_measures_final_impact\n                / 100\n                / (\n                    1\n                    + np.exp(\n                        -rpk_long_range_measures_parameter * (k - long_range_transition_year)\n                    )\n                )\n            )\n\n    rpk_short_range_measures_impact = self.df[\"rpk_short_range_measures_impact\"]\n    rpk_medium_range_measures_impact = self.df[\"rpk_medium_range_measures_impact\"]\n    rpk_long_range_measures_impact = self.df[\"rpk_long_range_measures_impact\"]\n\n    return (\n        rpk_short_range_measures_impact,\n        rpk_medium_range_measures_impact,\n        rpk_long_range_measures_impact,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.rtk/","title":"<code>aeromaps.models.air_transport.air_traffic.rtk</code>","text":""},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.rtk/#aeromaps.models.air_transport.air_traffic.rtk--rtk","title":"rtk","text":"<p>Module to compute freight traffic.</p>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.rtk/#aeromaps.models.air_transport.air_traffic.rtk.RTK","title":"RTK","text":"<pre><code>RTK(name='rtk', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute freight traffic considering COVID-19 impact and exogenous growth rates.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('rtk' by default).</p> <code>'rtk'</code> Source code in <code>aeromaps/models/air_transport/air_traffic/rtk.py</code> <pre><code>def __init__(self, name=\"rtk\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.rtk/#aeromaps.models.air_transport.air_traffic.rtk.RTK.compute","title":"compute","text":"<pre><code>compute(rtk_init, covid_start_year, covid_rtk_drop_start_year, covid_end_year_freight, covid_end_year_reference_rtk_ratio, cagr_freight_reference_periods, cagr_freight_reference_periods_values)\n</code></pre> <p>RTK calculation.</p> <p>Parameters:</p> Name Type Description Default <code>rtk_init</code> <code>Series</code> <p>Historical number of Revenue Tonne Kilometer (RTK) over 2000-2019 [RTK].</p> required <code>covid_start_year</code> <code>Number</code> <p>Covid-19 start year [yr].</p> required <code>covid_rtk_drop_start_year</code> <code>float</code> <p>Drop in RTK due to Covid-19 for the start year [%].</p> required <code>covid_end_year_freight</code> <code>Number</code> <p>Covid-19 end year [yr].</p> required <code>covid_end_year_reference_rtk_ratio</code> <code>float</code> <p>Percentage of cargo traffic level reached in Covid-19 end year compared with the one in Covid-19 start year [%].</p> required <code>cagr_freight_reference_periods</code> <code>list</code> <p>Reference periods for the CAGR for freight market [yr].</p> required <code>cagr_freight_reference_periods_values</code> <code>list</code> <p>CAGR for freight market for the reference periods [%].</p> required <p>Returns:</p> Type Description <code>rtk</code> <p>Number of Revenue Tonne Kilometer (RTK) for freight air transport [RTK].</p> <code>annual_growth_rate_freight</code> <p>Annual growth rate for freight [%/year].</p> <code>cagr_rtk</code> <p>Air traffic CAGR for freight market [%].</p> <code>prospective_evolution_rtk</code> <p>Evolution in percentage of Revenue Tonne Kilometer (RTK) for freight market between prospection_start_year and end_year [%].</p> Source code in <code>aeromaps/models/air_transport/air_traffic/rtk.py</code> <pre><code>def compute(\n    self,\n    rtk_init: pd.Series,\n    covid_start_year: Number,\n    covid_rtk_drop_start_year: float,\n    covid_end_year_freight: Number,\n    covid_end_year_reference_rtk_ratio: float,\n    cagr_freight_reference_periods: list,\n    cagr_freight_reference_periods_values: list,\n) -&gt; Tuple[pd.Series, pd.Series, float, float]:\n    \"\"\"\n    RTK calculation.\n\n    Parameters\n    ----------\n    rtk_init\n        Historical number of Revenue Tonne Kilometer (RTK) over 2000-2019 [RTK].\n    covid_start_year\n        Covid-19 start year [yr].\n    covid_rtk_drop_start_year\n        Drop in RTK due to Covid-19 for the start year [%].\n    covid_end_year_freight\n        Covid-19 end year [yr].\n    covid_end_year_reference_rtk_ratio\n        Percentage of cargo traffic level reached in Covid-19 end year compared with the one in Covid-19 start year [%].\n    cagr_freight_reference_periods\n        Reference periods for the CAGR for freight market [yr].\n    cagr_freight_reference_periods_values\n        CAGR for freight market for the reference periods [%].\n\n    Returns\n    -------\n    rtk\n        Number of Revenue Tonne Kilometer (RTK) for freight air transport [RTK].\n    annual_growth_rate_freight\n        Annual growth rate for freight [%/year].\n    cagr_rtk\n        Air traffic CAGR for freight market [%].\n    prospective_evolution_rtk\n        Evolution in percentage of Revenue Tonne Kilometer (RTK) for freight market between prospection_start_year and end_year [%].\n    \"\"\"\n\n    # Initialization\n    self.df.loc[self.prospection_start_year - 1, \"rtk\"] = rtk_init.loc[\n        self.prospection_start_year - 1\n    ]\n\n    # Covid functions\n    reference_years = [covid_start_year, covid_end_year_freight]\n    reference_values_covid = [\n        1 - covid_rtk_drop_start_year / 100,\n        covid_end_year_reference_rtk_ratio / 100,\n    ]\n    covid_function = interp1d(reference_years, reference_values_covid, kind=\"linear\")\n\n    # CAGR function\n    annual_growth_rate_freight_prospective = aeromaps_leveling_function(\n        self,\n        cagr_freight_reference_periods,\n        cagr_freight_reference_periods_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"annual_growth_rate_freight\"] = annual_growth_rate_freight_prospective\n\n    # Main\n    for k in range(covid_start_year, covid_end_year_freight + 1):\n        self.df.loc[k, \"rtk\"] = self.df.loc[covid_start_year - 1, \"rtk\"] * covid_function(k)\n    for k in range(covid_end_year_freight + 1, self.end_year + 1):\n        self.df.loc[k, \"rtk\"] = self.df.loc[k - 1, \"rtk\"] * (\n            1 + self.df.loc[k, \"annual_growth_rate_freight\"] / 100\n        )\n\n    # Historic values\n    for k in range(self.historic_start_year, self.prospection_start_year):\n        self.df.loc[k, \"rtk\"] = rtk_init.loc[k]\n    for k in range(self.historic_start_year + 1, self.prospection_start_year):\n        self.df.loc[k, \"annual_growth_rate_freight\"] = (\n            self.df.loc[k, \"rtk\"] / self.df.loc[k - 1, \"rtk\"] - 1\n        ) * 100\n    rtk = self.df[\"rtk\"]\n    annual_growth_rate_freight = self.df[\"annual_growth_rate_freight\"]\n\n    # Compound Annual Growth Rate (CAGR)\n    cagr_rtk = 100 * (\n        (\n            self.df.loc[self.end_year, \"rtk\"]\n            / self.df.loc[self.prospection_start_year - 1, \"rtk\"]\n        )\n        ** (1 / (self.end_year - self.prospection_start_year))\n        - 1\n    )\n\n    # Prospective evolution of RTK (between prospection_start_year-1 and end_year)\n    prospective_evolution_rtk = 100 * (\n        self.df.loc[self.end_year, \"rtk\"] / self.df.loc[self.prospection_start_year - 1, \"rtk\"]\n        - 1\n    )\n\n    self.float_outputs[\"cagr_rtk\"] = cagr_rtk\n    self.float_outputs[\"prospective_evolution_rtk\"] = prospective_evolution_rtk\n\n    return (\n        rtk,\n        annual_growth_rate_freight,\n        cagr_rtk,\n        prospective_evolution_rtk,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.rtk/#aeromaps.models.air_transport.air_traffic.rtk.RTKReference","title":"RTKReference","text":"<pre><code>RTKReference(name='rtk_reference', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute reference Revenue Tonne Kilometers (RTK) with baseline air traffic growth.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('rtk_reference' by default).</p> <code>'rtk_reference'</code> Source code in <code>aeromaps/models/air_transport/air_traffic/rtk.py</code> <pre><code>def __init__(self, name=\"rtk_reference\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.rtk/#aeromaps.models.air_transport.air_traffic.rtk.RTKReference.compute","title":"compute","text":"<pre><code>compute(rtk, reference_cagr_freight_reference_periods, reference_cagr_freight_reference_periods_values, covid_start_year, covid_rtk_drop_start_year, covid_end_year_freight, covid_end_year_reference_rtk_ratio)\n</code></pre> <p>RTK reference calculation.</p> <p>Parameters:</p> Name Type Description Default <code>rtk</code> <code>Series</code> <p>Number of Revenue Tonne Kilometer (RTK) for freight air transport [RTK].</p> required <code>reference_cagr_freight_reference_periods</code> <code>list</code> <p>Reference periods for the reference CAGR for freight market [yr].</p> required <code>reference_cagr_freight_reference_periods_values</code> <code>list</code> <p>Reference CAGR for freight market for the reference periods [%].</p> required <code>covid_start_year</code> <code>Number</code> <p>Covid-19 start year [yr].</p> required <code>covid_rtk_drop_start_year</code> <code>float</code> <p>Drop in RTK due to Covid-19 for the start year [%].</p> required <code>covid_end_year_freight</code> <code>Number</code> <p>Covid-19 end year [yr].</p> required <code>covid_end_year_reference_rtk_ratio</code> <code>float</code> <p>Percentage of traffic level reached in Covid-19 end year compared with the one in Covid-19 start year [%].</p> required <p>Returns:</p> Type Description <code>rtk_reference</code> <p>Number of Revenue Tonne Kilometer (RTK) for freight air transport with a baseline air traffic growth [RTK].</p> <code>reference_annual_growth_rate_freight</code> <p>Reference annual growth rate for freight market [%/year].</p> Source code in <code>aeromaps/models/air_transport/air_traffic/rtk.py</code> <pre><code>def compute(\n    self,\n    rtk: pd.Series,\n    reference_cagr_freight_reference_periods: list,\n    reference_cagr_freight_reference_periods_values: list,\n    covid_start_year: Number,\n    covid_rtk_drop_start_year: float,\n    covid_end_year_freight: Number,\n    covid_end_year_reference_rtk_ratio: float,\n) -&gt; Tuple[pd.Series, pd.Series]:\n    \"\"\"\n    RTK reference calculation.\n\n    Parameters\n    ----------\n    rtk\n        Number of Revenue Tonne Kilometer (RTK) for freight air transport [RTK].\n    reference_cagr_freight_reference_periods\n        Reference periods for the reference CAGR for freight market [yr].\n    reference_cagr_freight_reference_periods_values\n        Reference CAGR for freight market for the reference periods [%].\n    covid_start_year\n        Covid-19 start year [yr].\n    covid_rtk_drop_start_year\n        Drop in RTK due to Covid-19 for the start year [%].\n    covid_end_year_freight\n        Covid-19 end year [yr].\n    covid_end_year_reference_rtk_ratio\n        Percentage of traffic level reached in Covid-19 end year compared with the one in Covid-19 start year [%].\n\n    Returns\n    -------\n    rtk_reference\n        Number of Revenue Tonne Kilometer (RTK) for freight air transport with a baseline air traffic growth [RTK].\n    reference_annual_growth_rate_freight\n        Reference annual growth rate for freight market [%/year].\n    \"\"\"\n\n    for k in range(self.historic_start_year, self.prospection_start_year):\n        self.df.loc[k, \"rtk_reference\"] = rtk.loc[k]\n\n    covid_start_year = int(covid_start_year)\n    covid_rtk_drop_start_year = int(covid_rtk_drop_start_year)\n    covid_end_year_freight = int(covid_end_year_freight)\n    covid_end_year_reference_rtk_ratio = int(covid_end_year_reference_rtk_ratio)\n\n    self.df.loc[covid_start_year - 1, \"rtk_reference\"] = rtk.loc[covid_start_year - 1]\n\n    # Covid functions\n    reference_years = [covid_start_year, covid_end_year_freight]\n    reference_values_covid = [\n        1 - covid_rtk_drop_start_year / 100,\n        covid_end_year_reference_rtk_ratio / 100,\n    ]\n    covid_function = interp1d(reference_years, reference_values_covid, kind=\"linear\")\n\n    # CAGR function\n    reference_annual_growth_rate_freight = aeromaps_leveling_function(\n        self,\n        reference_cagr_freight_reference_periods,\n        reference_cagr_freight_reference_periods_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"reference_annual_growth_rate_freight\"] = (\n        reference_annual_growth_rate_freight\n    )\n\n    # Main\n    for k in range(covid_start_year, covid_end_year_freight + 1):\n        self.df.loc[k, \"rtk_reference\"] = self.df.loc[\n            covid_start_year - 1, \"rtk_reference\"\n        ] * covid_function(k)\n    for k in range(covid_end_year_freight + 1, self.end_year + 1):\n        self.df.loc[k, \"rtk_reference\"] = self.df.loc[k - 1, \"rtk_reference\"] * (\n            1 + self.df.loc[k, \"reference_annual_growth_rate_freight\"] / 100\n        )\n\n    rtk_reference = self.df[\"rtk_reference\"]\n\n    return (rtk_reference, reference_annual_growth_rate_freight)\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.short_range_distribution/","title":"<code>aeromaps.models.air_transport.air_traffic.short_range_distribution</code>","text":""},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.short_range_distribution/#aeromaps.models.air_transport.air_traffic.short_range_distribution--short_range_distribution","title":"short_range_distribution","text":"<p>Module to compute short-range aircraft shares when using simple efficiency models.</p> Warning <p>Apparently, this module is not used in the current version of AeroMAPS.</p>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.short_range_distribution/#aeromaps.models.air_transport.air_traffic.short_range_distribution.ShortRangeDistribution","title":"ShortRangeDistribution","text":"<pre><code>ShortRangeDistribution(name='short_range_distribution', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute the market shares of short-range aircraft architectures when using simple aircraft efficiency model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('short_range_distribution' by default).</p> <code>'short_range_distribution'</code> Source code in <code>aeromaps/models/air_transport/air_traffic/short_range_distribution.py</code> <pre><code>def __init__(self, name=\"short_range_distribution\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.short_range_distribution/#aeromaps.models.air_transport.air_traffic.short_range_distribution.ShortRangeDistribution.compute","title":"compute","text":"<pre><code>compute(short_range_basicturbofan_share_2019, short_range_basicturbofan_share_2030, short_range_basicturbofan_share_2040, short_range_basicturbofan_share_2050, short_range_regionalturboprop_share_2019, short_range_regionalturboprop_share_2030, short_range_regionalturboprop_share_2040, short_range_regionalturboprop_share_2050)\n</code></pre> <p>Short range distribution calculation.</p> <p>Parameters:</p> Name Type Description Default <code>short_range_basicturbofan_share_2019</code> <code>float</code> <p>Share of narrow-body turbofan architectures in passenger short-range market in 2019 [%].</p> required <code>short_range_basicturbofan_share_2030</code> <code>float</code> <p>Share of narrow-body turbofan architectures in passenger short-range market in 2030 [%].</p> required <code>short_range_basicturbofan_share_2040</code> <code>float</code> <p>Share of narrow-body turbofan architectures in passenger short-range market in 2040 [%].</p> required <code>short_range_basicturbofan_share_2050</code> <code>float</code> <p>Share of narrow-body turbofan architectures in passenger short-range market in 2050 [%].</p> required <code>short_range_regionalturboprop_share_2019</code> <code>float</code> <p>Share of regional turboprop architectures in passenger short-range market in 2019 [%].</p> required <code>short_range_regionalturboprop_share_2030</code> <code>float</code> <p>Share of regional turboprop architectures in passenger short-range market in 2030 [%].</p> required <code>short_range_regionalturboprop_share_2040</code> <code>float</code> <p>Share of regional turboprop architectures in passenger short-range market in 2040 [%].</p> required <code>short_range_regionalturboprop_share_2050</code> <code>float</code> <p>Share of regional turboprop architectures in passenger short-range market in 2050 [%].</p> required <p>Returns:</p> Type Description <code>short_range_basicturbofan_share</code> <p>Share of narrow-body turbofan architectures in passenger short-range market [%].</p> <code>short_range_regionalturboprop_share</code> <p>Share of regional turboprop architectures in passenger short-range market [%].</p> <code>short_range_regionalturbofan_share</code> <p>Share of regional turbofan architectures in passenger short-range market [%].</p> Source code in <code>aeromaps/models/air_transport/air_traffic/short_range_distribution.py</code> <pre><code>def compute(\n    self,\n    short_range_basicturbofan_share_2019: float,\n    short_range_basicturbofan_share_2030: float,\n    short_range_basicturbofan_share_2040: float,\n    short_range_basicturbofan_share_2050: float,\n    short_range_regionalturboprop_share_2019: float,\n    short_range_regionalturboprop_share_2030: float,\n    short_range_regionalturboprop_share_2040: float,\n    short_range_regionalturboprop_share_2050: float,\n) -&gt; Tuple[\n    pd.Series,\n    pd.Series,\n    pd.Series,\n]:\n    \"\"\"\n    Short range distribution calculation.\n\n    Parameters\n    ----------\n    short_range_basicturbofan_share_2019\n        Share of narrow-body turbofan architectures in passenger short-range market in 2019 [%].\n    short_range_basicturbofan_share_2030\n        Share of narrow-body turbofan architectures in passenger short-range market in 2030 [%].\n    short_range_basicturbofan_share_2040\n        Share of narrow-body turbofan architectures in passenger short-range market in 2040 [%].\n    short_range_basicturbofan_share_2050\n        Share of narrow-body turbofan architectures in passenger short-range market in 2050 [%].\n    short_range_regionalturboprop_share_2019\n        Share of regional turboprop architectures in passenger short-range market in 2019 [%].\n    short_range_regionalturboprop_share_2030\n        Share of regional turboprop architectures in passenger short-range market in 2030 [%].\n    short_range_regionalturboprop_share_2040\n        Share of regional turboprop architectures in passenger short-range market in 2040 [%].\n    short_range_regionalturboprop_share_2050\n        Share of regional turboprop architectures in passenger short-range market in 2050 [%].\n\n    Returns\n    -------\n    short_range_basicturbofan_share\n        Share of narrow-body turbofan architectures in passenger short-range market [%].\n    short_range_regionalturboprop_share\n        Share of regional turboprop architectures in passenger short-range market [%].\n    short_range_regionalturbofan_share\n        Share of regional turbofan architectures in passenger short-range market [%].\n    \"\"\"\n\n    reference_years = [2019, 2030, 2040, self.end_year]\n\n    # Reference\n    # \"short_range_basicturbofan_share_2019\": 88.4,\n    # \"short_range_regionalturboprop_share_2019\": 2.5,\n    # \"short_range_regionalturbofan_share_2019\": 9.1,\n\n    # Basic Turbofan\n    reference_values_basicturbofan = [\n        short_range_basicturbofan_share_2019,\n        short_range_basicturbofan_share_2030,\n        short_range_basicturbofan_share_2040,\n        short_range_basicturbofan_share_2050,\n    ]\n    short_range_basicturbofan_share_function = interp1d(\n        reference_years, reference_values_basicturbofan, kind=\"linear\"\n    )\n    for k in range(self.prospection_start_year - 1, self.end_year + 1):\n        self.df.loc[k, \"short_range_basicturbofan_share\"] = (\n            short_range_basicturbofan_share_function(k)\n        )\n\n    # Regional Turboprop\n    reference_values_regionalturboprop = [\n        short_range_regionalturboprop_share_2019,\n        short_range_regionalturboprop_share_2030,\n        short_range_regionalturboprop_share_2040,\n        short_range_regionalturboprop_share_2050,\n    ]\n    short_range_regionalturboprop_share_function = interp1d(\n        reference_years, reference_values_regionalturboprop, kind=\"linear\"\n    )\n    for k in range(self.prospection_start_year - 1, self.end_year + 1):\n        self.df.loc[k, \"short_range_regionalturboprop_share\"] = (\n            short_range_regionalturboprop_share_function(k)\n        )\n\n    short_range_basicturbofan_share = self.df[\"short_range_basicturbofan_share\"]\n    short_range_regionalturboprop_share = self.df[\"short_range_regionalturboprop_share\"]\n\n    # Regional Turbofan\n    short_range_regionalturbofan_share = (\n        100 - short_range_basicturbofan_share - short_range_regionalturboprop_share\n    )\n    self.df.loc[:, \"short_range_regionalturbofan_share\"] = short_range_regionalturbofan_share\n\n    return (\n        short_range_basicturbofan_share,\n        short_range_regionalturboprop_share,\n        short_range_regionalturbofan_share,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.short_range_distribution/#aeromaps.models.air_transport.air_traffic.short_range_distribution.RPKShortRange","title":"RPKShortRange","text":"<pre><code>RPKShortRange(name='rpk_short_range', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute RPK distribution for short-range market by aircraft architecture.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('rpk_short_range' by default).</p> <code>'rpk_short_range'</code> Source code in <code>aeromaps/models/air_transport/air_traffic/short_range_distribution.py</code> <pre><code>def __init__(self, name=\"rpk_short_range\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.short_range_distribution/#aeromaps.models.air_transport.air_traffic.short_range_distribution.RPKShortRange.compute","title":"compute","text":"<pre><code>compute(rpk_short_range, short_range_basicturbofan_share, short_range_regionalturboprop_share, short_range_regionalturbofan_share)\n</code></pre> <p>RPK short range calculation.</p> <p>Parameters:</p> Name Type Description Default <code>rpk_short_range</code> <code>Series</code> <p>Number of Revenue Passenger Kilometer (RPK) for passenger short-range market [RPK].</p> required <code>short_range_basicturbofan_share</code> <code>Series</code> <p>Share of narrow-body turbofan architectures in passenger short-range market [%].</p> required <code>short_range_regionalturboprop_share</code> <code>Series</code> <p>Share of regional turboprop architectures in passenger short-range market [%].</p> required <code>short_range_regionalturbofan_share</code> <code>Series</code> <p>Share of regional turbofan architectures in passenger short-range market [%].</p> required <p>Returns:</p> Type Description <code>rpk_short_range_basicturbofan</code> <p>RPK for short-range market from basic turbofan aircraft [RPK].</p> <code>rpk_short_range_regionalturboprop</code> <p>RPK for short-range market from regional turboprop aircraft [RPK].</p> <code>rpk_short_range_regionalturbofan</code> <p>RPK for short-range market from regional turbofan aircraft [RPK].</p> <code>cagr_rpk_short_range_basicturbofan</code> <p>Air traffic CAGR over prospective_years for short-range basic turbofan market [%].</p> <code>cagr_rpk_short_range_regionalturboprop</code> <p>Air traffic CAGR over prospective_years for short-range regional turboprop market [%].</p> <code>cagr_rpk_short_range_regionalturbofan</code> <p>Air traffic CAGR over prospective_years for short-range regional turbofan market [%].</p> <code>prospective_evolution_rpk_short_range_basicturbofan</code> <p>Evolution in percentage of RPK for short-range basic turbofan market between prospection_start_year and end_year [%].</p> <code>prospective_evolution_rpk_short_range_regionalturboprop</code> <p>Evolution in percentage of RPK for short-range regional turboprop market between prospection_start_year and end_year [%].</p> <code>prospective_evolution_rpk_short_range_regionalturbofan</code> <p>Evolution in percentage of RPK for short-range regional turbofan market between prospection_start_year and end_year [%].</p> Source code in <code>aeromaps/models/air_transport/air_traffic/short_range_distribution.py</code> <pre><code>def compute(\n    self,\n    rpk_short_range: pd.Series,\n    short_range_basicturbofan_share: pd.Series,\n    short_range_regionalturboprop_share: pd.Series,\n    short_range_regionalturbofan_share: pd.Series,\n) -&gt; Tuple[\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    float,\n    float,\n    float,\n    float,\n    float,\n    float,\n]:\n    \"\"\"\n    RPK short range calculation.\n\n    Parameters\n    ----------\n    rpk_short_range\n        Number of Revenue Passenger Kilometer (RPK) for passenger short-range market [RPK].\n    short_range_basicturbofan_share\n        Share of narrow-body turbofan architectures in passenger short-range market [%].\n    short_range_regionalturboprop_share\n        Share of regional turboprop architectures in passenger short-range market [%].\n    short_range_regionalturbofan_share\n        Share of regional turbofan architectures in passenger short-range market [%].\n\n    Returns\n    -------\n    rpk_short_range_basicturbofan\n        RPK for short-range market from basic turbofan aircraft [RPK].\n    rpk_short_range_regionalturboprop\n        RPK for short-range market from regional turboprop aircraft [RPK].\n    rpk_short_range_regionalturbofan\n        RPK for short-range market from regional turbofan aircraft [RPK].\n    cagr_rpk_short_range_basicturbofan\n        Air traffic CAGR over prospective_years for short-range basic turbofan market [%].\n    cagr_rpk_short_range_regionalturboprop\n        Air traffic CAGR over prospective_years for short-range regional turboprop market [%].\n    cagr_rpk_short_range_regionalturbofan\n        Air traffic CAGR over prospective_years for short-range regional turbofan market [%].\n    prospective_evolution_rpk_short_range_basicturbofan\n        Evolution in percentage of RPK for short-range basic turbofan market between prospection_start_year and end_year [%].\n    prospective_evolution_rpk_short_range_regionalturboprop\n        Evolution in percentage of RPK for short-range regional turboprop market between prospection_start_year and end_year [%].\n    prospective_evolution_rpk_short_range_regionalturbofan\n        Evolution in percentage of RPK for short-range regional turbofan market between prospection_start_year and end_year [%].\n    \"\"\"\n\n    rpk_short_range_basicturbofan = rpk_short_range * short_range_basicturbofan_share / 100\n    rpk_short_range_regionalturboprop = (\n        rpk_short_range * short_range_regionalturboprop_share / 100\n    )\n    rpk_short_range_regionalturbofan = (\n        rpk_short_range * short_range_regionalturbofan_share / 100\n    )\n\n    self.df.loc[:, \"rpk_short_range_basicturbofan\"] = rpk_short_range_basicturbofan\n    self.df.loc[:, \"rpk_short_range_regionalturboprop\"] = rpk_short_range_regionalturboprop\n    self.df.loc[:, \"rpk_short_range_regionalturbofan\"] = rpk_short_range_regionalturbofan\n\n    # Compound Annual Growth Rate (CAGR)\n    cagr_rpk_short_range_basicturbofan = 100 * (\n        (\n            self.df.loc[self.end_year, \"rpk_short_range_basicturbofan\"]\n            / self.df.loc[self.prospection_start_year - 1, \"rpk_short_range_basicturbofan\"]\n        )\n        ** (1 / (self.end_year - self.prospection_start_year))\n        - 1\n    )\n    cagr_rpk_short_range_regionalturboprop = 100 * (\n        (\n            self.df.loc[self.end_year, \"rpk_short_range_regionalturboprop\"]\n            / self.df.loc[self.prospection_start_year - 1, \"rpk_short_range_regionalturboprop\"]\n        )\n        ** (1 / (self.end_year - self.prospection_start_year))\n        - 1\n    )\n    cagr_rpk_short_range_regionalturbofan = 100 * (\n        (\n            self.df.loc[self.end_year, \"rpk_short_range_regionalturbofan\"]\n            / self.df.loc[self.prospection_start_year - 1, \"rpk_short_range_regionalturbofan\"]\n        )\n        ** (1 / (self.end_year - self.prospection_start_year))\n        - 1\n    )\n\n    # Prospective evolution of RPK (between prospection_start_year-1 and end_year)\n    prospective_evolution_rpk_short_range_basicturbofan = 100 * (\n        self.df.loc[self.end_year, \"rpk_short_range_basicturbofan\"]\n        / self.df.loc[self.prospection_start_year - 1, \"rpk_short_range_basicturbofan\"]\n        - 1\n    )\n    prospective_evolution_rpk_short_range_regionalturboprop = 100 * (\n        self.df.loc[self.end_year, \"rpk_short_range_regionalturboprop\"]\n        / self.df.loc[self.prospection_start_year - 1, \"rpk_short_range_regionalturboprop\"]\n        - 1\n    )\n    prospective_evolution_rpk_short_range_regionalturbofan = 100 * (\n        self.df.loc[self.end_year, \"rpk_short_range_regionalturbofan\"]\n        / self.df.loc[self.prospection_start_year - 1, \"rpk_short_range_regionalturbofan\"]\n        - 1\n    )\n\n    self.float_outputs[\"cagr_rpk_short_range_basicturbofan\"] = (\n        cagr_rpk_short_range_basicturbofan\n    )\n    self.float_outputs[\"cagr_rpk_short_range_regionalturboprop\"] = (\n        cagr_rpk_short_range_regionalturboprop\n    )\n    self.float_outputs[\"cagr_rpk_short_range_regionalturbofan\"] = (\n        cagr_rpk_short_range_regionalturbofan\n    )\n    self.float_outputs[\"prospective_evolution_rpk_short_range_basicturbofan\"] = (\n        prospective_evolution_rpk_short_range_basicturbofan\n    )\n    self.float_outputs[\"prospective_evolution_rpk_short_range_regionalturboprop\"] = (\n        prospective_evolution_rpk_short_range_regionalturboprop\n    )\n    self.float_outputs[\"prospective_evolution_rpk_short_range_regionalturbofan\"] = (\n        prospective_evolution_rpk_short_range_regionalturbofan\n    )\n\n    return (\n        rpk_short_range_basicturbofan,\n        rpk_short_range_regionalturboprop,\n        rpk_short_range_regionalturbofan,\n        cagr_rpk_short_range_basicturbofan,\n        cagr_rpk_short_range_regionalturboprop,\n        cagr_rpk_short_range_regionalturbofan,\n        prospective_evolution_rpk_short_range_basicturbofan,\n        prospective_evolution_rpk_short_range_regionalturboprop,\n        prospective_evolution_rpk_short_range_regionalturbofan,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.total_aircraft_distance/","title":"<code>aeromaps.models.air_transport.air_traffic.total_aircraft_distance</code>","text":""},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.total_aircraft_distance/#aeromaps.models.air_transport.air_traffic.total_aircraft_distance--total_aircraft_distance","title":"total_aircraft_distance","text":"<p>Module for computing total aircraft distance flown.</p>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.total_aircraft_distance/#aeromaps.models.air_transport.air_traffic.total_aircraft_distance.TotalAircraftDistance","title":"TotalAircraftDistance","text":"<pre><code>TotalAircraftDistance(name='total_aircraft_distance', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute total aircraft distance flown for all commercial air transport.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('total_aircraft_distance' by default).</p> <code>'total_aircraft_distance'</code> Source code in <code>aeromaps/models/air_transport/air_traffic/total_aircraft_distance.py</code> <pre><code>def __init__(self, name=\"total_aircraft_distance\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n    self.climate_historical_data = None\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.air_traffic.total_aircraft_distance/#aeromaps.models.air_transport.air_traffic.total_aircraft_distance.TotalAircraftDistance.compute","title":"compute","text":"<pre><code>compute(rtk, ask, ask_dropin_fuel, ask_hydrogen, ask_electric, total_aircraft_distance_init)\n</code></pre> <p>Total aircraft distance calculation.</p> <p>Parameters:</p> Name Type Description Default <code>rtk</code> <code>Series</code> <p>Number of Revenue Tonne Kilometer (RTK) for freight air transport [RTK].</p> required <code>ask</code> <code>Series</code> <p>Number of (ASK) for all commercial air transport [ASK].</p> required <code>ask_dropin_fuel</code> <code>Series</code> <p>Number of (ASK) for drop-in fuel aircraft [ASK].</p> required <code>ask_hydrogen</code> <code>Series</code> <p>Number of (ASK) for hydrogen aircraft [ASK].</p> required <code>ask_electric</code> <code>Series</code> <p>Number of (ASK) for electric aircraft [ASK].</p> required <code>total_aircraft_distance_init</code> <code>Series</code> <p>Historical total distance travelled by aircraft over 2000-2019 [km].</p> required <p>Returns:</p> Type Description <code>total_aircraft_distance</code> <p>Total distance flown by all aircraft [km].</p> <code>total_aircraft_distance_dropin_fuel</code> <p>Total aircraft distance flown by drop-in fuel aircraft [km].</p> <code>total_aircraft_distance_hydrogen</code> <p>Total aircraft distance flown by hydrogen aircraft [km].</p> <code>total_aircraft_distance_electric</code> <p>Total aircraft distance flown by electric aircraft [km].</p> Source code in <code>aeromaps/models/air_transport/air_traffic/total_aircraft_distance.py</code> <pre><code>def compute(\n    self,\n    rtk: pd.Series,\n    ask: pd.Series,\n    ask_dropin_fuel: pd.Series,\n    ask_hydrogen: pd.Series,\n    ask_electric: pd.Series,\n    total_aircraft_distance_init: pd.Series,\n) -&gt; Tuple[pd.Series, pd.Series, pd.Series, pd.Series]:\n    \"\"\"\n    Total aircraft distance calculation.\n\n    Parameters\n    ----------\n    rtk\n        Number of Revenue Tonne Kilometer (RTK) for freight air transport [RTK].\n    ask\n        Number of (ASK) for all commercial air transport [ASK].\n    ask_dropin_fuel\n        Number of (ASK) for drop-in fuel aircraft [ASK].\n    ask_hydrogen\n        Number of (ASK) for hydrogen aircraft [ASK].\n    ask_electric\n        Number of (ASK) for electric aircraft [ASK].\n    total_aircraft_distance_init\n        Historical total distance travelled by aircraft over 2000-2019 [km].\n\n    Returns\n    -------\n    total_aircraft_distance\n        Total distance flown by all aircraft [km].\n    total_aircraft_distance_dropin_fuel\n        Total aircraft distance flown by drop-in fuel aircraft [km].\n    total_aircraft_distance_hydrogen\n        Total aircraft distance flown by hydrogen aircraft [km].\n    total_aircraft_distance_electric\n        Total aircraft distance flown by electric aircraft [km].\n    \"\"\"\n\n    historical_distance_for_temperature = self.climate_historical_data[:, 6]\n\n    for k in range(self.climate_historic_start_year, self.historic_start_year):\n        self.df_climate.loc[k, \"total_aircraft_distance\"] = historical_distance_for_temperature[\n            k - self.climate_historic_start_year\n        ]\n\n    for k in range(self.historic_start_year, self.prospection_start_year):\n        self.df_climate.loc[k, \"total_aircraft_distance\"] = total_aircraft_distance_init.loc[k]\n\n    # Assumption: 1 RTK = 10 ASK\n    for k in range(self.prospection_start_year, self.end_year + 1):\n        self.df_climate.loc[k, \"total_aircraft_distance\"] = (\n            (ask.loc[k] + 10 * rtk.loc[k])\n            / (\n                ask.loc[self.prospection_start_year - 1]\n                + 10 * rtk.loc[self.prospection_start_year - 1]\n            )\n            * self.df_climate.loc[self.prospection_start_year - 1, \"total_aircraft_distance\"]\n        )\n\n    total_aircraft_distance = self.df_climate[\"total_aircraft_distance\"]\n\n    # Assumption: distribution proportional to ASK\n    total_aircraft_distance_dropin_fuel = total_aircraft_distance * ask_dropin_fuel / ask\n    total_aircraft_distance_hydrogen = total_aircraft_distance * ask_hydrogen / ask\n    total_aircraft_distance_electric = total_aircraft_distance * ask_electric / ask\n    self.df.loc[:, \"total_aircraft_distance_dropin_fuel\"] = total_aircraft_distance_dropin_fuel\n    self.df.loc[:, \"total_aircraft_distance_hydrogen\"] = total_aircraft_distance_hydrogen\n    self.df.loc[:, \"total_aircraft_distance_electric\"] = total_aircraft_distance_electric\n\n    return (\n        total_aircraft_distance,\n        total_aircraft_distance_dropin_fuel,\n        total_aircraft_distance_hydrogen,\n        total_aircraft_distance_electric,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.aircraft_efficiency/","title":"<code>aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.aircraft_efficiency</code>","text":""},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.aircraft_efficiency/#aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.aircraft_efficiency--aicraft_efficiency","title":"aicraft_efficiency","text":"<p>This module contains models to compute aircraft efficiency, either using simple models or outputs from generic fleet model.</p>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.aircraft_efficiency/#aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.aircraft_efficiency.PassengerAircraftEfficiencySimpleShares","title":"PassengerAircraftEfficiencySimpleShares","text":"<pre><code>PassengerAircraftEfficiencySimpleShares(name='passenger_aircraft_efficiency_simple_shares', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute energy consumption per ASK (without operations) using simple annual improvement rates.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('passenger_aircraft_efficiency_simple_shares' by default).</p> <code>'passenger_aircraft_efficiency_simple_shares'</code> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/fleet/aircraft_efficiency.py</code> <pre><code>def __init__(self, name=\"passenger_aircraft_efficiency_simple_shares\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.aircraft_efficiency/#aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.aircraft_efficiency.PassengerAircraftEfficiencySimpleShares.compute","title":"compute","text":"<pre><code>compute(energy_consumption_init, ask_init, short_range_energy_share_2019, medium_range_energy_share_2019, long_range_energy_share_2019, short_range_rpk_share_2019, medium_range_rpk_share_2019, long_range_rpk_share_2019, energy_per_ask_short_range_dropin_fuel_gain_reference_years, energy_per_ask_short_range_dropin_fuel_gain_reference_years_values, energy_per_ask_medium_range_dropin_fuel_gain_reference_years, energy_per_ask_medium_range_dropin_fuel_gain_reference_years_values, energy_per_ask_long_range_dropin_fuel_gain_reference_years, energy_per_ask_long_range_dropin_fuel_gain_reference_years_values, relative_energy_per_ask_hydrogen_wrt_dropin_short_range_reference_years, relative_energy_per_ask_hydrogen_wrt_dropin_short_range_reference_years_values, relative_energy_per_ask_hydrogen_wrt_dropin_medium_range_reference_years, relative_energy_per_ask_hydrogen_wrt_dropin_medium_range_reference_years_values, relative_energy_per_ask_hydrogen_wrt_dropin_long_range_reference_years, relative_energy_per_ask_hydrogen_wrt_dropin_long_range_reference_years_values, relative_energy_per_ask_electric_wrt_dropin_short_range_reference_years, relative_energy_per_ask_electric_wrt_dropin_short_range_reference_years_values, relative_energy_per_ask_electric_wrt_dropin_medium_range_reference_years, relative_energy_per_ask_electric_wrt_dropin_medium_range_reference_years_values, relative_energy_per_ask_electric_wrt_dropin_long_range_reference_years, relative_energy_per_ask_electric_wrt_dropin_long_range_reference_years_values, hydrogen_final_market_share_short_range, hydrogen_introduction_year_short_range, hydrogen_final_market_share_medium_range, hydrogen_introduction_year_medium_range, hydrogen_final_market_share_long_range, hydrogen_introduction_year_long_range, electric_final_market_share_short_range, electric_introduction_year_short_range, electric_final_market_share_medium_range, electric_introduction_year_medium_range, electric_final_market_share_long_range, electric_introduction_year_long_range, fleet_renewal_duration, covid_energy_intensity_per_ask_increase_2020)\n</code></pre> <p>Compute energy consumption per ASK (without operations) using simple annual improvement rates.</p> <p>Parameters:</p> Name Type Description Default <code>energy_consumption_init</code> <code>Series</code> <p>Historical energy consumption of aviation over 2000-2019 [MJ].</p> required <code>ask_init</code> <code>Series</code> <p>Historical number of Available Seat Kilometer (ASK) over 2000-2019 [ASK].</p> required <code>short_range_energy_share_2019</code> <code>float</code> <p>Share of aviation energy consumed by passenger short-range market in 2019 [%].</p> required <code>medium_range_energy_share_2019</code> <code>float</code> <p>Share of aviation energy consumed by passenger medium-range market in 2019 [%].</p> required <code>long_range_energy_share_2019</code> <code>float</code> <p>Share of aviation energy consumed by passenger long-range market in 2019 [%].</p> required <code>short_range_rpk_share_2019</code> <code>float</code> <p>Share of RPK from short-range market in 2019 [%].</p> required <code>medium_range_rpk_share_2019</code> <code>float</code> <p>Share of RPK from medium-range market in 2019 [%].</p> required <code>long_range_rpk_share_2019</code> <code>float</code> <p>Share of RPK from long-range market in 2019 [%].</p> required <code>energy_per_ask_short_range_dropin_fuel_gain_reference_years</code> <code>list</code> <p>Reference years for the mean annual efficiency gains in terms of energy consumption per ASK for short-range drop-in fuel aircraft [yr].</p> required <code>energy_per_ask_short_range_dropin_fuel_gain_reference_years_values</code> <code>list</code> <p>Mean annual efficiency gains in terms of energy consumption per ASK for short-range drop-in fuel aircraft for the reference years [%].</p> required <code>energy_per_ask_medium_range_dropin_fuel_gain_reference_years</code> <code>list</code> <p>Reference years for the mean annual efficiency gains in terms of energy consumption per ASK for medium-range drop-in fuel aircraft [yr].</p> required <code>energy_per_ask_medium_range_dropin_fuel_gain_reference_years_values</code> <code>list</code> <p>Mean annual efficiency gains in terms of energy consumption per ASK for medium-range drop-in fuel aircraft for the reference years [%].</p> required <code>energy_per_ask_long_range_dropin_fuel_gain_reference_years</code> <code>list</code> <p>Reference years for the mean annual efficiency gains in terms of energy consumption per ASK for long-range drop-in fuel aircraft [yr].</p> required <code>energy_per_ask_long_range_dropin_fuel_gain_reference_years_values</code> <code>list</code> <p>Mean annual efficiency gains in terms of energy consumption per ASK for long-range drop-in fuel aircraft for the reference years [%].</p> required <code>relative_energy_per_ask_hydrogen_wrt_dropin_short_range_reference_years</code> <code>list</code> <p>Reference years for the relative energy consumption per ASK of hydrogen aircraft with respect to drop-in aircraft for passenger short-range market [yr].</p> required <code>relative_energy_per_ask_hydrogen_wrt_dropin_short_range_reference_years_values</code> <code>list</code> <p>Relative energy consumption per ASK of hydrogen aircraft with respect to drop-in aircraft for passenger short-range market for the reference years [-].</p> required <code>relative_energy_per_ask_hydrogen_wrt_dropin_medium_range_reference_years</code> <code>list</code> <p>Reference years for the relative energy consumption per ASK of hydrogen aircraft with respect to drop-in aircraft for passenger medium-range market [yr].</p> required <code>relative_energy_per_ask_hydrogen_wrt_dropin_medium_range_reference_years_values</code> <code>list</code> <p>Relative energy consumption per ASK of hydrogen aircraft with respect to drop-in aircraft for passenger medium-range market for the reference years [-].</p> required <code>relative_energy_per_ask_hydrogen_wrt_dropin_long_range_reference_years</code> <code>list</code> <p>Reference years for the relative energy consumption per ASK of hydrogen aircraft with respect to drop-in aircraft for passenger long-range market [yr].</p> required <code>relative_energy_per_ask_hydrogen_wrt_dropin_long_range_reference_years_values</code> <code>list</code> <p>Relative energy consumption per ASK of hydrogen aircraft with respect to drop-in aircraft for passenger long-range market for the reference years [-].</p> required <code>relative_energy_per_ask_electric_wrt_dropin_short_range_reference_years</code> <code>list</code> <p>Reference years for the relative energy consumption per ASK of electric aircraft with respect to drop-in aircraft for passenger short-range market [yr].</p> required <code>relative_energy_per_ask_electric_wrt_dropin_short_range_reference_years_values</code> <code>list</code> <p>Relative energy consumption per ASK of electric aircraft with respect to drop-in aircraft for passenger short-range market for the reference years [-].</p> required <code>relative_energy_per_ask_electric_wrt_dropin_medium_range_reference_years</code> <code>list</code> <p>Reference years for the relative energy consumption per ASK of electric aircraft with respect to drop-in aircraft for passenger medium-range market [yr].</p> required <code>relative_energy_per_ask_electric_wrt_dropin_medium_range_reference_years_values</code> <code>list</code> <p>Relative energy consumption per ASK of electric aircraft with respect to drop-in aircraft for passenger medium-range market for the reference years [-].</p> required <code>relative_energy_per_ask_electric_wrt_dropin_long_range_reference_years</code> <code>list</code> <p>Reference years for the relative energy consumption per ASK of electric aircraft with respect to drop-in aircraft for passenger long-range market [yr].</p> required <code>relative_energy_per_ask_electric_wrt_dropin_long_range_reference_years_values</code> <code>list</code> <p>Relative energy consumption per ASK of electric aircraft with respect to drop-in aircraft for passenger long-range market for the reference years [-].</p> required <code>hydrogen_final_market_share_short_range</code> <code>float</code> <p>Share of hydrogen aircraft in the passenger short-range market [%].</p> required <code>hydrogen_introduction_year_short_range</code> <code>Number</code> <p>Entry-Into-Service year of hydrogen aircraft for short-range market [yr].</p> required <code>hydrogen_final_market_share_medium_range</code> <code>float</code> <p>Share of hydrogen aircraft in the passenger medium-range market [%].</p> required <code>hydrogen_introduction_year_medium_range</code> <code>Number</code> <p>Entry-Into-Service year of hydrogen aircraft for medium-range market [yr].</p> required <code>hydrogen_final_market_share_long_range</code> <code>float</code> <p>Share of hydrogen aircraft in the passenger long-range market [%].</p> required <code>hydrogen_introduction_year_long_range</code> <code>Number</code> <p>Entry-Into-Service year of hydrogen aircraft for long-range market [yr].</p> required <code>electric_final_market_share_short_range</code> <code>float</code> <p>Share of electric aircraft in the passenger short-range market [%].</p> required <code>electric_introduction_year_short_range</code> <code>Number</code> <p>Entry-Into-Service year of electric aircraft for short-range market [yr].</p> required <code>electric_final_market_share_medium_range</code> <code>float</code> <p>Share of electric aircraft in the passenger medium-range market [%].</p> required <code>electric_introduction_year_medium_range</code> <code>Number</code> <p>Entry-Into-Service year of electric aircraft for medium-range market [yr].</p> required <code>electric_final_market_share_long_range</code> <code>float</code> <p>Share of electric aircraft in the passenger long-range market [%].</p> required <code>electric_introduction_year_long_range</code> <code>Number</code> <p>Entry-Into-Service year of electric aircraft for long-range market [yr].</p> required <code>fleet_renewal_duration</code> <code>float</code> <p>Duration for renewing 98% of the aircraft fleet [yr].</p> required <code>covid_energy_intensity_per_ask_increase_2020</code> <code>float</code> <p>Increase in energy intensity per ASK due to Covid-19 for the start year [%].</p> required <p>Returns:</p> Type Description <code>energy_per_ask_without_operations_short_range_dropin_fuel</code> <p>Energy consumption per ASK for passenger short-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].</p> <code>energy_per_ask_without_operations_medium_range_dropin_fuel</code> <p>Energy consumption per ASK for passenger medium-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].</p> <code>energy_per_ask_without_operations_long_range_dropin_fuel</code> <p>Energy consumption per ASK for passenger long-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].</p> <code>energy_per_ask_without_operations_short_range_hydrogen</code> <p>Energy consumption per ASK for passenger short-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].</p> <code>energy_per_ask_without_operations_medium_range_hydrogen</code> <p>Energy consumption per ASK for passenger medium-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].</p> <code>energy_per_ask_without_operations_long_range_hydrogen</code> <p>Energy consumption per ASK for passenger long-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].</p> <code>energy_per_ask_without_operations_short_range_electric</code> <p>Energy consumption per ASK for passenger short-range market aircraft using electric propulsion without considering operation improvements [MJ/ASK].</p> <code>energy_per_ask_without_operations_medium_range_electric</code> <p>Energy consumption per ASK for passenger medium-range market aircraft using electric propulsion without considering operation improvements [MJ/ASK].</p> <code>energy_per_ask_without_operations_long_range_electric</code> <p>Energy consumption per ASK for passenger long-range market aircraft using electric propulsion without considering operation improvements [MJ/ASK].</p> <code>ask_short_range_dropin_fuel_share</code> <p>Share of Available Seat Kilometer (ASK) for passenger short-range market from drop-in fuel aircraft [%].</p> <code>ask_medium_range_dropin_fuel_share</code> <p>Share of Available Seat Kilometer (ASK) for passenger medium-range market from drop-in fuel aircraft [%].</p> <code>ask_long_range_dropin_fuel_share</code> <p>Share of Available Seat Kilometer (ASK) for passenger long-range market from drop-in fuel aircraft [%].</p> <code>ask_short_range_hydrogen_share</code> <p>Share of Available Seat Kilometer (ASK) for passenger short-range market from hydrogen aircraft [%].</p> <code>ask_medium_range_hydrogen_share</code> <p>Share of Available Seat Kilometer (ASK) for passenger medium-range market from hydrogen aircraft [%].</p> <code>ask_long_range_hydrogen_share</code> <p>Share of Available Seat Kilometer (ASK) for passenger long-range market from hydrogen aircraft [%].</p> <code>ask_short_range_electric_share</code> <p>Share of Available Seat Kilometer (ASK) for passenger short-range market from electric aircraft [%].</p> <code>ask_medium_range_electric_share</code> <p>Share of Available Seat Kilometer (ASK) for passenger medium-range market from electric aircraft [%].</p> <code>ask_long_range_electric_share</code> <p>Share of Available Seat Kilometer (ASK) for passenger long-range market from electric aircraft [%].</p> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/fleet/aircraft_efficiency.py</code> <pre><code>def compute(\n    self,\n    energy_consumption_init: pd.Series,\n    ask_init: pd.Series,\n    short_range_energy_share_2019: float,\n    medium_range_energy_share_2019: float,\n    long_range_energy_share_2019: float,\n    short_range_rpk_share_2019: float,\n    medium_range_rpk_share_2019: float,\n    long_range_rpk_share_2019: float,\n    energy_per_ask_short_range_dropin_fuel_gain_reference_years: list,\n    energy_per_ask_short_range_dropin_fuel_gain_reference_years_values: list,\n    energy_per_ask_medium_range_dropin_fuel_gain_reference_years: list,\n    energy_per_ask_medium_range_dropin_fuel_gain_reference_years_values: list,\n    energy_per_ask_long_range_dropin_fuel_gain_reference_years: list,\n    energy_per_ask_long_range_dropin_fuel_gain_reference_years_values: list,\n    relative_energy_per_ask_hydrogen_wrt_dropin_short_range_reference_years: list,\n    relative_energy_per_ask_hydrogen_wrt_dropin_short_range_reference_years_values: list,\n    relative_energy_per_ask_hydrogen_wrt_dropin_medium_range_reference_years: list,\n    relative_energy_per_ask_hydrogen_wrt_dropin_medium_range_reference_years_values: list,\n    relative_energy_per_ask_hydrogen_wrt_dropin_long_range_reference_years: list,\n    relative_energy_per_ask_hydrogen_wrt_dropin_long_range_reference_years_values: list,\n    relative_energy_per_ask_electric_wrt_dropin_short_range_reference_years: list,\n    relative_energy_per_ask_electric_wrt_dropin_short_range_reference_years_values: list,\n    relative_energy_per_ask_electric_wrt_dropin_medium_range_reference_years: list,\n    relative_energy_per_ask_electric_wrt_dropin_medium_range_reference_years_values: list,\n    relative_energy_per_ask_electric_wrt_dropin_long_range_reference_years: list,\n    relative_energy_per_ask_electric_wrt_dropin_long_range_reference_years_values: list,\n    hydrogen_final_market_share_short_range: float,\n    hydrogen_introduction_year_short_range: Number,\n    hydrogen_final_market_share_medium_range: float,\n    hydrogen_introduction_year_medium_range: Number,\n    hydrogen_final_market_share_long_range: float,\n    hydrogen_introduction_year_long_range: Number,\n    electric_final_market_share_short_range: float,\n    electric_introduction_year_short_range: Number,\n    electric_final_market_share_medium_range: float,\n    electric_introduction_year_medium_range: Number,\n    electric_final_market_share_long_range: float,\n    electric_introduction_year_long_range: Number,\n    fleet_renewal_duration: float,\n    covid_energy_intensity_per_ask_increase_2020: float,\n) -&gt; Tuple[\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n]:\n    \"\"\"\n    Compute energy consumption per ASK (without operations) using simple annual improvement rates.\n\n    Parameters\n    ----------\n    energy_consumption_init\n        Historical energy consumption of aviation over 2000-2019 [MJ].\n    ask_init\n        Historical number of Available Seat Kilometer (ASK) over 2000-2019 [ASK].\n    short_range_energy_share_2019\n        Share of aviation energy consumed by passenger short-range market in 2019 [%].\n    medium_range_energy_share_2019\n        Share of aviation energy consumed by passenger medium-range market in 2019 [%].\n    long_range_energy_share_2019\n        Share of aviation energy consumed by passenger long-range market in 2019 [%].\n    short_range_rpk_share_2019\n        Share of RPK from short-range market in 2019 [%].\n    medium_range_rpk_share_2019\n        Share of RPK from medium-range market in 2019 [%].\n    long_range_rpk_share_2019\n        Share of RPK from long-range market in 2019 [%].\n    energy_per_ask_short_range_dropin_fuel_gain_reference_years\n        Reference years for the mean annual efficiency gains in terms of energy consumption per ASK for short-range drop-in fuel aircraft [yr].\n    energy_per_ask_short_range_dropin_fuel_gain_reference_years_values\n        Mean annual efficiency gains in terms of energy consumption per ASK for short-range drop-in fuel aircraft for the reference years [%].\n    energy_per_ask_medium_range_dropin_fuel_gain_reference_years\n        Reference years for the mean annual efficiency gains in terms of energy consumption per ASK for medium-range drop-in fuel aircraft [yr].\n    energy_per_ask_medium_range_dropin_fuel_gain_reference_years_values\n        Mean annual efficiency gains in terms of energy consumption per ASK for medium-range drop-in fuel aircraft for the reference years [%].\n    energy_per_ask_long_range_dropin_fuel_gain_reference_years\n        Reference years for the mean annual efficiency gains in terms of energy consumption per ASK for long-range drop-in fuel aircraft [yr].\n    energy_per_ask_long_range_dropin_fuel_gain_reference_years_values\n        Mean annual efficiency gains in terms of energy consumption per ASK for long-range drop-in fuel aircraft for the reference years [%].\n    relative_energy_per_ask_hydrogen_wrt_dropin_short_range_reference_years\n        Reference years for the relative energy consumption per ASK of hydrogen aircraft with respect to drop-in aircraft for passenger short-range market [yr].\n    relative_energy_per_ask_hydrogen_wrt_dropin_short_range_reference_years_values\n        Relative energy consumption per ASK of hydrogen aircraft with respect to drop-in aircraft for passenger short-range market for the reference years [-].\n    relative_energy_per_ask_hydrogen_wrt_dropin_medium_range_reference_years\n        Reference years for the relative energy consumption per ASK of hydrogen aircraft with respect to drop-in aircraft for passenger medium-range market [yr].\n    relative_energy_per_ask_hydrogen_wrt_dropin_medium_range_reference_years_values\n        Relative energy consumption per ASK of hydrogen aircraft with respect to drop-in aircraft for passenger medium-range market for the reference years [-].\n    relative_energy_per_ask_hydrogen_wrt_dropin_long_range_reference_years\n        Reference years for the relative energy consumption per ASK of hydrogen aircraft with respect to drop-in aircraft for passenger long-range market [yr].\n    relative_energy_per_ask_hydrogen_wrt_dropin_long_range_reference_years_values\n        Relative energy consumption per ASK of hydrogen aircraft with respect to drop-in aircraft for passenger long-range market for the reference years [-].\n    relative_energy_per_ask_electric_wrt_dropin_short_range_reference_years\n        Reference years for the relative energy consumption per ASK of electric aircraft with respect to drop-in aircraft for passenger short-range market [yr].\n    relative_energy_per_ask_electric_wrt_dropin_short_range_reference_years_values\n        Relative energy consumption per ASK of electric aircraft with respect to drop-in aircraft for passenger short-range market for the reference years [-].\n    relative_energy_per_ask_electric_wrt_dropin_medium_range_reference_years\n        Reference years for the relative energy consumption per ASK of electric aircraft with respect to drop-in aircraft for passenger medium-range market [yr].\n    relative_energy_per_ask_electric_wrt_dropin_medium_range_reference_years_values\n        Relative energy consumption per ASK of electric aircraft with respect to drop-in aircraft for passenger medium-range market for the reference years [-].\n    relative_energy_per_ask_electric_wrt_dropin_long_range_reference_years\n        Reference years for the relative energy consumption per ASK of electric aircraft with respect to drop-in aircraft for passenger long-range market [yr].\n    relative_energy_per_ask_electric_wrt_dropin_long_range_reference_years_values\n        Relative energy consumption per ASK of electric aircraft with respect to drop-in aircraft for passenger long-range market for the reference years [-].\n    hydrogen_final_market_share_short_range\n        Share of hydrogen aircraft in the passenger short-range market [%].\n    hydrogen_introduction_year_short_range\n        Entry-Into-Service year of hydrogen aircraft for short-range market [yr].\n    hydrogen_final_market_share_medium_range\n        Share of hydrogen aircraft in the passenger medium-range market [%].\n    hydrogen_introduction_year_medium_range\n        Entry-Into-Service year of hydrogen aircraft for medium-range market [yr].\n    hydrogen_final_market_share_long_range\n        Share of hydrogen aircraft in the passenger long-range market [%].\n    hydrogen_introduction_year_long_range\n        Entry-Into-Service year of hydrogen aircraft for long-range market [yr].\n    electric_final_market_share_short_range\n        Share of electric aircraft in the passenger short-range market [%].\n    electric_introduction_year_short_range\n        Entry-Into-Service year of electric aircraft for short-range market [yr].\n    electric_final_market_share_medium_range\n        Share of electric aircraft in the passenger medium-range market [%].\n    electric_introduction_year_medium_range\n        Entry-Into-Service year of electric aircraft for medium-range market [yr].\n    electric_final_market_share_long_range\n        Share of electric aircraft in the passenger long-range market [%].\n    electric_introduction_year_long_range\n        Entry-Into-Service year of electric aircraft for long-range market [yr].\n    fleet_renewal_duration\n        Duration for renewing 98% of the aircraft fleet [yr].\n    covid_energy_intensity_per_ask_increase_2020\n        Increase in energy intensity per ASK due to Covid-19 for the start year [%].\n\n    Returns\n    -------\n    energy_per_ask_without_operations_short_range_dropin_fuel\n        Energy consumption per ASK for passenger short-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_medium_range_dropin_fuel\n        Energy consumption per ASK for passenger medium-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_long_range_dropin_fuel\n        Energy consumption per ASK for passenger long-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_short_range_hydrogen\n        Energy consumption per ASK for passenger short-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_medium_range_hydrogen\n        Energy consumption per ASK for passenger medium-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_long_range_hydrogen\n        Energy consumption per ASK for passenger long-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_short_range_electric\n        Energy consumption per ASK for passenger short-range market aircraft using electric propulsion without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_medium_range_electric\n        Energy consumption per ASK for passenger medium-range market aircraft using electric propulsion without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_long_range_electric\n        Energy consumption per ASK for passenger long-range market aircraft using electric propulsion without considering operation improvements [MJ/ASK].\n    ask_short_range_dropin_fuel_share\n        Share of Available Seat Kilometer (ASK) for passenger short-range market from drop-in fuel aircraft [%].\n    ask_medium_range_dropin_fuel_share\n        Share of Available Seat Kilometer (ASK) for passenger medium-range market from drop-in fuel aircraft [%].\n    ask_long_range_dropin_fuel_share\n        Share of Available Seat Kilometer (ASK) for passenger long-range market from drop-in fuel aircraft [%].\n    ask_short_range_hydrogen_share\n        Share of Available Seat Kilometer (ASK) for passenger short-range market from hydrogen aircraft [%].\n    ask_medium_range_hydrogen_share\n        Share of Available Seat Kilometer (ASK) for passenger medium-range market from hydrogen aircraft [%].\n    ask_long_range_hydrogen_share\n        Share of Available Seat Kilometer (ASK) for passenger long-range market from hydrogen aircraft [%].\n    ask_short_range_electric_share\n        Share of Available Seat Kilometer (ASK) for passenger short-range market from electric aircraft [%].\n    ask_medium_range_electric_share\n        Share of Available Seat Kilometer (ASK) for passenger medium-range market from electric aircraft [%].\n    ask_long_range_electric_share\n        Share of Available Seat Kilometer (ASK) for passenger long-range market from electric aircraft [%].\n    \"\"\"\n\n    # Initialization based on 2019 share\n    energy_consumption_per_ask_init = energy_consumption_init / ask_init\n    # Vectorised\n    years_hist = np.arange(self.historic_start_year, self.prospection_start_year)\n    idx_hist = pd.Index(years_hist)\n\n    years_proj = np.arange(self.prospection_start_year, self.end_year + 1)\n    idx_proj = pd.Index(years_proj)\n\n    self.df.loc[idx_hist, \"energy_per_ask_without_operations_short_range_dropin_fuel\"] = (\n        energy_consumption_per_ask_init.loc[idx_hist]\n        * short_range_energy_share_2019\n        / short_range_rpk_share_2019\n    )\n    self.df.loc[idx_hist, \"energy_per_ask_without_operations_medium_range_dropin_fuel\"] = (\n        energy_consumption_per_ask_init.loc[idx_hist]\n        * medium_range_energy_share_2019\n        / medium_range_rpk_share_2019\n    )\n    self.df.loc[idx_hist, \"energy_per_ask_without_operations_long_range_dropin_fuel\"] = (\n        energy_consumption_per_ask_init.loc[idx_hist]\n        * long_range_energy_share_2019\n        / long_range_rpk_share_2019\n    )\n\n    # Projections\n\n    ## Drop-in\n\n    energy_per_ask_short_range_dropin_fuel_gain = aeromaps_interpolation_function(\n        self,\n        energy_per_ask_short_range_dropin_fuel_gain_reference_years,\n        energy_per_ask_short_range_dropin_fuel_gain_reference_years_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"energy_per_ask_short_range_dropin_fuel_gain\"] = (\n        energy_per_ask_short_range_dropin_fuel_gain\n    )\n    energy_per_ask_medium_range_dropin_fuel_gain = aeromaps_interpolation_function(\n        self,\n        energy_per_ask_medium_range_dropin_fuel_gain_reference_years,\n        energy_per_ask_medium_range_dropin_fuel_gain_reference_years_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"energy_per_ask_medium_range_dropin_fuel_gain\"] = (\n        energy_per_ask_medium_range_dropin_fuel_gain\n    )\n    energy_per_ask_long_range_dropin_fuel_gain = aeromaps_interpolation_function(\n        self,\n        energy_per_ask_long_range_dropin_fuel_gain_reference_years,\n        energy_per_ask_long_range_dropin_fuel_gain_reference_years_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"energy_per_ask_long_range_dropin_fuel_gain\"] = (\n        energy_per_ask_long_range_dropin_fuel_gain\n    )\n\n    for k in range(self.prospection_start_year, self.end_year + 1):\n        self.df.loc[k, \"energy_per_ask_without_operations_short_range_dropin_fuel\"] = (\n            self.df.loc[k - 1, \"energy_per_ask_without_operations_short_range_dropin_fuel\"]\n            * (1 - energy_per_ask_short_range_dropin_fuel_gain.loc[k] / 100)\n        )\n        self.df.loc[k, \"energy_per_ask_without_operations_medium_range_dropin_fuel\"] = (\n            self.df.loc[k - 1, \"energy_per_ask_without_operations_medium_range_dropin_fuel\"]\n            * (1 - energy_per_ask_medium_range_dropin_fuel_gain.loc[k] / 100)\n        )\n        self.df.loc[k, \"energy_per_ask_without_operations_long_range_dropin_fuel\"] = (\n            self.df.loc[k - 1, \"energy_per_ask_without_operations_long_range_dropin_fuel\"]\n            * (1 - energy_per_ask_long_range_dropin_fuel_gain.loc[k] / 100)\n        )\n\n    self.df.loc[2020, \"energy_per_ask_without_operations_short_range_dropin_fuel\"] = (\n        self.df.loc[2019, \"energy_per_ask_without_operations_short_range_dropin_fuel\"]\n        * (1 + covid_energy_intensity_per_ask_increase_2020 / 100)\n    )\n    self.df.loc[2020, \"energy_per_ask_without_operations_medium_range_dropin_fuel\"] = (\n        self.df.loc[2019, \"energy_per_ask_without_operations_medium_range_dropin_fuel\"]\n        * (1 + covid_energy_intensity_per_ask_increase_2020 / 100)\n    )\n    self.df.loc[2020, \"energy_per_ask_without_operations_long_range_dropin_fuel\"] = self.df.loc[\n        2019, \"energy_per_ask_without_operations_long_range_dropin_fuel\"\n    ] * (1 + covid_energy_intensity_per_ask_increase_2020 / 100)\n\n    energy_per_ask_without_operations_short_range_dropin_fuel = self.df[\n        \"energy_per_ask_without_operations_short_range_dropin_fuel\"\n    ]\n    energy_per_ask_without_operations_medium_range_dropin_fuel = self.df[\n        \"energy_per_ask_without_operations_medium_range_dropin_fuel\"\n    ]\n    energy_per_ask_without_operations_long_range_dropin_fuel = self.df[\n        \"energy_per_ask_without_operations_long_range_dropin_fuel\"\n    ]\n\n    ## Hydrogen\n\n    relative_energy_per_ask_hydrogen_wrt_dropin_short_range = aeromaps_interpolation_function(\n        self,\n        relative_energy_per_ask_hydrogen_wrt_dropin_short_range_reference_years,\n        relative_energy_per_ask_hydrogen_wrt_dropin_short_range_reference_years_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"relative_energy_per_ask_hydrogen_wrt_dropin_short_range\"] = (\n        relative_energy_per_ask_hydrogen_wrt_dropin_short_range\n    )\n    relative_energy_per_ask_hydrogen_wrt_dropin_medium_range = aeromaps_interpolation_function(\n        self,\n        relative_energy_per_ask_hydrogen_wrt_dropin_medium_range_reference_years,\n        relative_energy_per_ask_hydrogen_wrt_dropin_medium_range_reference_years_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"relative_energy_per_ask_hydrogen_wrt_dropin_medium_range\"] = (\n        relative_energy_per_ask_hydrogen_wrt_dropin_medium_range\n    )\n    relative_energy_per_ask_hydrogen_wrt_dropin_long_range = aeromaps_interpolation_function(\n        self,\n        relative_energy_per_ask_hydrogen_wrt_dropin_long_range_reference_years,\n        relative_energy_per_ask_hydrogen_wrt_dropin_long_range_reference_years_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"relative_energy_per_ask_hydrogen_wrt_dropin_long_range\"] = (\n        relative_energy_per_ask_hydrogen_wrt_dropin_long_range\n    )\n\n    # Ann\u00e9es historiques : copie directe\n    self.df.loc[idx_hist, \"energy_per_ask_without_operations_short_range_hydrogen\"] = (\n        energy_per_ask_without_operations_short_range_dropin_fuel.loc[idx_hist]\n    )\n    self.df.loc[idx_hist, \"energy_per_ask_without_operations_medium_range_hydrogen\"] = (\n        energy_per_ask_without_operations_medium_range_dropin_fuel.loc[idx_hist]\n    )\n    self.df.loc[idx_hist, \"energy_per_ask_without_operations_long_range_hydrogen\"] = (\n        energy_per_ask_without_operations_long_range_dropin_fuel.loc[idx_hist]\n    )\n    # Ann\u00e9es projections : vectoris\u00e9\n    self.df.loc[idx_proj, \"energy_per_ask_without_operations_short_range_hydrogen\"] = (\n        energy_per_ask_without_operations_short_range_dropin_fuel.loc[idx_proj]\n        * self.df.loc[idx_proj, \"relative_energy_per_ask_hydrogen_wrt_dropin_short_range\"]\n    )\n    self.df.loc[idx_proj, \"energy_per_ask_without_operations_medium_range_hydrogen\"] = (\n        energy_per_ask_without_operations_medium_range_dropin_fuel.loc[idx_proj]\n        * self.df.loc[idx_proj, \"relative_energy_per_ask_hydrogen_wrt_dropin_medium_range\"]\n    )\n    self.df.loc[idx_proj, \"energy_per_ask_without_operations_long_range_hydrogen\"] = (\n        energy_per_ask_without_operations_long_range_dropin_fuel.loc[idx_proj]\n        * self.df.loc[idx_proj, \"relative_energy_per_ask_hydrogen_wrt_dropin_long_range\"]\n    )\n\n    energy_per_ask_without_operations_short_range_hydrogen = self.df[\n        \"energy_per_ask_without_operations_short_range_hydrogen\"\n    ]\n    energy_per_ask_without_operations_medium_range_hydrogen = self.df[\n        \"energy_per_ask_without_operations_medium_range_hydrogen\"\n    ]\n    energy_per_ask_without_operations_long_range_hydrogen = self.df[\n        \"energy_per_ask_without_operations_long_range_hydrogen\"\n    ]\n\n    ## Electric\n\n    relative_energy_per_ask_electric_wrt_dropin_short_range = aeromaps_interpolation_function(\n        self,\n        relative_energy_per_ask_electric_wrt_dropin_short_range_reference_years,\n        relative_energy_per_ask_electric_wrt_dropin_short_range_reference_years_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"relative_energy_per_ask_electric_wrt_dropin_short_range\"] = (\n        relative_energy_per_ask_electric_wrt_dropin_short_range\n    )\n    relative_energy_per_ask_electric_wrt_dropin_medium_range = aeromaps_interpolation_function(\n        self,\n        relative_energy_per_ask_electric_wrt_dropin_medium_range_reference_years,\n        relative_energy_per_ask_electric_wrt_dropin_medium_range_reference_years_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"relative_energy_per_ask_electric_wrt_dropin_medium_range\"] = (\n        relative_energy_per_ask_electric_wrt_dropin_medium_range\n    )\n    relative_energy_per_ask_electric_wrt_dropin_long_range = aeromaps_interpolation_function(\n        self,\n        relative_energy_per_ask_electric_wrt_dropin_long_range_reference_years,\n        relative_energy_per_ask_electric_wrt_dropin_long_range_reference_years_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"relative_energy_per_ask_electric_wrt_dropin_long_range\"] = (\n        relative_energy_per_ask_electric_wrt_dropin_long_range\n    )\n\n    self.df.loc[idx_hist, \"energy_per_ask_without_operations_short_range_electric\"] = (\n        energy_per_ask_without_operations_short_range_dropin_fuel.loc[idx_hist]\n    )\n    self.df.loc[idx_hist, \"energy_per_ask_without_operations_medium_range_electric\"] = (\n        energy_per_ask_without_operations_medium_range_dropin_fuel.loc[idx_hist]\n    )\n    self.df.loc[idx_hist, \"energy_per_ask_without_operations_long_range_electric\"] = (\n        energy_per_ask_without_operations_long_range_dropin_fuel.loc[idx_hist]\n    )\n    self.df.loc[idx_proj, \"energy_per_ask_without_operations_short_range_electric\"] = (\n        energy_per_ask_without_operations_short_range_dropin_fuel.loc[idx_proj]\n        * self.df.loc[idx_proj, \"relative_energy_per_ask_electric_wrt_dropin_short_range\"]\n    )\n    self.df.loc[idx_proj, \"energy_per_ask_without_operations_medium_range_electric\"] = (\n        energy_per_ask_without_operations_medium_range_dropin_fuel.loc[idx_proj]\n        * self.df.loc[idx_proj, \"relative_energy_per_ask_electric_wrt_dropin_medium_range\"]\n    )\n    self.df.loc[idx_proj, \"energy_per_ask_without_operations_long_range_electric\"] = (\n        energy_per_ask_without_operations_long_range_dropin_fuel.loc[idx_proj]\n        * self.df.loc[idx_proj, \"relative_energy_per_ask_electric_wrt_dropin_long_range\"]\n    )\n\n    energy_per_ask_without_operations_short_range_electric = self.df[\n        \"energy_per_ask_without_operations_short_range_electric\"\n    ]\n    energy_per_ask_without_operations_medium_range_electric = self.df[\n        \"energy_per_ask_without_operations_medium_range_electric\"\n    ]\n    energy_per_ask_without_operations_long_range_electric = self.df[\n        \"energy_per_ask_without_operations_long_range_electric\"\n    ]\n\n    # ASK Hydrogen\n\n    years_all = np.arange(self.historic_start_year, self.end_year + 1)\n    idx_all = pd.Index(years_all)\n\n    # Hydrogen shares vectoris\u00e9s\n    self.df.loc[idx_all, \"ask_short_range_hydrogen_share\"] = self._simple_sigmoid_share(\n        years_all,\n        hydrogen_final_market_share_short_range,\n        hydrogen_introduction_year_short_range,\n        fleet_renewal_duration,\n    )\n    self.df.loc[idx_all, \"ask_medium_range_hydrogen_share\"] = self._simple_sigmoid_share(\n        years_all,\n        hydrogen_final_market_share_medium_range,\n        hydrogen_introduction_year_medium_range,\n        fleet_renewal_duration,\n    )\n    self.df.loc[idx_all, \"ask_long_range_hydrogen_share\"] = self._simple_sigmoid_share(\n        years_all,\n        hydrogen_final_market_share_long_range,\n        hydrogen_introduction_year_long_range,\n        fleet_renewal_duration,\n    )\n\n    ask_short_range_hydrogen_share = self.df[\"ask_short_range_hydrogen_share\"]\n    ask_medium_range_hydrogen_share = self.df[\"ask_medium_range_hydrogen_share\"]\n    ask_long_range_hydrogen_share = self.df[\"ask_long_range_hydrogen_share\"]\n\n    # ASK Electric\n\n    # Electric shares vectoris\u00e9s\n    self.df.loc[idx_all, \"ask_short_range_electric_share\"] = self._simple_sigmoid_share(\n        years_all,\n        electric_final_market_share_short_range,\n        electric_introduction_year_short_range,\n        fleet_renewal_duration,\n    )\n    self.df.loc[idx_all, \"ask_medium_range_electric_share\"] = self._simple_sigmoid_share(\n        years_all,\n        electric_final_market_share_medium_range,\n        electric_introduction_year_medium_range,\n        fleet_renewal_duration,\n    )\n    self.df.loc[idx_all, \"ask_long_range_electric_share\"] = self._simple_sigmoid_share(\n        years_all,\n        electric_final_market_share_long_range,\n        electric_introduction_year_long_range,\n        fleet_renewal_duration,\n    )\n\n    ask_short_range_electric_share = self.df[\"ask_short_range_electric_share\"]\n    ask_medium_range_electric_share = self.df[\"ask_medium_range_electric_share\"]\n    ask_long_range_electric_share = self.df[\"ask_long_range_electric_share\"]\n\n    # ASK Drop-in fuel\n\n    ask_short_range_dropin_fuel_share = (\n        100 - ask_short_range_hydrogen_share - ask_short_range_electric_share\n    )\n    ask_medium_range_dropin_fuel_share = (\n        100 - ask_medium_range_hydrogen_share - ask_medium_range_electric_share\n    )\n    ask_long_range_dropin_fuel_share = (\n        100 - ask_long_range_hydrogen_share - ask_long_range_electric_share\n    )\n    self.df.loc[:, \"ask_short_range_dropin_fuel_share\"] = ask_short_range_dropin_fuel_share\n    self.df.loc[:, \"ask_medium_range_dropin_fuel_share\"] = ask_medium_range_dropin_fuel_share\n    self.df.loc[:, \"ask_long_range_dropin_fuel_share\"] = ask_long_range_dropin_fuel_share\n\n    return (\n        energy_per_ask_without_operations_short_range_dropin_fuel,\n        energy_per_ask_without_operations_medium_range_dropin_fuel,\n        energy_per_ask_without_operations_long_range_dropin_fuel,\n        energy_per_ask_without_operations_short_range_hydrogen,\n        energy_per_ask_without_operations_medium_range_hydrogen,\n        energy_per_ask_without_operations_long_range_hydrogen,\n        energy_per_ask_without_operations_short_range_electric,\n        energy_per_ask_without_operations_medium_range_electric,\n        energy_per_ask_without_operations_long_range_electric,\n        ask_short_range_dropin_fuel_share,\n        ask_medium_range_dropin_fuel_share,\n        ask_long_range_dropin_fuel_share,\n        ask_short_range_hydrogen_share,\n        ask_medium_range_hydrogen_share,\n        ask_long_range_hydrogen_share,\n        ask_short_range_electric_share,\n        ask_medium_range_electric_share,\n        ask_long_range_electric_share,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.aircraft_efficiency/#aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.aircraft_efficiency.PassengerAircraftEfficiencySimpleASK","title":"PassengerAircraftEfficiencySimpleASK","text":"<pre><code>PassengerAircraftEfficiencySimpleASK(name='passenger_aircraft_efficiency_simple_ask', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute ASK for each aircraft type when using simple efficiency models.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('passenger_aircraft_efficiency_simple_ask' by default).</p> <code>'passenger_aircraft_efficiency_simple_ask'</code> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/fleet/aircraft_efficiency.py</code> <pre><code>def __init__(self, name=\"passenger_aircraft_efficiency_simple_ask\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.aircraft_efficiency/#aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.aircraft_efficiency.PassengerAircraftEfficiencySimpleASK.compute","title":"compute","text":"<pre><code>compute(ask_short_range, ask_medium_range, ask_long_range, ask_short_range_hydrogen_share, ask_medium_range_hydrogen_share, ask_long_range_hydrogen_share, ask_short_range_electric_share, ask_medium_range_electric_share, ask_long_range_electric_share)\n</code></pre> <p>Compute ASK breakdown by aircraft type and range.</p> <p>Parameters:</p> Name Type Description Default <code>ask_short_range</code> <code>Series</code> <p>Number of Available Seat Kilometre (ASK) for passenger short-range market [ASK].</p> required <code>ask_medium_range</code> <code>Series</code> <p>Number of Available Seat Kilometre (ASK) for passenger medium-range market [ASK].</p> required <code>ask_long_range</code> <code>Series</code> <p>Number of Available Seat Kilometre (ASK) for passenger long-range market [ASK].</p> required <code>ask_short_range_hydrogen_share</code> <code>Series</code> <p>Share of Available Seat Kilometre (ASK) for passenger short-range market from hydrogen aircraft [%].</p> required <code>ask_medium_range_hydrogen_share</code> <code>Series</code> <p>Share of Available Seat Kilometre (ASK) for passenger medium-range market from hydrogen aircraft [%].</p> required <code>ask_long_range_hydrogen_share</code> <code>Series</code> <p>Share of Available Seat Kilometre (ASK) for passenger long-range market from hydrogen aircraft [%].</p> required <code>ask_short_range_electric_share</code> <code>Series</code> <p>Share of Available Seat Kilometre (ASK) for passenger short-range market from electric aircraft [%].</p> required <code>ask_medium_range_electric_share</code> <code>Series</code> <p>Share of Available Seat Kilometre (ASK) for passenger medium-range market from electric aircraft [%].</p> required <code>ask_long_range_electric_share</code> <code>Series</code> <p>Share of Available Seat Kilometre (ASK) for passenger long-range market from electric aircraft [%].</p> required <p>Returns:</p> Type Description <code>ask_short_range_dropin_fuel</code> <p>ASK for short-range market from drop-in fuel aircraft [ASK].</p> <code>ask_medium_range_dropin_fuel</code> <p>ASK for medium-range market from drop-in fuel aircraft [ASK].</p> <code>ask_long_range_dropin_fuel</code> <p>ASK for long-range market from drop-in fuel aircraft [ASK].</p> <code>ask_short_range_hydrogen</code> <p>ASK for short-range market from hydrogen aircraft [ASK].</p> <code>ask_medium_range_hydrogen</code> <p>ASK for medium-range market from hydrogen aircraft [ASK].</p> <code>ask_long_range_hydrogen</code> <p>ASK for long-range market from hydrogen aircraft [ASK].</p> <code>ask_short_range_electric</code> <p>ASK for short-range market from electric aircraft [ASK].</p> <code>ask_medium_range_electric</code> <p>ASK for medium-range market from electric aircraft [ASK].</p> <code>ask_long_range_electric</code> <p>ASK for long-range market from electric aircraft [ASK].</p> <code>ask_dropin_fuel</code> <p>Total ASK for drop-in fuel aircraft across ranges [ASK].</p> <code>ask_hydrogen</code> <p>Total ASK for hydrogen aircraft across ranges [ASK].</p> <code>ask_electric</code> <p>Total ASK for electric aircraft across ranges [ASK].</p> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/fleet/aircraft_efficiency.py</code> <pre><code>def compute(\n    self,\n    ask_short_range: pd.Series,\n    ask_medium_range: pd.Series,\n    ask_long_range: pd.Series,\n    ask_short_range_hydrogen_share: pd.Series,\n    ask_medium_range_hydrogen_share: pd.Series,\n    ask_long_range_hydrogen_share: pd.Series,\n    ask_short_range_electric_share: pd.Series,\n    ask_medium_range_electric_share: pd.Series,\n    ask_long_range_electric_share: pd.Series,\n) -&gt; Tuple[\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n]:\n    \"\"\"\n    Compute ASK breakdown by aircraft type and range.\n\n    Parameters\n    ----------\n    ask_short_range\n        Number of Available Seat Kilometre (ASK) for passenger short-range market [ASK].\n    ask_medium_range\n        Number of Available Seat Kilometre (ASK) for passenger medium-range market [ASK].\n    ask_long_range\n        Number of Available Seat Kilometre (ASK) for passenger long-range market [ASK].\n    ask_short_range_hydrogen_share\n        Share of Available Seat Kilometre (ASK) for passenger short-range market from hydrogen aircraft [%].\n    ask_medium_range_hydrogen_share\n        Share of Available Seat Kilometre (ASK) for passenger medium-range market from hydrogen aircraft [%].\n    ask_long_range_hydrogen_share\n        Share of Available Seat Kilometre (ASK) for passenger long-range market from hydrogen aircraft [%].\n    ask_short_range_electric_share\n        Share of Available Seat Kilometre (ASK) for passenger short-range market from electric aircraft [%].\n    ask_medium_range_electric_share\n        Share of Available Seat Kilometre (ASK) for passenger medium-range market from electric aircraft [%].\n    ask_long_range_electric_share\n        Share of Available Seat Kilometre (ASK) for passenger long-range market from electric aircraft [%].\n\n    Returns\n    -------\n    ask_short_range_dropin_fuel\n        ASK for short-range market from drop-in fuel aircraft [ASK].\n    ask_medium_range_dropin_fuel\n        ASK for medium-range market from drop-in fuel aircraft [ASK].\n    ask_long_range_dropin_fuel\n        ASK for long-range market from drop-in fuel aircraft [ASK].\n    ask_short_range_hydrogen\n        ASK for short-range market from hydrogen aircraft [ASK].\n    ask_medium_range_hydrogen\n        ASK for medium-range market from hydrogen aircraft [ASK].\n    ask_long_range_hydrogen\n        ASK for long-range market from hydrogen aircraft [ASK].\n    ask_short_range_electric\n        ASK for short-range market from electric aircraft [ASK].\n    ask_medium_range_electric\n        ASK for medium-range market from electric aircraft [ASK].\n    ask_long_range_electric\n        ASK for long-range market from electric aircraft [ASK].\n    ask_dropin_fuel\n        Total ASK for drop-in fuel aircraft across ranges [ASK].\n    ask_hydrogen\n        Total ASK for hydrogen aircraft across ranges [ASK].\n    ask_electric\n        Total ASK for electric aircraft across ranges [ASK].\n    \"\"\"\n\n    # ASK Hydrogen\n    ask_short_range_hydrogen = ask_short_range * ask_short_range_hydrogen_share / 100\n    ask_medium_range_hydrogen = ask_medium_range * ask_medium_range_hydrogen_share / 100\n    ask_long_range_hydrogen = ask_long_range * ask_long_range_hydrogen_share / 100\n    self.df.loc[:, \"ask_short_range_hydrogen\"] = ask_short_range_hydrogen\n    self.df.loc[:, \"ask_medium_range_hydrogen\"] = ask_medium_range_hydrogen\n    self.df.loc[:, \"ask_long_range_hydrogen\"] = ask_long_range_hydrogen\n\n    # ASK Electric\n\n    ask_short_range_electric = ask_short_range * ask_short_range_electric_share / 100\n    ask_medium_range_electric = ask_medium_range * ask_medium_range_electric_share / 100\n    ask_long_range_electric = ask_long_range * ask_long_range_electric_share / 100\n    self.df.loc[:, \"ask_short_range_electric\"] = ask_short_range_electric\n    self.df.loc[:, \"ask_medium_range_electric\"] = ask_medium_range_electric\n    self.df.loc[:, \"ask_long_range_electric\"] = ask_long_range_electric\n\n    # ASK Drop-in fuel\n\n    ask_short_range_dropin_fuel = (\n        ask_short_range - ask_short_range_hydrogen - ask_short_range_electric\n    )\n    ask_medium_range_dropin_fuel = (\n        ask_medium_range - ask_medium_range_hydrogen - ask_medium_range_electric\n    )\n    ask_long_range_dropin_fuel = (\n        ask_long_range - ask_long_range_hydrogen - ask_long_range_electric\n    )\n    self.df.loc[:, \"ask_short_range_dropin_fuel\"] = ask_short_range_dropin_fuel\n    self.df.loc[:, \"ask_medium_range_dropin_fuel\"] = ask_medium_range_dropin_fuel\n    self.df.loc[:, \"ask_long_range_dropin_fuel\"] = ask_long_range_dropin_fuel\n\n    # Total ASK\n\n    ask_dropin_fuel = (\n        ask_short_range_dropin_fuel + ask_medium_range_dropin_fuel + ask_long_range_dropin_fuel\n    )\n    ask_hydrogen = (\n        ask_short_range_hydrogen + ask_medium_range_hydrogen + ask_long_range_hydrogen\n    )\n    ask_electric = (\n        ask_short_range_electric + ask_medium_range_electric + ask_long_range_electric\n    )\n\n    self.df.loc[:, \"ask_dropin_fuel\"] = ask_dropin_fuel\n    self.df.loc[:, \"ask_hydrogen\"] = ask_hydrogen\n    self.df.loc[:, \"ask_electric\"] = ask_electric\n\n    return (\n        ask_short_range_dropin_fuel,\n        ask_medium_range_dropin_fuel,\n        ask_long_range_dropin_fuel,\n        ask_short_range_hydrogen,\n        ask_medium_range_hydrogen,\n        ask_long_range_hydrogen,\n        ask_short_range_electric,\n        ask_medium_range_electric,\n        ask_long_range_electric,\n        ask_dropin_fuel,\n        ask_hydrogen,\n        ask_electric,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.aircraft_efficiency/#aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.aircraft_efficiency.PassengerAircraftEfficiencyComplex","title":"PassengerAircraftEfficiencyComplex","text":"<pre><code>PassengerAircraftEfficiencyComplex(name='passenger_aircraft_efficiency_complex', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute energy consumption per ASK (without operations) using complex models.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('passenger_aircraft_efficiency_complex' by default).</p> <code>'passenger_aircraft_efficiency_complex'</code> <p>Attributes:</p> Name Type Description <code>fleet_model</code> <code>FleetModel(AeroMAPSModel)</code> <p>FleetModel instance to be used for complex efficiency computations.</p> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/fleet/aircraft_efficiency.py</code> <pre><code>def __init__(self, name=\"passenger_aircraft_efficiency_complex\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n    self.fleet_model = None\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.aircraft_efficiency/#aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.aircraft_efficiency.PassengerAircraftEfficiencyComplex.compute","title":"compute","text":"<pre><code>compute(dummy_fleet_model_output, energy_consumption_init, ask, short_range_energy_share_2019, medium_range_energy_share_2019, long_range_energy_share_2019, short_range_rpk_share_2019, medium_range_rpk_share_2019, long_range_rpk_share_2019, covid_energy_intensity_per_ask_increase_2020, ask_short_range, ask_medium_range, ask_long_range)\n</code></pre> <p>Compute energy consumption per ASK (without operations) using complex fleet-model outputs.</p> <p>Parameters:</p> Name Type Description Default <code>dummy_fleet_model_output</code> <code>ndarray</code> <p>Dummy fleet model output to ensure the prior execution of the generic fleet model [-].</p> required <code>energy_consumption_init</code> <code>Series</code> <p>Historical energy consumption of aviation over 2000-2019 [MJ].</p> required <code>ask</code> <code>Series</code> <p>Number of Available Seat Kilometre (ASK) for all commercial air transport [ASK].</p> required <code>short_range_energy_share_2019</code> <code>float</code> <p>Share of aviation energy consumed by passenger short-range market in 2019 [%].</p> required <code>medium_range_energy_share_2019</code> <code>float</code> <p>Share of aviation energy consumed by passenger medium-range market in 2019 [%].</p> required <code>long_range_energy_share_2019</code> <code>float</code> <p>Share of aviation energy consumed by passenger long-range market in 2019 [%].</p> required <code>short_range_rpk_share_2019</code> <code>float</code> <p>Share of RPK from short-range market in 2019 [%].</p> required <code>medium_range_rpk_share_2019</code> <code>float</code> <p>Share of RPK from medium-range market in 2019 [%].</p> required <code>long_range_rpk_share_2019</code> <code>float</code> <p>Share of RPK from long-range market in 2019 [%].</p> required <code>covid_energy_intensity_per_ask_increase_2020</code> <code>float</code> <p>Increase in energy intensity per ASK due to Covid-19 for the start year [%].</p> required <code>ask_short_range</code> <code>Series</code> <p>Number of Available Seat Kilometre (ASK) for passenger short-range market [ASK].</p> required <code>ask_medium_range</code> <code>Series</code> <p>Number of Available Seat Kilometre (ASK) for passenger medium-range market [ASK].</p> required <code>ask_long_range</code> <code>Series</code> <p>Number of Available Seat Kilometre (ASK) for passenger long-range market [ASK].</p> required <p>Returns:</p> Type Description <code>energy_per_ask_without_operations_short_range_dropin_fuel</code> <p>Energy consumption per ASK for passenger short-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].</p> <code>energy_per_ask_without_operations_medium_range_dropin_fuel</code> <p>Energy consumption per ASK for passenger medium-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].</p> <code>energy_per_ask_without_operations_long_range_dropin_fuel</code> <p>Energy consumption per ASK for passenger long-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].</p> <code>energy_per_ask_without_operations_short_range_hydrogen</code> <p>Energy consumption per ASK for passenger short-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].</p> <code>energy_per_ask_without_operations_medium_range_hydrogen</code> <p>Energy consumption per ASK for passenger medium-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].</p> <code>energy_per_ask_without_operations_long_range_hydrogen</code> <p>Energy consumption per ASK for passenger long-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].</p> <code>energy_per_ask_without_operations_short_range_electric</code> <p>Energy consumption per ASK for passenger short-range market aircraft using electric propulsion without considering operation improvements [MJ/ASK].</p> <code>energy_per_ask_without_operations_medium_range_electric</code> <p>Energy consumption per ASK for passenger medium-range market aircraft using electric propulsion without considering operation improvements [MJ/ASK].</p> <code>energy_per_ask_without_operations_long_range_electric</code> <p>Energy consumption per ASK for passenger long-range market aircraft using electric propulsion without considering operation improvements [MJ/ASK].</p> <code>ask_short_range_dropin_fuel_share</code> <p>Share of Available Seat Kilometer (ASK) for passenger short-range market from drop-in fuel aircraft [%].</p> <code>ask_medium_range_dropin_fuel_share</code> <p>Share of Available Seat Kilometer (ASK) for passenger medium-range market from drop-in fuel aircraft [%].</p> <code>ask_long_range_dropin_fuel_share</code> <p>Share of Available Seat Kilometer (ASK) for passenger long-range market from drop-in fuel aircraft [%].</p> <code>ask_short_range_hydrogen_share</code> <p>Share of Available Seat Kilometer (ASK) for passenger short-range market from hydrogen aircraft [%].</p> <code>ask_medium_range_hydrogen_share</code> <p>Share of Available Seat Kilometer (ASK) for passenger medium-range market from hydrogen aircraft [%].</p> <code>ask_long_range_hydrogen_share</code> <p>Share of Available Seat Kilometer (ASK) for passenger long-range market from hydrogen aircraft [%].</p> <code>ask_short_range_electric_share</code> <p>Share of Available Seat Kilometer (ASK) for passenger short-range market from electric aircraft [%].</p> <code>ask_medium_range_electric_share</code> <p>Share of Available Seat Kilometer (ASK) for passenger medium-range market from electric aircraft [%].</p> <code>ask_long_range_electric_share</code> <p>Share of Available Seat Kilometer (ASK) for passenger long-range market from electric aircraft [%].</p> <code>ask_short_range_dropin_fuel</code> <p>ASK for short-range market from drop-in fuel aircraft [ASK].</p> <code>ask_medium_range_dropin_fuel</code> <p>ASK for medium-range market from drop-in fuel aircraft [ASK].</p> <code>ask_long_range_dropin_fuel</code> <p>ASK for long-range market from drop-in fuel aircraft [ASK].</p> <code>ask_short_range_hydrogen</code> <p>ASK for short-range market from hydrogen aircraft [ASK].</p> <code>ask_medium_range_hydrogen</code> <p>ASK for medium-range market from hydrogen aircraft [ASK].</p> <code>ask_long_range_hydrogen</code> <p>ASK for long-range market from hydrogen aircraft [ASK].</p> <code>ask_short_range_electric</code> <p>ASK for short-range market from electric aircraft [ASK].</p> <code>ask_medium_range_electric</code> <p>ASK for medium-range market from electric aircraft [ASK].</p> <code>ask_long_range_electric</code> <p>ASK for long-range market from electric aircraft [ASK].</p> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/fleet/aircraft_efficiency.py</code> <pre><code>def compute(\n    self,\n    dummy_fleet_model_output: np.ndarray,\n    energy_consumption_init: pd.Series,\n    ask: pd.Series,\n    short_range_energy_share_2019: float,\n    medium_range_energy_share_2019: float,\n    long_range_energy_share_2019: float,\n    short_range_rpk_share_2019: float,\n    medium_range_rpk_share_2019: float,\n    long_range_rpk_share_2019: float,\n    covid_energy_intensity_per_ask_increase_2020: float,\n    ask_short_range: pd.Series,\n    ask_medium_range: pd.Series,\n    ask_long_range: pd.Series,\n) -&gt; Tuple[\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n]:\n    \"\"\"\n    Compute energy consumption per ASK (without operations) using complex fleet-model outputs.\n\n    Parameters\n    ----------\n    dummy_fleet_model_output\n        Dummy fleet model output to ensure the prior execution of the generic fleet model [-].\n    energy_consumption_init\n        Historical energy consumption of aviation over 2000-2019 [MJ].\n    ask\n        Number of Available Seat Kilometre (ASK) for all commercial air transport [ASK].\n    short_range_energy_share_2019\n        Share of aviation energy consumed by passenger short-range market in 2019 [%].\n    medium_range_energy_share_2019\n        Share of aviation energy consumed by passenger medium-range market in 2019 [%].\n    long_range_energy_share_2019\n        Share of aviation energy consumed by passenger long-range market in 2019 [%].\n    short_range_rpk_share_2019\n        Share of RPK from short-range market in 2019 [%].\n    medium_range_rpk_share_2019\n        Share of RPK from medium-range market in 2019 [%].\n    long_range_rpk_share_2019\n        Share of RPK from long-range market in 2019 [%].\n    covid_energy_intensity_per_ask_increase_2020\n        Increase in energy intensity per ASK due to Covid-19 for the start year [%].\n    ask_short_range\n        Number of Available Seat Kilometre (ASK) for passenger short-range market [ASK].\n    ask_medium_range\n        Number of Available Seat Kilometre (ASK) for passenger medium-range market [ASK].\n    ask_long_range\n        Number of Available Seat Kilometre (ASK) for passenger long-range market [ASK].\n\n    Returns\n    -------\n    energy_per_ask_without_operations_short_range_dropin_fuel\n        Energy consumption per ASK for passenger short-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_medium_range_dropin_fuel\n        Energy consumption per ASK for passenger medium-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_long_range_dropin_fuel\n        Energy consumption per ASK for passenger long-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_short_range_hydrogen\n        Energy consumption per ASK for passenger short-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_medium_range_hydrogen\n        Energy consumption per ASK for passenger medium-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_long_range_hydrogen\n        Energy consumption per ASK for passenger long-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_short_range_electric\n        Energy consumption per ASK for passenger short-range market aircraft using electric propulsion without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_medium_range_electric\n        Energy consumption per ASK for passenger medium-range market aircraft using electric propulsion without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_long_range_electric\n        Energy consumption per ASK for passenger long-range market aircraft using electric propulsion without considering operation improvements [MJ/ASK].\n    ask_short_range_dropin_fuel_share\n        Share of Available Seat Kilometer (ASK) for passenger short-range market from drop-in fuel aircraft [%].\n    ask_medium_range_dropin_fuel_share\n        Share of Available Seat Kilometer (ASK) for passenger medium-range market from drop-in fuel aircraft [%].\n    ask_long_range_dropin_fuel_share\n        Share of Available Seat Kilometer (ASK) for passenger long-range market from drop-in fuel aircraft [%].\n    ask_short_range_hydrogen_share\n        Share of Available Seat Kilometer (ASK) for passenger short-range market from hydrogen aircraft [%].\n    ask_medium_range_hydrogen_share\n        Share of Available Seat Kilometer (ASK) for passenger medium-range market from hydrogen aircraft [%].\n    ask_long_range_hydrogen_share\n        Share of Available Seat Kilometer (ASK) for passenger long-range market from hydrogen aircraft [%].\n    ask_short_range_electric_share\n        Share of Available Seat Kilometer (ASK) for passenger short-range market from electric aircraft [%].\n    ask_medium_range_electric_share\n        Share of Available Seat Kilometer (ASK) for passenger medium-range market from electric aircraft [%].\n    ask_long_range_electric_share\n        Share of Available Seat Kilometer (ASK) for passenger long-range market from electric aircraft [%].\n    ask_short_range_dropin_fuel\n        ASK for short-range market from drop-in fuel aircraft [ASK].\n    ask_medium_range_dropin_fuel\n        ASK for medium-range market from drop-in fuel aircraft [ASK].\n    ask_long_range_dropin_fuel\n        ASK for long-range market from drop-in fuel aircraft [ASK].\n    ask_short_range_hydrogen\n        ASK for short-range market from hydrogen aircraft [ASK].\n    ask_medium_range_hydrogen\n        ASK for medium-range market from hydrogen aircraft [ASK].\n    ask_long_range_hydrogen\n        ASK for long-range market from hydrogen aircraft [ASK].\n    ask_short_range_electric\n        ASK for short-range market from electric aircraft [ASK].\n    ask_medium_range_electric\n        ASK for medium-range market from electric aircraft [ASK].\n    ask_long_range_electric\n        ASK for long-range market from electric aircraft [ASK].\n    \"\"\"\n\n    # Pull outputs produced by the external fleet model\n    ask_short_range_dropin_fuel_share = self.fleet_model.df[\"Short Range:share:dropin_fuel\"]\n    ask_medium_range_dropin_fuel_share = self.fleet_model.df[\"Medium Range:share:dropin_fuel\"]\n    ask_long_range_dropin_fuel_share = self.fleet_model.df[\"Long Range:share:dropin_fuel\"]\n    ask_short_range_hydrogen_share = self.fleet_model.df[\"Short Range:share:hydrogen\"]\n    ask_medium_range_hydrogen_share = self.fleet_model.df[\"Medium Range:share:hydrogen\"]\n    ask_long_range_hydrogen_share = self.fleet_model.df[\"Long Range:share:hydrogen\"]\n    ask_short_range_electric_share = self.fleet_model.df[\"Short Range:share:electric\"]\n    ask_medium_range_electric_share = self.fleet_model.df[\"Medium Range:share:electric\"]\n    ask_long_range_electric_share = self.fleet_model.df[\"Long Range:share:electric\"]\n\n    energy_per_ask_without_operations_short_range_dropin_fuel = self.fleet_model.df[\n        \"Short Range:energy_consumption:dropin_fuel\"\n    ]\n    energy_per_ask_without_operations_medium_range_dropin_fuel = self.fleet_model.df[\n        \"Medium Range:energy_consumption:dropin_fuel\"\n    ]\n    energy_per_ask_without_operations_long_range_dropin_fuel = self.fleet_model.df[\n        \"Long Range:energy_consumption:dropin_fuel\"\n    ]\n    energy_per_ask_without_operations_short_range_hydrogen = self.fleet_model.df[\n        \"Short Range:energy_consumption:hydrogen\"\n    ]\n    energy_per_ask_without_operations_medium_range_hydrogen = self.fleet_model.df[\n        \"Medium Range:energy_consumption:hydrogen\"\n    ]\n    energy_per_ask_without_operations_long_range_hydrogen = self.fleet_model.df[\n        \"Long Range:energy_consumption:hydrogen\"\n    ]\n    energy_per_ask_without_operations_short_range_electric = self.fleet_model.df[\n        \"Short Range:energy_consumption:electric\"\n    ]\n    energy_per_ask_without_operations_medium_range_electric = self.fleet_model.df[\n        \"Medium Range:energy_consumption:electric\"\n    ]\n    energy_per_ask_without_operations_long_range_electric = self.fleet_model.df[\n        \"Long Range:energy_consumption:electric\"\n    ]\n\n    # Drop-in - Initialization based on 2019 share - To check for consistency\n    energy_consumption_per_ask_init = energy_consumption_init / ask\n\n    for k in range(self.historic_start_year, self.prospection_start_year):\n        self.df.loc[k, \"energy_per_ask_without_operations_short_range_dropin_fuel\"] = (\n            energy_consumption_per_ask_init.loc[k]\n            * short_range_energy_share_2019\n            / short_range_rpk_share_2019\n        )\n        self.df.loc[k, \"energy_per_ask_without_operations_medium_range_dropin_fuel\"] = (\n            energy_consumption_per_ask_init.loc[k]\n            * medium_range_energy_share_2019\n            / medium_range_rpk_share_2019\n        )\n        self.df.loc[k, \"energy_per_ask_without_operations_long_range_dropin_fuel\"] = (\n            energy_consumption_per_ask_init.loc[k]\n            * long_range_energy_share_2019\n            / long_range_rpk_share_2019\n        )\n    # Share\n    self.df[\"ask_short_range_dropin_fuel_share\"] = 100.0\n    self.df[\"ask_medium_range_dropin_fuel_share\"] = 100.0\n    self.df[\"ask_long_range_dropin_fuel_share\"] = 100.0\n\n    # Hydrogen initialization\n    # Energy consumption\n    self.df[\"energy_per_ask_without_operations_short_range_hydrogen\"] = 0.0\n    self.df[\"energy_per_ask_without_operations_medium_range_hydrogen\"] = 0.0\n    self.df[\"energy_per_ask_without_operations_long_range_hydrogen\"] = 0.0\n\n    # Share\n    self.df[\"ask_short_range_hydrogen_share\"] = 0.0\n    self.df[\"ask_medium_range_hydrogen_share\"] = 0.0\n    self.df[\"ask_long_range_hydrogen_share\"] = 0.0\n\n    # Electric initialization\n    # Energy consumption\n    self.df[\"energy_per_ask_without_operations_short_range_electric\"] = 0.0\n    self.df[\"energy_per_ask_without_operations_medium_range_electric\"] = 0.0\n    self.df[\"energy_per_ask_without_operations_long_range_electric\"] = 0.0\n\n    # Share\n    self.df[\"ask_short_range_electric_share\"] = 0.0\n    self.df[\"ask_medium_range_electric_share\"] = 0.0\n    self.df[\"ask_long_range_electric_share\"] = 0.0\n\n    # Hybrid-electric initialization\n    # Energy consumption\n    self.df[\"energy_per_ask_without_operations_short_range_hybrid_electric\"] = 0.0\n    self.df[\"energy_per_ask_without_operations_medium_range_hybrid_electric\"] = 0.0\n    self.df[\"energy_per_ask_without_operations_long_range_hybrid_electric\"] = 0.0\n\n    # Share\n    self.df[\"ask_short_range_hybrid_electric_share\"] = 0.0\n    self.df[\"ask_medium_range_hybrid_electric_share\"] = 0.0\n    self.df[\"ask_long_range_hybrid_electric_share\"] = 0.0\n\n    # Drop-in - Projections\n    for k in range(self.prospection_start_year, self.end_year + 1):\n        self.df.loc[k, \"energy_per_ask_without_operations_short_range_dropin_fuel\"] = (\n            energy_per_ask_without_operations_short_range_dropin_fuel.loc[k]\n        )\n        self.df.loc[k, \"energy_per_ask_without_operations_medium_range_dropin_fuel\"] = (\n            energy_per_ask_without_operations_medium_range_dropin_fuel.loc[k]\n        )\n        self.df.loc[k, \"energy_per_ask_without_operations_long_range_dropin_fuel\"] = (\n            energy_per_ask_without_operations_long_range_dropin_fuel.loc[k]\n        )\n\n    self.df.loc[2020, \"energy_per_ask_without_operations_short_range_dropin_fuel\"] = (\n        self.df.loc[2019, \"energy_per_ask_without_operations_short_range_dropin_fuel\"]\n        * (1 + covid_energy_intensity_per_ask_increase_2020 / 100)\n    )\n    self.df.loc[2020, \"energy_per_ask_without_operations_medium_range_dropin_fuel\"] = (\n        self.df.loc[2019, \"energy_per_ask_without_operations_medium_range_dropin_fuel\"]\n        * (1 + covid_energy_intensity_per_ask_increase_2020 / 100)\n    )\n    self.df.loc[2020, \"energy_per_ask_without_operations_long_range_dropin_fuel\"] = self.df.loc[\n        2019, \"energy_per_ask_without_operations_long_range_dropin_fuel\"\n    ] * (1 + covid_energy_intensity_per_ask_increase_2020 / 100)\n\n    energy_per_ask_without_operations_short_range_dropin_fuel = self.df[\n        \"energy_per_ask_without_operations_short_range_dropin_fuel\"\n    ]\n    energy_per_ask_without_operations_medium_range_dropin_fuel = self.df[\n        \"energy_per_ask_without_operations_medium_range_dropin_fuel\"\n    ]\n    energy_per_ask_without_operations_long_range_dropin_fuel = self.df[\n        \"energy_per_ask_without_operations_long_range_dropin_fuel\"\n    ]\n\n    # Hydrogen\n    for k in range(self.prospection_start_year + 1, self.end_year + 1):\n        self.df.loc[k, \"energy_per_ask_without_operations_short_range_hydrogen\"] = (\n            energy_per_ask_without_operations_short_range_hydrogen.loc[k]\n        )\n        self.df.loc[k, \"energy_per_ask_without_operations_medium_range_hydrogen\"] = (\n            energy_per_ask_without_operations_medium_range_hydrogen.loc[k]\n        )\n        self.df.loc[k, \"energy_per_ask_without_operations_long_range_hydrogen\"] = (\n            energy_per_ask_without_operations_long_range_hydrogen.loc[k]\n        )\n\n    energy_per_ask_without_operations_short_range_hydrogen = self.df[\n        \"energy_per_ask_without_operations_short_range_hydrogen\"\n    ]\n    energy_per_ask_without_operations_medium_range_hydrogen = self.df[\n        \"energy_per_ask_without_operations_medium_range_hydrogen\"\n    ]\n    energy_per_ask_without_operations_long_range_hydrogen = self.df[\n        \"energy_per_ask_without_operations_long_range_hydrogen\"\n    ]\n\n    # Electric\n    for k in range(self.prospection_start_year + 1, self.end_year + 1):\n        self.df.loc[k, \"energy_per_ask_without_operations_short_range_electric\"] = (\n            energy_per_ask_without_operations_short_range_electric.loc[k]\n        )\n        self.df.loc[k, \"energy_per_ask_without_operations_medium_range_electric\"] = (\n            energy_per_ask_without_operations_medium_range_electric.loc[k]\n        )\n        self.df.loc[k, \"energy_per_ask_without_operations_long_range_electric\"] = (\n            energy_per_ask_without_operations_long_range_electric.loc[k]\n        )\n\n    energy_per_ask_without_operations_short_range_electric = self.df[\n        \"energy_per_ask_without_operations_short_range_electric\"\n    ]\n    energy_per_ask_without_operations_medium_range_electric = self.df[\n        \"energy_per_ask_without_operations_medium_range_electric\"\n    ]\n    energy_per_ask_without_operations_long_range_electric = self.df[\n        \"energy_per_ask_without_operations_long_range_electric\"\n    ]\n\n    # Share\n    self.df.loc[\n        self.prospection_start_year : self.end_year + 1, \"ask_short_range_dropin_fuel_share\"\n    ] = ask_short_range_dropin_fuel_share\n    self.df.loc[\n        self.prospection_start_year : self.end_year + 1, \"ask_medium_range_dropin_fuel_share\"\n    ] = ask_medium_range_dropin_fuel_share\n    self.df.loc[\n        self.prospection_start_year : self.end_year + 1, \"ask_long_range_dropin_fuel_share\"\n    ] = ask_long_range_dropin_fuel_share\n    self.df.loc[\n        self.prospection_start_year : self.end_year + 1, \"ask_short_range_hydrogen_share\"\n    ] = ask_short_range_hydrogen_share\n    self.df.loc[\n        self.prospection_start_year : self.end_year + 1, \"ask_medium_range_hydrogen_share\"\n    ] = ask_medium_range_hydrogen_share\n    self.df.loc[\n        self.prospection_start_year : self.end_year + 1, \"ask_long_range_hydrogen_share\"\n    ] = ask_long_range_hydrogen_share\n    self.df.loc[\n        self.prospection_start_year : self.end_year + 1, \"ask_short_range_electric_share\"\n    ] = ask_short_range_electric_share\n    self.df.loc[\n        self.prospection_start_year : self.end_year + 1, \"ask_medium_range_electric_share\"\n    ] = ask_medium_range_electric_share\n    self.df.loc[\n        self.prospection_start_year : self.end_year + 1, \"ask_long_range_electric_share\"\n    ] = ask_long_range_electric_share\n    # ASK\n    ask_short_range_dropin_fuel = (\n        ask_short_range * self.df[\"ask_short_range_dropin_fuel_share\"] / 100\n    )\n    ask_medium_range_dropin_fuel = (\n        ask_medium_range * self.df[\"ask_medium_range_dropin_fuel_share\"] / 100\n    )\n    ask_long_range_dropin_fuel = (\n        ask_long_range * self.df[\"ask_long_range_dropin_fuel_share\"] / 100\n    )\n    ask_short_range_hydrogen = ask_short_range * self.df[\"ask_short_range_hydrogen_share\"] / 100\n    ask_medium_range_hydrogen = (\n        ask_medium_range * self.df[\"ask_medium_range_hydrogen_share\"] / 100\n    )\n    ask_long_range_hydrogen = ask_long_range * self.df[\"ask_long_range_hydrogen_share\"] / 100\n    ask_short_range_electric = ask_short_range * self.df[\"ask_short_range_electric_share\"] / 100\n    ask_medium_range_electric = (\n        ask_medium_range * self.df[\"ask_medium_range_electric_share\"] / 100\n    )\n    ask_long_range_electric = ask_long_range * self.df[\"ask_long_range_electric_share\"] / 100\n\n    self.df.loc[:, \"ask_short_range_dropin_fuel\"] = ask_short_range_dropin_fuel\n    self.df.loc[:, \"ask_medium_range_dropin_fuel\"] = ask_medium_range_dropin_fuel\n    self.df.loc[:, \"ask_long_range_dropin_fuel\"] = ask_long_range_dropin_fuel\n    self.df.loc[:, \"ask_short_range_hydrogen\"] = ask_short_range_hydrogen\n    self.df.loc[:, \"ask_medium_range_hydrogen\"] = ask_medium_range_hydrogen\n    self.df.loc[:, \"ask_long_range_hydrogen\"] = ask_long_range_hydrogen\n    self.df.loc[:, \"ask_short_range_electric\"] = ask_short_range_electric\n    self.df.loc[:, \"ask_medium_range_electric\"] = ask_medium_range_electric\n    self.df.loc[:, \"ask_long_range_electric\"] = ask_long_range_electric\n\n    ask_dropin_fuel = (\n        ask_short_range_dropin_fuel + ask_medium_range_dropin_fuel + ask_long_range_dropin_fuel\n    )\n    ask_hydrogen = (\n        ask_short_range_hydrogen + ask_medium_range_hydrogen + ask_long_range_hydrogen\n    )\n    ask_electric = (\n        ask_short_range_electric + ask_medium_range_electric + ask_long_range_electric\n    )\n\n    self.df.loc[:, \"ask_dropin_fuel\"] = ask_dropin_fuel\n    self.df.loc[:, \"ask_hydrogen\"] = ask_hydrogen\n    self.df.loc[:, \"ask_electric\"] = ask_electric\n\n    return (\n        energy_per_ask_without_operations_short_range_dropin_fuel,\n        energy_per_ask_without_operations_medium_range_dropin_fuel,\n        energy_per_ask_without_operations_long_range_dropin_fuel,\n        energy_per_ask_without_operations_short_range_hydrogen,\n        energy_per_ask_without_operations_medium_range_hydrogen,\n        energy_per_ask_without_operations_long_range_hydrogen,\n        energy_per_ask_without_operations_short_range_electric,\n        energy_per_ask_without_operations_medium_range_electric,\n        energy_per_ask_without_operations_long_range_electric,\n        ask_short_range_dropin_fuel_share,\n        ask_medium_range_dropin_fuel_share,\n        ask_long_range_dropin_fuel_share,\n        ask_short_range_hydrogen_share,\n        ask_medium_range_hydrogen_share,\n        ask_long_range_hydrogen_share,\n        ask_short_range_electric_share,\n        ask_medium_range_electric_share,\n        ask_long_range_electric_share,\n        ask_short_range_dropin_fuel,\n        ask_medium_range_dropin_fuel,\n        ask_long_range_dropin_fuel,\n        ask_short_range_hydrogen,\n        ask_medium_range_hydrogen,\n        ask_long_range_hydrogen,\n        ask_short_range_electric,\n        ask_medium_range_electric,\n        ask_long_range_electric,\n        ask_dropin_fuel,\n        ask_hydrogen,\n        ask_electric,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.aircraft_efficiency/#aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.aircraft_efficiency.FreightAircraftEfficiency","title":"FreightAircraftEfficiency","text":"<pre><code>FreightAircraftEfficiency(name='freight_aircraft_efficiency', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute energy consumption per RTK (without operations) for freight aircraft.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('freight_aircraft_efficiency' by default).</p> <code>'freight_aircraft_efficiency'</code> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/fleet/aircraft_efficiency.py</code> <pre><code>def __init__(self, name=\"freight_aircraft_efficiency\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.aircraft_efficiency/#aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.aircraft_efficiency.FreightAircraftEfficiency.compute","title":"compute","text":"<pre><code>compute(energy_consumption_init, rtk, freight_energy_share_2019, energy_per_ask_without_operations_short_range_dropin_fuel, energy_per_ask_without_operations_medium_range_dropin_fuel, energy_per_ask_without_operations_long_range_dropin_fuel, energy_per_ask_without_operations_short_range_hydrogen, energy_per_ask_without_operations_medium_range_hydrogen, energy_per_ask_without_operations_long_range_hydrogen, energy_per_ask_without_operations_short_range_electric, energy_per_ask_without_operations_medium_range_electric, energy_per_ask_without_operations_long_range_electric, ask, ask_short_range, ask_medium_range, ask_long_range, ask_short_range_dropin_fuel, ask_medium_range_dropin_fuel, ask_long_range_dropin_fuel, ask_short_range_hydrogen_share, ask_medium_range_hydrogen_share, ask_long_range_hydrogen_share, ask_short_range_electric_share, ask_medium_range_electric_share, ask_long_range_electric_share, covid_energy_intensity_per_ask_increase_2020)\n</code></pre> <p>Compute energy consumption per RTK (without operations) for freight aircraft.</p> <p>Parameters:</p> Name Type Description Default <code>energy_consumption_init</code> <code>Series</code> <p>Historical energy consumption of aviation over 2000-2019 [MJ].</p> required <code>rtk</code> <code>Series</code> <p>Number of Revenue Tonne Kilometer (RTK) for freight air transport [RTK].</p> required <code>freight_energy_share_2019</code> <code>float</code> <p>Share of aviation energy consumed by freight market in 2019 [%].</p> required <code>energy_per_ask_without_operations_short_range_dropin_fuel</code> <code>Series</code> <p>Energy consumption per ASK for passenger short-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].</p> required <code>energy_per_ask_without_operations_medium_range_dropin_fuel</code> <code>Series</code> <p>Energy consumption per ASK for passenger medium-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].</p> required <code>energy_per_ask_without_operations_long_range_dropin_fuel</code> <code>Series</code> <p>Energy consumption per ASK for passenger long-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].</p> required <code>energy_per_ask_without_operations_short_range_hydrogen</code> <code>Series</code> <p>Energy consumption per ASK for passenger short-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].</p> required <code>energy_per_ask_without_operations_medium_range_hydrogen</code> <code>Series</code> <p>Energy consumption per ASK for passenger medium-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].</p> required <code>energy_per_ask_without_operations_long_range_hydrogen</code> <code>Series</code> <p>Energy consumption per ASK for passenger long-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].</p> required <code>energy_per_ask_without_operations_short_range_electric</code> <code>Series</code> <p>Energy consumption per ASK for passenger short-range market aircraft using electric propulsion without considering operation improvements [MJ/ASK].</p> required <code>energy_per_ask_without_operations_medium_range_electric</code> <code>Series</code> <p>Energy consumption per ASK for passenger medium-range market aircraft using electric propulsion without considering operation improvements [MJ/ASK].</p> required <code>energy_per_ask_without_operations_long_range_electric</code> <code>Series</code> <p>Energy consumption per ASK for passenger long-range market aircraft using electric propulsion without considering operation improvements [MJ/ASK].</p> required <code>ask</code> <code>Series</code> <p>Number of Available Seat Kilometre (ASK) for all commercial air transport [ASK].</p> required <code>ask_short_range</code> <code>Series</code> <p>Number of Available Seat Kilometre (ASK) for passenger short-range market [ASK].</p> required <code>ask_medium_range</code> <code>Series</code> <p>Number of Available Seat Kilometre (ASK) for passenger medium-range market [ASK].</p> required <code>ask_long_range</code> <code>Series</code> <p>Number of Available Seat Kilometre (ASK) for passenger long-range market [ASK].</p> required <code>ask_short_range_dropin_fuel</code> <code>Series</code> <p>ASK for short-range market from drop-in fuel aircraft [ASK].</p> required <code>ask_medium_range_dropin_fuel</code> <code>Series</code> <p>ASK for medium-range market from drop-in fuel aircraft [ASK].</p> required <code>ask_long_range_dropin_fuel</code> <code>Series</code> <p>ASK for long-range market from drop-in fuel aircraft [ASK].</p> required <code>ask_short_range_hydrogen_share</code> <code>Series</code> <p>Share of Available Seat Kilometre (ASK) for passenger short-range market from hydrogen aircraft [%].</p> required <code>ask_medium_range_hydrogen_share</code> <code>Series</code> <p>Share of Available Seat Kilometre (ASK) for passenger medium-range market from hydrogen aircraft [%].</p> required <code>ask_long_range_hydrogen_share</code> <code>Series</code> <p>Share of Available Seat Kilometre (ASK) for passenger long-range market from hydrogen aircraft [%].</p> required <code>ask_short_range_electric_share</code> <code>Series</code> <p>Share of Available Seat Kilometre (ASK) for passenger short-range market from electric aircraft [%].</p> required <code>ask_medium_range_electric_share</code> <code>Series</code> <p>Share of Available Seat Kilometre (ASK) for passenger medium-range market from electric aircraft [%].</p> required <code>ask_long_range_electric_share</code> <code>Series</code> <p>Share of Available Seat Kilometre (ASK) for passenger long-range market from electric aircraft [%].</p> required <code>covid_energy_intensity_per_ask_increase_2020</code> <code>float</code> <p>Increase in energy intensity per ASK due to Covid-19 for the start year [%].</p> required <p>Returns:</p> Type Description <code>energy_per_rtk_without_operations_freight_dropin_fuel</code> <p>Energy consumption per RTK for freight market aircraft using drop-in fuel without considering operation improvements [MJ/RTK].</p> <code>energy_per_rtk_without_operations_freight_hydrogen</code> <p>Energy consumption per RTK for freight market aircraft using hydrogen without considering operation improvements [MJ/RTK].</p> <code>energy_per_rtk_without_operations_freight_electric</code> <p>Energy consumption per RTK for freight market aircraft using electric propulsion without considering operation improvements [MJ/RTK].</p> <code>rtk_dropin_fuel_share</code> <p>Share of Revenue Tonne Kilometer (RTK) for freight air transport from drop-in fuel aircraft [%].</p> <code>rtk_hydrogen_share</code> <p>Share of Revenue Tonne Kilometer (RTK) for freight air transport from hydrogen aircraft [%].</p> <code>rtk_electric_share</code> <p>Share of Revenue Tonne Kilometer (RTK) for freight air transport from electric aircraft [%].</p> <code>rtk_dropin_fuel</code> <p>Number of Revenue Tonne Kilometer (RTK) for freight air transport from drop-in fuel aircraft [RTK].</p> <code>rtk_hydrogen</code> <p>Number of Revenue Tonne Kilometer (RTK) for freight air transport from hydrogen aircraft [RTK].</p> <code>rtk_electric</code> <p>Number of Revenue Tonne Kilometer (RTK) for freight air transport from electric aircraft [RTK].</p> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/fleet/aircraft_efficiency.py</code> <pre><code>def compute(\n    self,\n    energy_consumption_init: pd.Series,\n    rtk: pd.Series,\n    freight_energy_share_2019: float,\n    energy_per_ask_without_operations_short_range_dropin_fuel: pd.Series,\n    energy_per_ask_without_operations_medium_range_dropin_fuel: pd.Series,\n    energy_per_ask_without_operations_long_range_dropin_fuel: pd.Series,\n    energy_per_ask_without_operations_short_range_hydrogen: pd.Series,\n    energy_per_ask_without_operations_medium_range_hydrogen: pd.Series,\n    energy_per_ask_without_operations_long_range_hydrogen: pd.Series,\n    energy_per_ask_without_operations_short_range_electric: pd.Series,\n    energy_per_ask_without_operations_medium_range_electric: pd.Series,\n    energy_per_ask_without_operations_long_range_electric: pd.Series,\n    ask: pd.Series,\n    ask_short_range: pd.Series,\n    ask_medium_range: pd.Series,\n    ask_long_range: pd.Series,\n    ask_short_range_dropin_fuel: pd.Series,\n    ask_medium_range_dropin_fuel: pd.Series,\n    ask_long_range_dropin_fuel: pd.Series,\n    ask_short_range_hydrogen_share: pd.Series,\n    ask_medium_range_hydrogen_share: pd.Series,\n    ask_long_range_hydrogen_share: pd.Series,\n    ask_short_range_electric_share: pd.Series,\n    ask_medium_range_electric_share: pd.Series,\n    ask_long_range_electric_share: pd.Series,\n    covid_energy_intensity_per_ask_increase_2020: float,\n) -&gt; Tuple[\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n]:\n    \"\"\"\n    Compute energy consumption per RTK (without operations) for freight aircraft.\n\n    Parameters\n    ----------\n    energy_consumption_init\n        Historical energy consumption of aviation over 2000-2019 [MJ].\n    rtk\n        Number of Revenue Tonne Kilometer (RTK) for freight air transport [RTK].\n    freight_energy_share_2019\n        Share of aviation energy consumed by freight market in 2019 [%].\n    energy_per_ask_without_operations_short_range_dropin_fuel\n        Energy consumption per ASK for passenger short-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_medium_range_dropin_fuel\n        Energy consumption per ASK for passenger medium-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_long_range_dropin_fuel\n        Energy consumption per ASK for passenger long-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_short_range_hydrogen\n        Energy consumption per ASK for passenger short-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_medium_range_hydrogen\n        Energy consumption per ASK for passenger medium-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_long_range_hydrogen\n        Energy consumption per ASK for passenger long-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_short_range_electric\n        Energy consumption per ASK for passenger short-range market aircraft using electric propulsion without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_medium_range_electric\n        Energy consumption per ASK for passenger medium-range market aircraft using electric propulsion without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_long_range_electric\n        Energy consumption per ASK for passenger long-range market aircraft using electric propulsion without considering operation improvements [MJ/ASK].\n    ask\n        Number of Available Seat Kilometre (ASK) for all commercial air transport [ASK].\n    ask_short_range\n        Number of Available Seat Kilometre (ASK) for passenger short-range market [ASK].\n    ask_medium_range\n        Number of Available Seat Kilometre (ASK) for passenger medium-range market [ASK].\n    ask_long_range\n        Number of Available Seat Kilometre (ASK) for passenger long-range market [ASK].\n    ask_short_range_dropin_fuel\n        ASK for short-range market from drop-in fuel aircraft [ASK].\n    ask_medium_range_dropin_fuel\n        ASK for medium-range market from drop-in fuel aircraft [ASK].\n    ask_long_range_dropin_fuel\n        ASK for long-range market from drop-in fuel aircraft [ASK].\n    ask_short_range_hydrogen_share\n        Share of Available Seat Kilometre (ASK) for passenger short-range market from hydrogen aircraft [%].\n    ask_medium_range_hydrogen_share\n        Share of Available Seat Kilometre (ASK) for passenger medium-range market from hydrogen aircraft [%].\n    ask_long_range_hydrogen_share\n        Share of Available Seat Kilometre (ASK) for passenger long-range market from hydrogen aircraft [%].\n    ask_short_range_electric_share\n        Share of Available Seat Kilometre (ASK) for passenger short-range market from electric aircraft [%].\n    ask_medium_range_electric_share\n        Share of Available Seat Kilometre (ASK) for passenger medium-range market from electric aircraft [%].\n    ask_long_range_electric_share\n        Share of Available Seat Kilometre (ASK) for passenger long-range market from electric aircraft [%].\n    covid_energy_intensity_per_ask_increase_2020\n        Increase in energy intensity per ASK due to Covid-19 for the start year [%].\n\n    Returns\n    -------\n    energy_per_rtk_without_operations_freight_dropin_fuel\n        Energy consumption per RTK for freight market aircraft using drop-in fuel without considering operation improvements [MJ/RTK].\n    energy_per_rtk_without_operations_freight_hydrogen\n        Energy consumption per RTK for freight market aircraft using hydrogen without considering operation improvements [MJ/RTK].\n    energy_per_rtk_without_operations_freight_electric\n        Energy consumption per RTK for freight market aircraft using electric propulsion without considering operation improvements [MJ/RTK].\n    rtk_dropin_fuel_share\n        Share of Revenue Tonne Kilometer (RTK) for freight air transport from drop-in fuel aircraft [%].\n    rtk_hydrogen_share\n        Share of Revenue Tonne Kilometer (RTK) for freight air transport from hydrogen aircraft [%].\n    rtk_electric_share\n        Share of Revenue Tonne Kilometer (RTK) for freight air transport from electric aircraft [%].\n    rtk_dropin_fuel\n        Number of Revenue Tonne Kilometer (RTK) for freight air transport from drop-in fuel aircraft [RTK].\n    rtk_hydrogen\n        Number of Revenue Tonne Kilometer (RTK) for freight air transport from hydrogen aircraft [RTK].\n    rtk_electric\n        Number of Revenue Tonne Kilometer (RTK) for freight air transport from electric aircraft [RTK].\n    \"\"\"\n\n    # Initialization based on 2019 share: to correct to include load factor\n    hist_years = list(range(self.historic_start_year, self.prospection_start_year))\n    self.df.loc[hist_years, \"energy_per_rtk_without_operations_freight_dropin_fuel\"] = (\n        energy_consumption_init.loc[hist_years]\n        / rtk.loc[hist_years]\n        * freight_energy_share_2019\n        / 100\n    )\n\n    # Projections\n    init_energy_per_rtk_without_operations_freight_dropin_fuel = self.df.loc[\n        2019, \"energy_per_rtk_without_operations_freight_dropin_fuel\"\n    ]\n    energy_per_rtk_without_operations_freight_dropin_fuel_short_range_k = (\n        init_energy_per_rtk_without_operations_freight_dropin_fuel.copy()\n    )\n    energy_per_rtk_without_operations_freight_dropin_fuel_medium_range_k = (\n        init_energy_per_rtk_without_operations_freight_dropin_fuel.copy()\n    )\n    energy_per_rtk_without_operations_freight_dropin_fuel_long_range_k = (\n        init_energy_per_rtk_without_operations_freight_dropin_fuel.copy()\n    )\n\n    for k in range(self.prospection_start_year, self.end_year + 1):\n        energy_per_rtk_without_operations_freight_dropin_fuel_short_range_k = (\n            energy_per_rtk_without_operations_freight_dropin_fuel_short_range_k\n            * energy_per_ask_without_operations_short_range_dropin_fuel.loc[k]\n            / energy_per_ask_without_operations_short_range_dropin_fuel.loc[k - 1]\n        )\n        energy_per_rtk_without_operations_freight_dropin_fuel_medium_range_k = (\n            energy_per_rtk_without_operations_freight_dropin_fuel_medium_range_k\n            * energy_per_ask_without_operations_medium_range_dropin_fuel.loc[k]\n            / energy_per_ask_without_operations_medium_range_dropin_fuel.loc[k - 1]\n        )\n        energy_per_rtk_without_operations_freight_dropin_fuel_long_range_k = (\n            energy_per_rtk_without_operations_freight_dropin_fuel_long_range_k\n            * energy_per_ask_without_operations_long_range_dropin_fuel.loc[k]\n            / energy_per_ask_without_operations_long_range_dropin_fuel.loc[k - 1]\n        )\n\n        # local variables to avoid multiple locs\n        ask_short_range_dropin_fuel_k = ask_short_range_dropin_fuel.loc[k]\n        ask_medium_range_dropin_fuel_k = ask_medium_range_dropin_fuel.loc[k]\n        ask_long_range_dropin_fuel_k = ask_long_range_dropin_fuel.loc[k]\n        ask_total_dropin_fuel_k = (\n            ask_short_range_dropin_fuel_k\n            + ask_medium_range_dropin_fuel_k\n            + ask_long_range_dropin_fuel_k\n        )\n\n        self.df.loc[k, \"energy_per_rtk_without_operations_freight_dropin_fuel\"] = (\n            energy_per_rtk_without_operations_freight_dropin_fuel_short_range_k\n            * ask_short_range_dropin_fuel_k\n            / (ask_total_dropin_fuel_k)\n            + energy_per_rtk_without_operations_freight_dropin_fuel_medium_range_k\n            * ask_medium_range_dropin_fuel_k\n            / (ask_total_dropin_fuel_k)\n            + energy_per_rtk_without_operations_freight_dropin_fuel_long_range_k\n            * ask_long_range_dropin_fuel_k\n            / (ask_total_dropin_fuel_k)\n        )\n\n    # Covid\n    self.df.loc[2020, \"energy_per_rtk_without_operations_freight_dropin_fuel\"] = self.df.loc[\n        2019, \"energy_per_rtk_without_operations_freight_dropin_fuel\"\n    ] * (1 + covid_energy_intensity_per_ask_increase_2020 / 100)\n\n    energy_per_rtk_without_operations_freight_dropin_fuel = self.df[\n        \"energy_per_rtk_without_operations_freight_dropin_fuel\"\n    ]\n\n    rtk_hydrogen_share = (\n        ask_short_range_hydrogen_share * (ask_short_range / ask)\n        + ask_medium_range_hydrogen_share * (ask_medium_range / ask)\n        + ask_long_range_hydrogen_share * (ask_long_range / ask)\n    )\n    rtk_electric_share = (\n        ask_short_range_electric_share * (ask_short_range / ask)\n        + ask_medium_range_electric_share * (ask_medium_range / ask)\n        + ask_long_range_electric_share * (ask_long_range / ask)\n    )\n    rtk_dropin_fuel_share = 100 - rtk_hydrogen_share - rtk_electric_share\n    self.df.loc[:, \"rtk_hydrogen_share\"] = rtk_hydrogen_share\n    self.df.loc[:, \"rtk_dropin_fuel_share\"] = rtk_dropin_fuel_share\n    self.df.loc[:, \"rtk_electric_share\"] = rtk_electric_share\n\n    rtk_hydrogen = rtk * rtk_hydrogen_share / 100\n    rtk_electric = rtk * rtk_electric_share / 100\n    rtk_dropin_fuel = rtk * rtk_dropin_fuel_share / 100\n    self.df.loc[:, \"rtk_hydrogen\"] = rtk_hydrogen\n    self.df.loc[:, \"rtk_dropin_fuel\"] = rtk_dropin_fuel\n    self.df.loc[:, \"rtk_electric\"] = rtk_electric\n\n    relative_energy_per_ask_hydrogen_wrt_dropin_short_range = (\n        energy_per_ask_without_operations_short_range_hydrogen\n        / energy_per_ask_without_operations_short_range_dropin_fuel\n    )\n    relative_energy_per_ask_hydrogen_wrt_dropin_medium_range = (\n        energy_per_ask_without_operations_medium_range_hydrogen\n        / energy_per_ask_without_operations_medium_range_dropin_fuel\n    )\n    relative_energy_per_ask_hydrogen_wrt_dropin_long_range = (\n        energy_per_ask_without_operations_long_range_hydrogen\n        / energy_per_ask_without_operations_long_range_dropin_fuel\n    )\n\n    relative_energy_per_ask_electric_wrt_dropin_short_range = (\n        energy_per_ask_without_operations_short_range_electric\n        / energy_per_ask_without_operations_short_range_dropin_fuel\n    )\n    relative_energy_per_ask_electric_wrt_dropin_medium_range = (\n        energy_per_ask_without_operations_medium_range_electric\n        / energy_per_ask_without_operations_medium_range_dropin_fuel\n    )\n    relative_energy_per_ask_electric_wrt_dropin_long_range = (\n        energy_per_ask_without_operations_long_range_electric\n        / energy_per_ask_without_operations_long_range_dropin_fuel\n    )\n\n    # Vectorized computation for hydrogen =&gt; direct affectation of dropin fuel average if not used. Strange but kept old way of doing.\n    hydrogen_zero_mask = rtk_hydrogen_share == 0\n    hydrogen_nonzero_mask = ~hydrogen_zero_mask\n\n    self.df.loc[hydrogen_zero_mask, \"energy_per_rtk_without_operations_freight_hydrogen\"] = (\n        self.df.loc[hydrogen_zero_mask, \"energy_per_rtk_without_operations_freight_dropin_fuel\"]\n    )\n\n    hydrogen_weighted_sum = (\n        relative_energy_per_ask_hydrogen_wrt_dropin_short_range\n        * ask_short_range_hydrogen_share\n        * (ask_short_range / ask)\n        + relative_energy_per_ask_hydrogen_wrt_dropin_medium_range\n        * ask_medium_range_hydrogen_share\n        * (ask_medium_range / ask)\n        + relative_energy_per_ask_hydrogen_wrt_dropin_long_range\n        * ask_long_range_hydrogen_share\n        * (ask_long_range / ask)\n    ) / rtk_hydrogen_share.loc[hydrogen_nonzero_mask]\n\n    self.df.loc[hydrogen_nonzero_mask, \"energy_per_rtk_without_operations_freight_hydrogen\"] = (\n        energy_per_rtk_without_operations_freight_dropin_fuel.loc[hydrogen_nonzero_mask]\n        * hydrogen_weighted_sum.loc[hydrogen_nonzero_mask]\n    )\n\n    # Vectorized computation for electric\n    electric_zero_mask = rtk_electric_share == 0\n    electric_nonzero_mask = ~electric_zero_mask\n\n    self.df.loc[electric_zero_mask, \"energy_per_rtk_without_operations_freight_electric\"] = (\n        self.df.loc[electric_zero_mask, \"energy_per_rtk_without_operations_freight_dropin_fuel\"]\n    )\n\n    electric_weighted_sum = (\n        relative_energy_per_ask_electric_wrt_dropin_short_range\n        * ask_short_range_electric_share\n        * (ask_short_range / ask)\n        + relative_energy_per_ask_electric_wrt_dropin_medium_range\n        * ask_medium_range_electric_share\n        * (ask_medium_range / ask)\n        + relative_energy_per_ask_electric_wrt_dropin_long_range\n        * ask_long_range_electric_share\n        * (ask_long_range / ask)\n    ) / rtk_electric_share.loc[electric_nonzero_mask]\n\n    self.df.loc[electric_nonzero_mask, \"energy_per_rtk_without_operations_freight_electric\"] = (\n        energy_per_rtk_without_operations_freight_dropin_fuel.loc[electric_nonzero_mask]\n        * electric_weighted_sum.loc[electric_nonzero_mask]\n    )\n\n    energy_per_rtk_without_operations_freight_hydrogen = self.df[\n        \"energy_per_rtk_without_operations_freight_hydrogen\"\n    ]\n    energy_per_rtk_without_operations_freight_electric = self.df[\n        \"energy_per_rtk_without_operations_freight_electric\"\n    ]\n    return (\n        energy_per_rtk_without_operations_freight_dropin_fuel,\n        energy_per_rtk_without_operations_freight_hydrogen,\n        energy_per_rtk_without_operations_freight_electric,\n        rtk_dropin_fuel_share,\n        rtk_hydrogen_share,\n        rtk_electric_share,\n        rtk_dropin_fuel,\n        rtk_hydrogen,\n        rtk_electric,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.fleet_model/","title":"<code>aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.fleet_model</code>","text":""},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.fleet_numeric/","title":"<code>aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.fleet_numeric</code>","text":""},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.fleet_numeric/#aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.fleet_numeric.filter_columns","title":"filter_columns","text":"<pre><code>filter_columns(df, prefix, suffix)\n</code></pre> <p>Filters columns of a dataframe by prefix and suffix</p> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/fleet/fleet_numeric.py</code> <pre><code>def filter_columns(df, prefix, suffix):\n    \"\"\"\n    Filters columns of a dataframe by prefix and suffix\n    \"\"\"\n    return [col for col in df.columns if col.startswith(prefix) and col.endswith(suffix)]\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.fleet_numeric/#aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.fleet_numeric.sum_positive","title":"sum_positive","text":"<pre><code>sum_positive(row)\n</code></pre> <p>Calculates the sum of positive values in a row of a dataframe</p> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/fleet/fleet_numeric.py</code> <pre><code>def sum_positive(row):\n    \"\"\"\n    Calculates the sum of positive values in a row of a dataframe\n    \"\"\"\n    return row[row &gt; 0].sum()\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.fleet_numeric/#aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet.fleet_numeric.sum_negative","title":"sum_negative","text":"<pre><code>sum_negative(row)\n</code></pre> <p>Calculates the absolute sum of negative values in a row of a dataframe</p> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/fleet/fleet_numeric.py</code> <pre><code>def sum_negative(row):\n    \"\"\"\n    Calculates the absolute sum of negative values in a row of a dataframe\n    \"\"\"\n    return abs(row[row &lt; 0].sum())\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet/","title":"<code>aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet</code>","text":""},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet/#aeromaps.models.air_transport.aircraft_fleet_and_operations.fleet--fleet","title":"fleet","text":"<p>This package contains models related to fleet management and efficiency.</p> Warning <p>Incomplete documentation for this package, due to ongoing works on generic fleet model.</p>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.load_factor.load_factor/","title":"<code>aeromaps.models.air_transport.aircraft_fleet_and_operations.load_factor.load_factor</code>","text":""},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.load_factor.load_factor/#aeromaps.models.air_transport.aircraft_fleet_and_operations.load_factor.load_factor--load_factor","title":"load_factor","text":"<p>Module for computing aircraft load factor evolution</p>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.load_factor.load_factor/#aeromaps.models.air_transport.aircraft_fleet_and_operations.load_factor.load_factor.LoadFactor","title":"LoadFactor","text":"<pre><code>LoadFactor(name='load_factor', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Model for computing aircraft load factor evolution based on user's inputs.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('load_factor' by default).</p> <code>'load_factor'</code> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/load_factor/load_factor.py</code> <pre><code>def __init__(self, name=\"load_factor\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.load_factor.load_factor/#aeromaps.models.air_transport.aircraft_fleet_and_operations.load_factor.load_factor.LoadFactor.compute","title":"compute","text":"<pre><code>compute(load_factor_end_year, covid_load_factor_2020, rpk, ask_init)\n</code></pre> <p>Execute the computation of aircraft load factor.</p> <p>Historical load factor values are computed from provided RPK and historical ASK, initializes the 2019 load factor as a baseline, then projects load factor forward to <code>end_year</code> using a quadratic model. The 2020 value is overwritten with a Covid-19-specific value.</p> <p>Parameters:</p> Name Type Description Default <code>load_factor_end_year</code> <code>float</code> <p>Value of mean aircraft load factor in the considered end year [%].</p> required <code>covid_load_factor_2020</code> <code>float</code> <p>Load factor due to Covid-19 for the start_year [%].</p> required <code>rpk</code> <code>Series</code> <p>Total number of Revenue Passenger Kilometer (RPK).</p> required <code>ask_init</code> <code>Series</code> <p>Historical number of Available Seat Kilometer (ASK) over 2000-2019 [ASK].</p> required <p>Returns:</p> Type Description <code>load_factor</code> <p>Mean aircraft load factor for each year of the model period [%].</p> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/load_factor/load_factor.py</code> <pre><code>def compute(\n    self,\n    load_factor_end_year: float,\n    covid_load_factor_2020: float,\n    rpk: pd.Series,\n    ask_init: pd.Series,\n) -&gt; pd.Series:\n    \"\"\"Execute the computation of aircraft load factor.\n\n    Historical load factor values are computed from provided RPK and\n    historical ASK, initializes the 2019 load factor as a baseline, then\n    projects load factor forward to `end_year` using a quadratic model.\n    The 2020 value is overwritten with a Covid-19-specific value.\n\n    Parameters\n    ----------\n    load_factor_end_year\n        Value of mean aircraft load factor in the considered end year [%].\n    covid_load_factor_2020\n        Load factor due to Covid-19 for the start_year [%].\n    rpk\n        Total number of Revenue Passenger Kilometer (RPK).\n    ask_init\n        Historical number of Available Seat Kilometer (ASK) over 2000-2019 [ASK].\n\n    Returns\n    -------\n    load_factor\n        Mean aircraft load factor for each year of the model period [%].\n    \"\"\"\n    for k in range(self.historic_start_year, self.prospection_start_year):\n        self.df.loc[k, \"load_factor\"] = rpk.loc[k] / ask_init.loc[k] * 100\n\n    # Initialization for load factor\n    load_factor_2019 = self.df.loc[2019, \"load_factor\"]\n\n    # Parameters for the model\n    a, b = self.parameters_load_factor_model(\n        self.end_year, load_factor_2019, load_factor_end_year\n    )\n\n    for k in range(self.prospection_start_year, self.end_year + 1):\n        self.df.loc[k, \"load_factor\"] = a * (k - 2019) ** 2 + b * (k - 2019) + load_factor_2019\n\n    # Covid-19 : \u00e0 refaire proprement\n    self.df.loc[2020, \"load_factor\"] = covid_load_factor_2020\n\n    load_factor = self.df[\"load_factor\"]\n\n    return load_factor\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.load_factor.load_factor/#aeromaps.models.air_transport.aircraft_fleet_and_operations.load_factor.load_factor.LoadFactor.parameters_load_factor_model","title":"parameters_load_factor_model  <code>staticmethod</code>","text":"<pre><code>parameters_load_factor_model(end_year, load_factor_2019, load_factor_end_year)\n</code></pre> <p>Compute the parameters of the quadratic model for load factor evolution.</p> <p>Parameters:</p> Name Type Description Default <code>end_year</code> <p>Year at which the target load factor is reached [yr]</p> required <code>load_factor_2019</code> <p>Load factor in 2019 [%]</p> required <code>load_factor_end_year</code> <p>Target load factor in end_year [%]</p> required <p>Returns:</p> Type Description <code>a</code> <p>Second order parameter of the quadratic model</p> <code>b</code> <p>First order parameter of the quadratic model</p> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/load_factor/load_factor.py</code> <pre><code>@staticmethod\ndef parameters_load_factor_model(end_year, load_factor_2019, load_factor_end_year):\n    \"\"\"\n    Compute the parameters of the quadratic model for load factor evolution.\n\n    Parameters\n    ----------\n    end_year\n        Year at which the target load factor is reached [yr]\n    load_factor_2019\n        Load factor in 2019 [%]\n    load_factor_end_year\n        Target load factor in end_year [%]\n\n    Returns\n    -------\n    a\n        Second order parameter of the quadratic model\n    b\n        First order parameter of the quadratic model\n\n    \"\"\"\n    # Calculate via derivative : 2ax+b\n    derivative = 2 * (-5.62003082e-05) * 31 + 3.59670410e-03\n    a = (\n        -(load_factor_end_year - load_factor_2019 - derivative * (end_year - 2019))\n        / (end_year - 2019) ** 2\n    )\n    b = derivative - 2 * a * (end_year - 2019)\n    return [a, b]\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.load_factor/","title":"<code>aeromaps.models.air_transport.aircraft_fleet_and_operations.load_factor</code>","text":""},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.load_factor/#aeromaps.models.air_transport.aircraft_fleet_and_operations.load_factor--load_factor","title":"load_factor","text":"<p>Module to compute the evolution of aircraft load factor over time.</p>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations/","title":"<code>aeromaps.models.air_transport.aircraft_fleet_and_operations</code>","text":""},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations/#aeromaps.models.air_transport.aircraft_fleet_and_operations--aircraft_fleet_and_operations","title":"aircraft_fleet_and_operations","text":"<p>This package contains models related to aircraft fleet and operations simulation.</p>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2/","title":"<code>aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2</code>","text":""},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2/#aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2--non_co2","title":"non_co2","text":"<p>This package contains models related to measures specific to reduce non-co2 effects.</p>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2.non_co2/","title":"<code>aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2.non_co2</code>","text":""},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2.non_co2/#aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2.non_co2--non_co2","title":"non_co2","text":"<p>Module for computing non-CO2 climate effects related to aircraft operations, including contrail-related adjustments and fuel-effect corrections used in ERF calculations.</p>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2.non_co2/#aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2.non_co2.OperationsContrailsSimple","title":"OperationsContrailsSimple","text":"<pre><code>OperationsContrailsSimple(name='operations_contrails_simple', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Simple operational model computing contrails gains for ERF calculation and overconsumption associated with contrail avoidance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name of the model instance ('operations_contrails_simple' by default).</p> <code>'operations_contrails_simple'</code> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/non_co2/non_co2.py</code> <pre><code>def __init__(self, name=\"operations_contrails_simple\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2.non_co2/#aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2.non_co2.OperationsContrailsSimple.compute","title":"compute","text":"<pre><code>compute(operations_contrails_final_gain, operations_contrails_final_overconsumption, operations_contrails_start_year, operations_contrails_duration)\n</code></pre> <p>Execute computation for contrails gains for ERF calculation and overconsumption associated with contrail avoidance.</p> <p>Parameters:</p> Name Type Description Default <code>operations_contrails_final_gain</code> <code>float</code> <p>Final impact of contrail operational improvements in terms of percentage reduction in contrails climate impacts [%].</p> required <code>operations_contrails_final_overconsumption</code> <code>float</code> <p>Final impact of contrail operational improvements in terms of percentage increase in fuel consumption [%].</p> required <code>operations_contrails_start_year</code> <code>Number</code> <p>Start year for implementing contrail operational improvements to reduce contrail climate impacts [yr].</p> required <code>operations_contrails_duration</code> <code>float</code> <p>Duration for implementing 98% of contrail operational improvements to reduce contrail climate impacts [yr].</p> required <p>Returns:</p> Type Description <code>operations_contrails_gain</code> <p>Impact of contrail operational improvements in terms of percentage reduction in contrails climate impacts [%].</p> <code>operations_contrails_overconsumption</code> <p>Impact of contrail operational improvements in terms of percentage increase in fuel consumption [%].</p> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/non_co2/non_co2.py</code> <pre><code>def compute(\n    self,\n    operations_contrails_final_gain: float,\n    operations_contrails_final_overconsumption: float,\n    operations_contrails_start_year: Number,\n    operations_contrails_duration: float,\n) -&gt; Tuple[pd.Series, pd.Series]:\n    \"\"\"Execute computation for contrails gains for ERF calculation and overconsumption associated with contrail avoidance.\n\n    Parameters\n    ----------\n    operations_contrails_final_gain\n        Final impact of contrail operational improvements in terms of percentage reduction in contrails climate impacts [%].\n    operations_contrails_final_overconsumption\n        Final impact of contrail operational improvements in terms of percentage increase in fuel consumption [%].\n    operations_contrails_start_year\n        Start year for implementing contrail operational improvements to reduce contrail climate impacts [yr].\n    operations_contrails_duration\n        Duration for implementing 98% of contrail operational improvements to reduce contrail climate impacts [yr].\n\n    Returns\n    -------\n    operations_contrails_gain\n        Impact of contrail operational improvements in terms of percentage reduction in contrails climate impacts [%].\n    operations_contrails_overconsumption\n        Impact of contrail operational improvements in terms of percentage increase in fuel consumption [%].\n    \"\"\"\n\n    transition_year = operations_contrails_start_year + operations_contrails_duration / 2\n    operations_contrails_limit = 0.02 * operations_contrails_final_gain\n    operations_parameter = np.log(100 / 2 - 1) / (operations_contrails_duration / 2)\n    for k in range(self.historic_start_year, self.prospection_start_year):\n        self.df.loc[k, \"operations_contrails_gain\"] = 0\n        self.df.loc[k, \"operations_contrails_overconsumption\"] = 0\n    for k in range(self.prospection_start_year, self.end_year + 1):\n        if (\n            operations_contrails_final_gain\n            / (1 + np.exp(-operations_parameter * (k - transition_year)))\n            &lt; operations_contrails_limit\n        ):\n            self.df.loc[k, \"operations_contrails_gain\"] = 0\n            self.df.loc[k, \"operations_contrails_overconsumption\"] = 0\n        else:\n            self.df.loc[k, \"operations_contrails_gain\"] = operations_contrails_final_gain / (\n                1 + np.exp(-operations_parameter * (k - transition_year))\n            )\n            self.df.loc[k, \"operations_contrails_overconsumption\"] = (\n                operations_contrails_final_overconsumption\n                / (1 + np.exp(-operations_parameter * (k - transition_year)))\n            )\n\n    operations_contrails_gain = self.df[\"operations_contrails_gain\"]\n    operations_contrails_overconsumption = self.df[\"operations_contrails_overconsumption\"]\n\n    return operations_contrails_gain, operations_contrails_overconsumption\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2.non_co2/#aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2.non_co2.FuelEffectCorrectionContrails","title":"FuelEffectCorrectionContrails","text":"<pre><code>FuelEffectCorrectionContrails(name='fuel_effect_correction_contrails', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Compute fuel-effect on contrails for ERF calculation.</p> <p>This custom model aggregates pathway-specific particle emission indices and distance shares to compute a correction applied to contrail forcing to reflect fuel/pathway effects.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name of the model instance ('fuel_effect_correction_contrails' by default).</p> <code>'fuel_effect_correction_contrails'</code> <p>Attributes:</p> Name Type Description <code>pathways_manager</code> <p>EnergyCarrierManager instance managing the energy carriers pathways considered in the scenario.</p> <code>input_names</code> <p>Dictionary defining the expected input names for the model.</p> <code>output_names</code> <p>Dictionary defining the output names for the model.</p> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/non_co2/non_co2.py</code> <pre><code>def __init__(self, name=\"fuel_effect_correction_contrails\", *args, **kwargs):\n    super().__init__(name=name, model_type=\"custom\", *args, **kwargs)\n    self.pathways_manager = None\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2.non_co2/#aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2.non_co2.FuelEffectCorrectionContrails.custom_setup","title":"custom_setup","text":"<pre><code>custom_setup()\n</code></pre> <p>Setup input and output names for the model grammar, based on .yaml configuration of energy carriers.</p> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/non_co2/non_co2.py</code> <pre><code>def custom_setup(self):\n    \"\"\"Setup input and output names for the model grammar, based on .yaml configuration of energy carriers.\"\"\"\n    self.input_names = {}\n    self.output_names = {}\n\n    for aircraft_type in self.pathways_manager.get_all_types(\"aircraft_type\"):\n        if aircraft_type == \"dropin_fuel\":\n            for pathway in self.pathways_manager.get(\n                aircraft_type=aircraft_type,\n            ):\n                self.input_names.update(\n                    {\n                        f\"{pathway.name}_massic_share_{aircraft_type}\": pd.Series([0.0]),\n                        f\"{pathway.name}_emission_index_particles_number\": 0.0,\n                    }\n                )\n            self.input_names.update(\n                {\n                    \"total_aircraft_distance_dropin_fuel\": pd.Series([0.0]),\n                }\n            )\n        elif aircraft_type == \"hydrogen\":\n            self.input_names.update(\n                {\n                    \"contrails_relative_effect_hydrogen_wrt_kerosene\": 0.0,\n                    \"total_aircraft_distance_hydrogen\": pd.Series([0.0]),\n                }\n            )\n        elif aircraft_type == \"electric\":\n            self.input_names.update(\n                {\n                    \"total_aircraft_distance_electric\": pd.Series([0.0]),\n                }\n            )\n        else:\n            warnings.warn(f\"Aircraft type '{aircraft_type}' not supported.\", UserWarning)\n\n    self.input_names.update(\n        {\n            \"total_aircraft_distance\": pd.Series([0.0]),\n        }\n    )\n\n    self.output_names.update(\n        {\n            \"fuel_effect_correction_contrails\": pd.Series([0.0]),\n        }\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2.non_co2/#aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2.non_co2.FuelEffectCorrectionContrails.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Execute the computation of fuel-effect correction for contrails ERF computation.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Mapping of input series and scalars required by the model. Expected keys include pathway-specific massic shares of each aircraft consumption; particle emission indices, total aircraft distances travelled by aircraft type and overall total aircraft distance, and contrails_relative_effect_hydrogen_wrt_kerosene when hydrogen pathways are present.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary with key 'fuel_effect_correction_contrails' containing a pd.Series multiplicative correction (dimensionless) for contrail forcing over the scenario.</p> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/non_co2/non_co2.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"Execute the computation of fuel-effect correction for contrails ERF computation.\n\n    Parameters\n    ----------\n    input_data\n        Mapping of input series and scalars required by the model. Expected\n        keys include pathway-specific massic shares of each aircraft consumption; particle emission\n        indices, total aircraft distances travelled by aircraft type and overall total\n        aircraft distance, and contrails_relative_effect_hydrogen_wrt_kerosene\n        when hydrogen pathways are present.\n\n    Returns\n    -------\n    output_data\n        Dictionary with key 'fuel_effect_correction_contrails' containing a\n        pd.Series multiplicative correction (dimensionless) for contrail\n        forcing over the scenario.\n    \"\"\"\n\n    fuel_effect_correction_contrails = get_default_series(\n        self.historic_start_year, self.end_year\n    )\n\n    for aircraft_type in self.pathways_manager.get_all_types(\"aircraft_type\"):\n        if aircraft_type == \"dropin_fuel\":\n            relative_particles_number = get_default_series(\n                self.historic_start_year, self.end_year\n            )\n            distance_share_dropin_fuel = (\n                input_data[\"total_aircraft_distance_dropin_fuel\"]\n                / input_data[\"total_aircraft_distance\"]\n            )\n\n            default_pathway = self.pathways_manager.get(\n                aircraft_type=aircraft_type, default=True\n            )[0]\n            default_emission_index_number_particles = input_data[\n                f\"{default_pathway.name}_emission_index_particles_number\"\n            ]\n\n            for pathway in self.pathways_manager.get(\n                aircraft_type=aircraft_type,\n            ):\n                relative_particles_number += (\n                    input_data[f\"{pathway.name}_massic_share_{aircraft_type}\"]\n                    / 100\n                    * np.sqrt(\n                        input_data[f\"{pathway.name}_emission_index_particles_number\"]\n                        / default_emission_index_number_particles\n                    )\n                ).fillna(0)\n\n            fuel_effect_correction_contrails += (\n                distance_share_dropin_fuel * relative_particles_number\n            )\n        elif aircraft_type == \"hydrogen\":\n            fuel_effect_correction_contrails += (\n                input_data[\"total_aircraft_distance_hydrogen\"]\n                / input_data[\"total_aircraft_distance\"]\n                * input_data[\"contrails_relative_effect_hydrogen_wrt_kerosene\"]\n            )\n        elif aircraft_type == \"electric\":\n            pass\n        else:\n            warnings.warn(f\"Aircraft type '{aircraft_type}' not supported.\", UserWarning)\n\n    output_data = {\n        \"fuel_effect_correction_contrails\": fuel_effect_correction_contrails,\n    }\n\n    self._store_outputs(output_data)\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2.non_co2/#aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2.non_co2.WithoutFuelEffectCorrectionContrails","title":"WithoutFuelEffectCorrectionContrails","text":"<pre><code>WithoutFuelEffectCorrectionContrails(name='without_fuel_effect_correction_contrails', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Model returning a unitary correction (no fuel effect) for contrails.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name of the model instance ('without_fuel_effect_correction_contrails' by default).</p> <code>'without_fuel_effect_correction_contrails'</code> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/non_co2/non_co2.py</code> <pre><code>def __init__(self, name=\"without_fuel_effect_correction_contrails\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2.non_co2/#aeromaps.models.air_transport.aircraft_fleet_and_operations.non_co2.non_co2.WithoutFuelEffectCorrectionContrails.compute","title":"compute","text":"<pre><code>compute(total_aircraft_distance)\n</code></pre> <p>Return a multiplicative correction equal to 1 for all years.</p> <p>Parameters:</p> Name Type Description Default <code>total_aircraft_distance</code> <code>Series</code> <p>Total distance travelled by aircraft (based on RPK traffic) [km]. FIXME: this input is not used in the computation.</p> required <p>Returns:</p> Type Description <code>fuel_effect_correction_contrails</code> <p>Multiplicative multiplicative correction (dimensionless) for contrail forcing over the scenario, equal to 1 for all years.</p> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/non_co2/non_co2.py</code> <pre><code>def compute(\n    self,\n    total_aircraft_distance: pd.Series,\n) -&gt; pd.Series:\n    \"\"\"Return a multiplicative correction equal to 1 for all years.\n\n    Parameters\n    ----------\n    total_aircraft_distance\n        Total distance travelled by aircraft (based on RPK traffic) [km].\n        FIXME: this input is not used in the computation.\n\n    Returns\n    -------\n    fuel_effect_correction_contrails\n        Multiplicative multiplicative correction (dimensionless) for contrail\n        forcing over the scenario, equal to 1 for all years.\n    \"\"\"\n\n    for k in range(self.historic_start_year, self.end_year + 1):\n        self.df.loc[k, \"fuel_effect_correction_contrails\"] = 1\n\n    fuel_effect_correction_contrails = self.df[\"fuel_effect_correction_contrails\"]\n    return fuel_effect_correction_contrails\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.operations/","title":"<code>aeromaps.models.air_transport.aircraft_fleet_and_operations.operations</code>","text":""},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.operations/#aeromaps.models.air_transport.aircraft_fleet_and_operations.operations--operations","title":"operations","text":"<p>Subpackage grouping models for operational improvements (operations gain) used in energy and emissions calculations.</p>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.operations.operations/","title":"<code>aeromaps.models.air_transport.aircraft_fleet_and_operations.operations.operations</code>","text":""},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.operations.operations/#aeromaps.models.air_transport.aircraft_fleet_and_operations.operations.operations--operations","title":"operations","text":"<p>Module for computing operational improvements (efficiency gains) used in energy and emissions calculations. Provides logistic and interpolation-based models to produce an annual <code>operations_gain</code> series representing percentage reductions in fuel consumption per ASK.</p>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.operations.operations/#aeromaps.models.air_transport.aircraft_fleet_and_operations.operations.operations.OperationsLogistic","title":"OperationsLogistic","text":"<pre><code>OperationsLogistic(name='operations_logistic', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Logistic model implementation to project operational efficiency gains.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name of the model instance ('operations_logistic' by default).</p> <code>'operations_logistic'</code> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/operations/operations.py</code> <pre><code>def __init__(self, name=\"operations_logistic\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.operations.operations/#aeromaps.models.air_transport.aircraft_fleet_and_operations.operations.operations.OperationsLogistic.compute","title":"compute","text":"<pre><code>compute(operations_final_gain, operations_start_year, operations_duration)\n</code></pre> <p>Compute the annual operational efficiency gains.</p> <p>Parameters:</p> Name Type Description Default <code>operations_final_gain</code> <code>float</code> <p>Final impact of operational improvements in terms of percentage reduction in fuel consumption per ASK [%].</p> required <code>operations_start_year</code> <code>Number</code> <p>Start year for implementing operational improvements to reduce fuel consumption [yr].</p> required <code>operations_duration</code> <code>float</code> <p>Duration for implementing 98% of operational improvements to reduce fuel consumption [yr].</p> required <p>Returns:</p> Type Description <code>operations_gain</code> <p>Impact of operational improvements in terms of percentage reduction in fuel consumption per ASK [%].</p> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/operations/operations.py</code> <pre><code>def compute(\n    self,\n    operations_final_gain: float,\n    operations_start_year: Number,\n    operations_duration: float,\n) -&gt; pd.Series:\n    \"\"\"Compute the annual operational efficiency gains.\n\n    Parameters\n    ----------\n    operations_final_gain\n        Final impact of operational improvements in terms of percentage reduction in fuel consumption per ASK [%].\n    operations_start_year\n        Start year for implementing operational improvements to reduce fuel consumption [yr].\n    operations_duration\n        Duration for implementing 98% of operational improvements to reduce fuel consumption [yr].\n\n    Returns\n    -------\n    operations_gain\n        Impact of operational improvements in terms of percentage reduction in fuel consumption per ASK [%].\n    \"\"\"\n\n    transition_year = operations_start_year + operations_duration / 2\n    operations_limit = 0.02 * operations_final_gain\n    operations_parameter = np.log(100 / 2 - 1) / (operations_duration / 2)\n    for k in range(self.historic_start_year, self.prospection_start_year):\n        self.df.loc[k, \"operations_gain\"] = 0\n    for k in range(self.prospection_start_year - 1, self.end_year + 1):\n        if (\n            operations_final_gain / (1 + np.exp(-operations_parameter * (k - transition_year)))\n            &lt; operations_limit\n        ):\n            self.df.loc[k, \"operations_gain\"] = 0\n        else:\n            self.df.loc[k, \"operations_gain\"] = operations_final_gain / (\n                1 + np.exp(-operations_parameter * (k - transition_year))\n            )\n\n    operations_gain = self.df[\"operations_gain\"]\n\n    return operations_gain\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.operations.operations/#aeromaps.models.air_transport.aircraft_fleet_and_operations.operations.operations.OperationsInterpolation","title":"OperationsInterpolation","text":"<pre><code>OperationsInterpolation(name='operations_interpolation', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Interpolation-based implementation to project operational efficiency gains.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name of the model instance ('operations_interpolation' by default).</p> <code>'operations_interpolation'</code> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/operations/operations.py</code> <pre><code>def __init__(self, name=\"operations_interpolation\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.aircraft_fleet_and_operations.operations.operations/#aeromaps.models.air_transport.aircraft_fleet_and_operations.operations.operations.OperationsInterpolation.compute","title":"compute","text":"<pre><code>compute(operations_gain_reference_years, operations_gain_reference_years_values)\n</code></pre> <p>Compute the annual operations efficiency gain by interpolating provided reference points.</p> <p>Parameters:</p> Name Type Description Default <code>operations_gain_reference_years</code> <code>list</code> <p>Reference years for the operations gain [yr].</p> required <code>operations_gain_reference_years_values</code> <code>list</code> <p>Operations gain for the reference years [%].</p> required <p>Returns:</p> Type Description <code>operations_gain</code> <p>Impact of operational improvements in terms of percentage reduction in fuel consumption per ASK [%].</p> Source code in <code>aeromaps/models/air_transport/aircraft_fleet_and_operations/operations/operations.py</code> <pre><code>def compute(\n    self,\n    operations_gain_reference_years: list,\n    operations_gain_reference_years_values: list,\n) -&gt; pd.Series:\n    \"\"\"Compute the annual operations efficiency gain by interpolating provided reference points.\n\n    Parameters\n    ----------\n    operations_gain_reference_years\n        Reference years for the operations gain [yr].\n    operations_gain_reference_years_values\n        Operations gain for the reference years [%].\n\n    Returns\n    -------\n    operations_gain\n        Impact of operational improvements in terms of percentage reduction in fuel consumption per ASK [%].\n    \"\"\"\n\n    operations_gain_prospective = aeromaps_interpolation_function(\n        self,\n        operations_gain_reference_years,\n        operations_gain_reference_years_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"operations_gain\"] = operations_gain_prospective\n    for k in range(self.historic_start_year, self.prospection_start_year):\n        self.df.loc[k, \"operations_gain\"] = 0\n    operations_gain = self.df[\"operations_gain\"]\n\n    return operations_gain\n</code></pre>"},{"location":"full_doc/aeromaps.models.air_transport.constants/","title":"<code>aeromaps.models.air_transport.constants</code>","text":"<p>Constants for air transport energy and fuel types. FIXME: Typo in 'HYDROGENE' should be 'HYDROGEN'. FIXME: Where are the constants used?</p>"},{"location":"full_doc/aeromaps.models.air_transport.constants/#aeromaps.models.air_transport.constants.EnergyTypes","title":"EnergyTypes","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of Energy Types.</p>"},{"location":"full_doc/aeromaps.models.air_transport.constants/#aeromaps.models.air_transport.constants.FuelTypes","title":"FuelTypes","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of Fuel Types.</p>"},{"location":"full_doc/aeromaps.models.air_transport/","title":"<code>aeromaps.models.air_transport</code>","text":""},{"location":"full_doc/aeromaps.models.air_transport/#aeromaps.models.air_transport--air_transport","title":"air_transport","text":"<p>This package contains models structural to air transport scenario simulation, such as traffic metrics and fleet composition.</p>"},{"location":"full_doc/aeromaps.models.base/","title":"<code>aeromaps.models.base</code>","text":"<p>Utility base classes and climate-related helper functions used by AeroMAPS models.</p>"},{"location":"full_doc/aeromaps.models.base/#aeromaps.models.base.AeroMapsCustomDataType","title":"AeroMapsCustomDataType","text":"<pre><code>AeroMapsCustomDataType(reference_data)\n</code></pre> <p>Custom type class to handle yaml data input for AeroMAPS models. It contains reference years and values, and interpolation options. When an AeroMapsCustomDataType is found when reading the yaml it instantiates an interpolation model from yaml_interpolator.py</p> <p>Parameters:</p> Name Type Description Default <code>reference_data</code> <code>dict</code> <p>Dictionary containing interpolation attributes.</p> required <p>Attributes:</p> Name Type Description <code>years</code> <p>List of reference years for the interpolation.</p> <code>values</code> <p>List of reference values for the interpolation.</p> <code>method</code> <p>Interpolation method, default is 'linear'.</p> <code>positive_constraint</code> <p>If True, ensures interpolated values are non-negative.</p> Source code in <code>aeromaps/models/base.py</code> <pre><code>def __init__(self, reference_data: dict):\n    self.years = reference_data[\"years\"]\n    self.values = reference_data[\"values\"]\n    if \"method\" in reference_data:\n        self.method = reference_data[\"method\"]\n    else:\n        self.method = \"linear\"\n    if \"positive_constraint\" in reference_data:\n        self.positive_constraint = reference_data[\"positive_constraint\"]\n    else:\n        self.positive_constraint = False\n</code></pre>"},{"location":"full_doc/aeromaps.models.base/#aeromaps.models.base.AeroMAPSModel","title":"AeroMAPSModel","text":"<pre><code>AeroMAPSModel(name, parameters=None, model_type='auto')\n</code></pre> <p>               Bases: <code>object</code></p> <p>Base class for AeroMAPS model components that provides shared state and utilities.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name of the model instance.</p> required <code>parameters</code> <p>AeroMAPS process parameters object containing model inputs.</p> <code>None</code> <code>model_type</code> <p>Type of the model, either 'auto' or 'custom'.</p> <code>'auto'</code> <p>Attributes:</p> Name Type Description <code>name</code> <p>Name of the model instance.</p> <code>parameters</code> <p>Reference to the parameters object passed at construction.</p> <code>float_outputs</code> <p>Dictionary storing scalar outputs produced by the model.</p> <code>model_type</code> <p>Configured model type, either 'auto' or 'custom'.</p> <code>input_names</code> <p>Dictionary of expected input names and types (only for 'custom' models).</p> <code>output_names</code> <p>Dictionary of output names and types (only for 'custom' models).</p> <code>default_input_data</code> <p>Default input data provided internally by the model (only for 'custom' models).</p> <code>_skip_data_type_validation</code> <p>Flag to skip input/output data type validation for custom models.</p> <code>climate_historic_start_year</code> <p>Start year for climate-related historical data.</p> <code>historic_start_year</code> <p>Start year for general historical data.</p> <code>prospection_start_year</code> <p>First year of the prospection/projection period.</p> <code>end_year</code> <p>Last year of the model time horizon.</p> <code>df</code> <p>pandas DataFrame indexed by model years for vector outputs.</p> <code>df_climate</code> <p>pandas DataFrame indexed by climate years for climate-specific outputs.</p> <code>xarray_lca</code> <p>xarray DataArray placeholder used by some LCA computations.</p> <code>years</code> <p>Numpy array of years spanning the model horizon.</p> Source code in <code>aeromaps/models/base.py</code> <pre><code>def __init__(self, name, parameters=None, model_type=\"auto\"):\n    self.name = name\n    self.parameters = parameters\n    self.float_outputs = {}\n    if self.parameters is not None:\n        self._initialize_df()\n\n    # Verify model type\n    self.model_type = model_type\n    if self.model_type == \"custom\":\n        self.input_names = {}  # Dictionary to store input names and their types (or values)\n        self.output_names = {}  # Dictionary to store output names and their types (or values)\n        self.default_input_data = {}  # Dictionary to store default input data (i.e. provided internally by the model rather than parameters.json)\n        self._skip_data_type_validation = False  # Whether to skip input/output data type validation. If True, input_names and output_names can be lists of names only.\n    elif self.model_type != \"auto\":\n        raise ValueError(\"model_type must be either 'auto' or 'custom'\")\n</code></pre>"},{"location":"full_doc/aeromaps.models.base/#aeromaps.models.base.aeromaps_interpolation_function","title":"aeromaps_interpolation_function","text":"<pre><code>aeromaps_interpolation_function(self, reference_years, reference_years_values, method='linear', positive_constraint=False, model_name='Not provided')\n</code></pre> <p>Interpolate values across the scenario horizon from reference years and values.</p> <p>Parameters:</p> Name Type Description Default <code>reference_years</code> <p>Sequence of reference years used for interpolation.</p> required <code>reference_years_values</code> <p>Sequence of values corresponding to the reference years.</p> required <code>method</code> <p>Interpolation method to use (e.g. 'linear').</p> <code>'linear'</code> <code>positive_constraint</code> <p>If True, negative interpolated values are clipped to zero.</p> <code>False</code> <code>model_name</code> <p>Optional name used in warnings.</p> <code>'Not provided'</code> <p>Returns:</p> Type Description <code>interpolation_function_values</code> <p>Series of interpolated values indexed by year taken from the model's DataFrame.</p> Source code in <code>aeromaps/models/base.py</code> <pre><code>def aeromaps_interpolation_function(\n    self,\n    reference_years,\n    reference_years_values,\n    method=\"linear\",\n    positive_constraint=False,\n    model_name=\"Not provided\",\n):\n    \"\"\"\n    Interpolate values across the scenario horizon from reference years and values.\n\n    Parameters\n    ----------\n    reference_years\n        Sequence of reference years used for interpolation.\n    reference_years_values\n        Sequence of values corresponding to the reference years.\n    method\n        Interpolation method to use (e.g. 'linear').\n    positive_constraint\n        If True, negative interpolated values are clipped to zero.\n    model_name\n        Optional name used in warnings.\n\n    Returns\n    -------\n    interpolation_function_values\n        Series of interpolated values indexed by year taken from the model's DataFrame.\n    \"\"\"\n    # Main\n    if len(reference_years) == 0:\n        for k in range(self.prospection_start_year, self.end_year + 1):\n            self.df.loc[k, \"interpolation_function_values\"] = reference_years_values[0]\n    else:\n        interpolation_function = interp1d(\n            reference_years,\n            reference_years_values,\n            kind=method,\n        )\n\n        # If first reference year is lower than prospection start year, we start interpolating before\n        if reference_years[0] != self.prospection_start_year:\n            warnings.warn(\n                f\"\\n[Interpolation Model: {model_name} Warning]\\n\"\n                f\"The first reference year ({reference_years[0]}) differs from the prospection start year ({self.prospection_start_year}).\\n\"\n                f\"Interpolation will begin at the first reference year.\"\n            )\n            prospection_start_year = reference_years[0]\n        else:\n            prospection_start_year = self.prospection_start_year\n\n        if reference_years[-1] == self.end_year:\n            for k in range(prospection_start_year, reference_years[-1] + 1):\n                if positive_constraint and interpolation_function(k) &lt;= 0.0:\n                    self.df.loc[k, \"interpolation_function_values\"] = 0.0\n                else:\n                    self.df.loc[k, \"interpolation_function_values\"] = interpolation_function(k)\n        elif reference_years[-1] &gt; self.end_year:\n            warnings.warn(\n                \"Warning Message - \"\n                + \"Model name: \"\n                + model_name\n                + \" - Warning on aeromaps_interpolation_function:\"\n                + \" The last reference year for the interpolation is higher than end_year, the interpolation function is therefore not used in its entirety.\",\n            )\n            for k in range(prospection_start_year, self.end_year + 1):\n                if positive_constraint and interpolation_function(k) &lt;= 0.0:\n                    self.df.loc[k, \"interpolation_function_values\"] = 0.0\n                else:\n                    self.df.loc[k, \"interpolation_function_values\"] = interpolation_function(k)\n        else:\n            warnings.warn(\n                \"Warning Message - \"\n                + \"Model name: \"\n                + model_name\n                + \" - Warning on aeromaps_interpolation_function:\"\n                + \" The last reference year for the interpolation is lower than end_year, the value associated to the last reference year is therefore used as a constant for the upper years.\",\n            )\n            for k in range(prospection_start_year, reference_years[-1] + 1):\n                if positive_constraint and interpolation_function(k) &lt;= 0.0:\n                    self.df.loc[k, \"interpolation_function_values\"] = 0.0\n                else:\n                    self.df.loc[k, \"interpolation_function_values\"] = interpolation_function(k)\n            for k in range(reference_years[-1] + 1, self.end_year + 1):\n                self.df.loc[k, \"interpolation_function_values\"] = self.df.loc[\n                    k - 1, \"interpolation_function_values\"\n                ]\n\n    interpolation_function_values = self.df.loc[:, \"interpolation_function_values\"]\n\n    # Delete intermediate df column\n    self.df.pop(\"interpolation_function_values\")\n\n    return interpolation_function_values\n</code></pre>"},{"location":"full_doc/aeromaps.models.base/#aeromaps.models.base.aeromaps_leveling_function","title":"aeromaps_leveling_function","text":"<pre><code>aeromaps_leveling_function(self, reference_periods, reference_periods_values, model_name='Not provided')\n</code></pre> <p>Build a stepwise series that holds values constant across defined reference periods.</p> <p>Parameters:</p> Name Type Description Default <code>reference_periods</code> <p>Sequence of period boundary years used to define steps.</p> required <code>reference_periods_values</code> <p>Sequence of values corresponding to each reference period.</p> required <code>model_name</code> <p>Optional name used in warnings.</p> <code>'Not provided'</code> <p>Returns:</p> Type Description <code>leveling_function_values</code> <p>Series of leveled values indexed by year taken from the model's DataFrame.</p> Source code in <code>aeromaps/models/base.py</code> <pre><code>def aeromaps_leveling_function(\n    self, reference_periods, reference_periods_values, model_name=\"Not provided\"\n):\n    \"\"\"\n    Build a stepwise series that holds values constant across defined reference periods.\n\n    Parameters\n    ----------\n    reference_periods\n        Sequence of period boundary years used to define steps.\n    reference_periods_values\n        Sequence of values corresponding to each reference period.\n    model_name\n        Optional name used in warnings.\n\n    Returns\n    -------\n    leveling_function_values\n        Series of leveled values indexed by year taken from the model's DataFrame.\n    \"\"\"\n    # Main\n    if len(reference_periods) == 0:\n        for k in range(self.prospection_start_year, self.end_year + 1):\n            self.df.loc[k, \"leveling_function_values\"] = reference_periods_values[0]\n    else:\n        if reference_periods[-1] == self.end_year:\n            for i in range(0, len(reference_periods) - 1):\n                for k in range(reference_periods[i], reference_periods[i + 1] + 1):\n                    self.df.loc[k, \"leveling_function_values\"] = reference_periods_values[i]\n        elif reference_periods[-1] &gt; self.end_year:\n            warnings.warn(\n                \"Warning Message - \"\n                + \"Model name: \"\n                + model_name\n                + \" - Warning on aeromaps_leveling_function:\"\n                + \" The last reference year for the leveling is higher than end_year, the leveling function is therefore not used in its entirety.\",\n            )\n            for i in range(0, len(reference_periods) - 1):\n                for k in range(reference_periods[i], reference_periods[i + 1] + 1):\n                    if k &lt;= self.end_year:\n                        self.df.loc[k, \"leveling_function_values\"] = reference_periods_values[i]\n                    else:\n                        pass\n        else:\n            warnings.warn(\n                \"Warning Message - \"\n                + \"Model name: \"\n                + model_name\n                + \" - Warning on aeromaps_leveling_function:\"\n                + \" The last reference year for the leveling is lower than end_year, the value associated to the last reference period is therefore used as a constant for the upper period.\",\n            )\n            for i in range(0, len(reference_periods) - 1):\n                for k in range(reference_periods[i], reference_periods[i + 1] + 1):\n                    self.df.loc[k, \"leveling_function_values\"] = reference_periods_values[i]\n            for k in range(reference_periods[-1] + 1, self.end_year + 1):\n                self.df.loc[k, \"leveling_function_values\"] = self.df.loc[\n                    k - 1, \"leveling_function_values\"\n                ]\n\n    leveling_function_values = self.df.loc[:, \"leveling_function_values\"]\n\n    # Delete intermediate df column\n    self.df.pop(\"leveling_function_values\")\n\n    return leveling_function_values\n</code></pre>"},{"location":"full_doc/aeromaps.models.base/#aeromaps.models.base.AbsoluteGlobalWarmingPotentialCO2Function","title":"AbsoluteGlobalWarmingPotentialCO2Function","text":"<pre><code>AbsoluteGlobalWarmingPotentialCO2Function(climate_time_horizon)\n</code></pre> <p>Compute the absolute global warming potential (AGWP) for CO2 for a given time horizon. TODO: is base.py the appropriate location for this function?</p> <p>Parameters:</p> Name Type Description Default <code>climate_time_horizon</code> <p>Time horizon over which to compute the AGWP.</p> required <p>Returns:</p> Type Description <code>co2_agwp_h</code> <p>Absolute global warming potential value computed for CO2.</p> Source code in <code>aeromaps/models/base.py</code> <pre><code>def AbsoluteGlobalWarmingPotentialCO2Function(climate_time_horizon):\n    \"\"\"\n    Compute the absolute global warming potential (AGWP) for CO2 for a given time horizon.\n    TODO: is base.py the appropriate location for this function?\n\n    Parameters\n    ----------\n    climate_time_horizon\n        Time horizon over which to compute the AGWP.\n\n    Returns\n    -------\n    co2_agwp_h\n        Absolute global warming potential value computed for CO2.\n    \"\"\"\n    # Reference: IPCC AR5 - https://www.ipcc.ch/site/assets/uploads/2018/07/WGI_AR5.Chap_.8_SM.pdf\n\n    # Parameter: climate time horizon\n    h = climate_time_horizon\n\n    co2_molar_mass = 44.01 * 1e-3  # [kg/mol]\n    air_molar_mass = 28.97e-3  # [kg/mol]\n    atmosphere_total_mass = 5.1352e18  # [kg]\n\n    radiative_efficiency = 1.37e-2 * 1e9  # radiative efficiency [mW/m^2]\n\n    # RF per unit mass increase in atmospheric abundance of CO2 [W/m^2/kg]\n    A_CO2 = radiative_efficiency * air_molar_mass / (co2_molar_mass * atmosphere_total_mass) * 1e-3\n\n    # Coefficients for the model\n    a = [0.2173, 0.2240, 0.2824, 0.2763]\n    tau = [0, 394.4, 36.54, 4.304]  # CO2 lifetime [yrs]\n\n    co2_agwp_h = A_CO2 * a[0] * h\n    for i in [1, 2, 3]:\n        co2_agwp_h += A_CO2 * a[i] * tau[i] * (1 - np.exp(-h / tau[i]))\n\n    # From W/m^2/kg.yr to mW/m^2/Mt.yr\n    co2_agwp_h = co2_agwp_h * 1e3 * 1e9\n\n    return co2_agwp_h\n</code></pre>"},{"location":"full_doc/aeromaps.models.base/#aeromaps.models.base.GWPStarEquivalentEmissionsFunction","title":"GWPStarEquivalentEmissionsFunction","text":"<pre><code>GWPStarEquivalentEmissionsFunction(self, emissions_erf, gwpstar_variation_duration, gwpstar_s_coefficient)\n</code></pre> <p>Compute equivalent CO2 emissions according to the GWP* formulation. TODO: is base.py the appropriate location for this function?</p> <p>Parameters:</p> Name Type Description Default <code>emissions_erf</code> <p>Time series of emissions expressed as effective radiative forcing or equivalent values.</p> required <code>gwpstar_variation_duration</code> <p>Duration over which emission rate changes are evaluated for GWP*.</p> required <code>gwpstar_s_coefficient</code> <p>S coefficient used in the GWP* formulation to weight instantaneous forcing.</p> required <p>Returns:</p> Type Description <code>emissions_equivalent_emissions</code> <p>Series of GWP*-equivalent CO2 emissions indexed by climate years.</p> Source code in <code>aeromaps/models/base.py</code> <pre><code>def GWPStarEquivalentEmissionsFunction(\n    self, emissions_erf, gwpstar_variation_duration, gwpstar_s_coefficient\n):\n    \"\"\"\n    Compute equivalent CO2 emissions according to the GWP* formulation.\n    TODO: is base.py the appropriate location for this function?\n\n    Parameters\n    ----------\n    emissions_erf\n        Time series of emissions expressed as effective radiative forcing or equivalent values.\n    gwpstar_variation_duration\n        Duration over which emission rate changes are evaluated for GWP*.\n    gwpstar_s_coefficient\n        S coefficient used in the GWP* formulation to weight instantaneous forcing.\n\n    Returns\n    -------\n    emissions_equivalent_emissions\n        Series of GWP*-equivalent CO2 emissions indexed by climate years.\n    \"\"\"\n    # Reference: Smith et al. (2021), https://doi.org/10.1038/s41612-021-00169-8\n    # Global\n    climate_time_horizon = 100\n    co2_agwp_h = AbsoluteGlobalWarmingPotentialCO2Function(climate_time_horizon)\n\n    # g coefficient for GWP*\n    if gwpstar_s_coefficient == 0:\n        g_coefficient = 1\n    else:\n        g_coefficient = (\n            1 - np.exp(-gwpstar_s_coefficient / (1 - gwpstar_s_coefficient))\n        ) / gwpstar_s_coefficient\n\n    # Main\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        if k - self.climate_historic_start_year &gt;= gwpstar_variation_duration:\n            self.df_climate.loc[k, \"emissions_erf_variation\"] = (\n                emissions_erf.loc[k] - emissions_erf.loc[k - gwpstar_variation_duration]\n            ) / gwpstar_variation_duration\n        else:\n            self.df_climate.loc[k, \"emissions_erf_variation\"] = (\n                emissions_erf.loc[k] / gwpstar_variation_duration\n            )\n\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        self.df_climate.loc[k, \"emissions_equivalent_emissions\"] = (\n            g_coefficient\n            * (1 - gwpstar_s_coefficient)\n            * climate_time_horizon\n            / co2_agwp_h\n            * self.df_climate.loc[k, \"emissions_erf_variation\"]\n        ) + g_coefficient * gwpstar_s_coefficient / co2_agwp_h * emissions_erf.loc[k]\n    emissions_equivalent_emissions = self.df_climate.loc[:, \"emissions_equivalent_emissions\"]\n\n    # Delete intermediate df column\n    self.df_climate.pop(\"emissions_erf_variation\")\n    self.df_climate.pop(\"emissions_equivalent_emissions\")\n\n    return emissions_equivalent_emissions\n</code></pre>"},{"location":"full_doc/aeromaps.models.base/#aeromaps.models.base.RunFair","title":"RunFair","text":"<pre><code>RunFair(self, species_quantities, without='None')\n</code></pre> <p>Configure and run the FaIR climate model using provided species inputs. TODO: is base.py the appropriate location for this function?</p> <p>Parameters:</p> Name Type Description Default <code>species_quantities</code> <p>List or sequence of species input arrays used to fill FaIR emissions and forcings.</p> required <code>without</code> <p>Optional string controlling which aviation components are excluded from the run.</p> <code>'None'</code> <p>Returns:</p> Type Description <code>(temperature, forcing_sum)</code> <p>Temperature time series and total forcing time series produced by the FaIR run.</p> Source code in <code>aeromaps/models/base.py</code> <pre><code>def RunFair(self, species_quantities, without=\"None\"):\n    \"\"\"\n    Configure and run the FaIR climate model using provided species inputs.\n    TODO: is base.py the appropriate location for this function?\n\n    Parameters\n    ----------\n    species_quantities\n        List or sequence of species input arrays used to fill FaIR emissions and forcings.\n    without\n        Optional string controlling which aviation components are excluded from the run.\n\n    Returns\n    -------\n    temperature, forcing_sum\n        Temperature time series and total forcing time series produced by the FaIR run.\n    \"\"\"\n    # Creation of FaIR instance\n    f = FAIR()\n\n    # Definition of time horizon, scenarios, configs\n    start_time = 1765\n    end_time = self.end_year\n    f.define_time(start_time, end_time, 1)\n    f.define_scenarios([\"central\"])\n    f.define_configs([\"central\"])\n    # f.define_configs([\"high\", \"central\", \"low\"])\n\n    # Definition of species and properties\n    species = [\n        \"CO2\",  # Includes world emissions, aviation emissions, and equivalent emissions for NOx effects (except ST O3)\n        \"World CH4\",\n        \"Aviation contrails\",\n        \"Aviation NOx ST O3 increase\",\n        \"Aviation H2O\",\n        \"Aviation sulfur\",\n        \"Aviation soot\",\n        \"Aviation aerosols\",\n    ]\n    properties = {\n        \"CO2\": {\n            \"type\": \"co2\",\n            \"input_mode\": \"emissions\",\n            \"greenhouse_gas\": True,\n            \"aerosol_chemistry_from_emissions\": False,\n            \"aerosol_chemistry_from_concentration\": False,\n        },\n        \"World CH4\": {\n            \"type\": \"ch4\",\n            \"input_mode\": \"emissions\",\n            \"greenhouse_gas\": True,\n            \"aerosol_chemistry_from_emissions\": False,\n            \"aerosol_chemistry_from_concentration\": True,  # we treat methane as a reactive gas\n        },\n        \"Aviation contrails\": {\n            \"type\": \"contrails\",\n            \"input_mode\": \"forcing\",\n            \"greenhouse_gas\": False,\n            \"aerosol_chemistry_from_emissions\": False,\n            \"aerosol_chemistry_from_concentration\": False,\n        },\n        \"Aviation NOx ST O3 increase\": {\n            \"type\": \"ozone\",\n            \"input_mode\": \"forcing\",\n            \"greenhouse_gas\": False,\n            \"aerosol_chemistry_from_emissions\": False,\n            \"aerosol_chemistry_from_concentration\": False,\n        },\n        \"Aviation H2O\": {\n            \"type\": \"h2o stratospheric\",\n            \"input_mode\": \"forcing\",\n            \"greenhouse_gas\": False,\n            \"aerosol_chemistry_from_emissions\": False,\n            \"aerosol_chemistry_from_concentration\": False,\n        },\n        \"Aviation sulfur\": {\n            \"type\": \"sulfur\",\n            \"input_mode\": \"emissions\",\n            \"greenhouse_gas\": False,\n            \"aerosol_chemistry_from_emissions\": True,\n            \"aerosol_chemistry_from_concentration\": False,\n        },\n        \"Aviation soot\": {\n            \"type\": \"black carbon\",\n            \"input_mode\": \"emissions\",\n            \"greenhouse_gas\": False,\n            \"aerosol_chemistry_from_emissions\": True,\n            \"aerosol_chemistry_from_concentration\": False,\n        },\n        # Dedicated specie for aerosols\n        \"Aviation aerosols\": {\n            \"type\": \"ari\",\n            \"input_mode\": \"calculated\",\n            \"greenhouse_gas\": False,\n            \"aerosol_chemistry_from_emissions\": False,\n            \"aerosol_chemistry_from_concentration\": False,\n        },\n    }\n    f.define_species(species, properties)\n\n    # Definition of run options\n    f.ghg_method = \"leach2021\"\n    f.aci_method = \"myhre1998\"\n\n    # Creation of input and output data\n    f.allocate()\n\n    # Filling species quantities\n    if without == \"All aviation\":\n        fill(\n            f.emissions,\n            species_quantities[0][1 : self.end_year - 1765 + 1],\n            specie=\"CO2\",\n            config=f.configs[0],\n            scenario=f.scenarios[0],\n        )\n        fill(\n            f.emissions,\n            species_quantities[5][1 : self.end_year - 1765 + 1],\n            specie=\"World CH4\",\n            config=f.configs[0],\n            scenario=f.scenarios[0],\n        )\n        fill(\n            f.forcing, 0, specie=\"Aviation contrails\", config=f.configs[0], scenario=f.scenarios[0]\n        )\n        fill(\n            f.forcing,\n            0,\n            specie=\"Aviation NOx ST O3 increase\",\n            config=f.configs[0],\n            scenario=f.scenarios[0],\n        )\n        fill(f.forcing, 0, specie=\"Aviation H2O\", config=f.configs[0], scenario=f.scenarios[0])\n        fill(f.emissions, 0, specie=\"Aviation sulfur\", config=f.configs[0], scenario=f.scenarios[0])\n        fill(f.emissions, 0, specie=\"Aviation soot\", config=f.configs[0], scenario=f.scenarios[0])\n    else:\n        if without == \"Aviation CO2\":\n            total_CO2 = (\n                species_quantities[0][1 : self.end_year - 1765 + 1]\n                + species_quantities[2][1 : self.end_year - 1765 + 1]\n                + species_quantities[3][1 : self.end_year - 1765 + 1]\n                + species_quantities[4][1 : self.end_year - 1765 + 1]\n            )\n        elif without == \"Aviation NOx LT O3 decrease\":\n            total_CO2 = (\n                species_quantities[0][1 : self.end_year - 1765 + 1]\n                + species_quantities[1][1 : self.end_year - 1765 + 1]\n                + species_quantities[3][1 : self.end_year - 1765 + 1]\n                + species_quantities[4][1 : self.end_year - 1765 + 1]\n            )\n        elif without == \"Aviation NOx CH4 decrease\":\n            total_CO2 = (\n                species_quantities[0][1 : self.end_year - 1765 + 1]\n                + species_quantities[1][1 : self.end_year - 1765 + 1]\n                + species_quantities[2][1 : self.end_year - 1765 + 1]\n                + species_quantities[4][1 : self.end_year - 1765 + 1]\n            )\n        elif without == \"Aviation NOx H2O decrease\":\n            total_CO2 = (\n                species_quantities[0][1 : self.end_year - 1765 + 1]\n                + species_quantities[1][1 : self.end_year - 1765 + 1]\n                + species_quantities[2][1 : self.end_year - 1765 + 1]\n                + species_quantities[3][1 : self.end_year - 1765 + 1]\n            )\n        else:\n            total_CO2 = (\n                species_quantities[0][1 : self.end_year - 1765 + 1]\n                + species_quantities[1][1 : self.end_year - 1765 + 1]\n                + species_quantities[2][1 : self.end_year - 1765 + 1]\n                + species_quantities[3][1 : self.end_year - 1765 + 1]\n                + species_quantities[4][1 : self.end_year - 1765 + 1]\n            )\n        fill(f.emissions, total_CO2, specie=\"CO2\", config=f.configs[0], scenario=f.scenarios[0])\n        fill(\n            f.emissions,\n            species_quantities[5][1 : self.end_year - 1765 + 1],\n            specie=\"World CH4\",\n            config=f.configs[0],\n            scenario=f.scenarios[0],\n        )\n        if without != \"Aviation contrails\":\n            fill(\n                f.forcing,\n                species_quantities[6],\n                specie=\"Aviation contrails\",\n                config=f.configs[0],\n                scenario=f.scenarios[0],\n            )\n        else:\n            fill(\n                f.forcing,\n                0,\n                specie=\"Aviation contrails\",\n                config=f.configs[0],\n                scenario=f.scenarios[0],\n            )\n        if without != \"Aviation NOx ST O3 increase\":\n            fill(\n                f.forcing,\n                species_quantities[7],\n                specie=\"Aviation NOx ST O3 increase\",\n                config=f.configs[0],\n                scenario=f.scenarios[0],\n            )\n        else:\n            fill(\n                f.forcing,\n                0,\n                specie=\"Aviation NOx ST O3 increase\",\n                config=f.configs[0],\n                scenario=f.scenarios[0],\n            )\n        if without != \"Aviation H2O\":\n            fill(\n                f.forcing,\n                species_quantities[8],\n                specie=\"Aviation H2O\",\n                config=f.configs[0],\n                scenario=f.scenarios[0],\n            )\n        else:\n            fill(f.forcing, 0, specie=\"Aviation H2O\", config=f.configs[0], scenario=f.scenarios[0])\n        if without != \"Aviation sulfur\":\n            fill(\n                f.emissions,\n                species_quantities[9][1 : self.end_year - 1765 + 1],\n                specie=\"Aviation sulfur\",\n                config=f.configs[0],\n                scenario=f.scenarios[0],\n            )\n        else:\n            fill(\n                f.emissions,\n                0,\n                specie=\"Aviation sulfur\",\n                config=f.configs[0],\n                scenario=f.scenarios[0],\n            )\n        if without != \"Aviation soot\":\n            fill(\n                f.emissions,\n                species_quantities[10][1 : self.end_year - 1765 + 1],\n                specie=\"Aviation soot\",\n                config=f.configs[0],\n                scenario=f.scenarios[0],\n            )\n        else:\n            fill(\n                f.emissions, 0, specie=\"Aviation soot\", config=f.configs[0], scenario=f.scenarios[0]\n            )\n\n    initialise(f.forcing, 0)\n    initialise(f.temperature, 0)\n    initialise(f.cumulative_emissions, 0)\n    initialise(f.airborne_emissions, 0)\n\n    # Filling climate configs\n    # fill(f.climate_configs[\"ocean_heat_transfer\"], [1.1, 1.6, 0.9], config=\"central\")\n    # fill(f.climate_configs[\"ocean_heat_capacity\"], [8, 14, 100], config=\"central\")\n    # fill(f.climate_configs[\"deep_ocean_efficacy\"], 1.1, config=\"central\")\n    # Corresponds to a \"low\" configuration on FaIR\n    fill(f.climate_configs[\"ocean_heat_transfer\"], [1.7, 2.0, 1.1], config=\"central\")\n    fill(f.climate_configs[\"ocean_heat_capacity\"], [6, 11, 75], config=\"central\")\n    fill(f.climate_configs[\"deep_ocean_efficacy\"], 0.8, config=\"central\")\n\n    # Filling species configs\n    for specie in species:\n        if specie == \"CO2\":\n            fill(\n                f.species_configs[\"partition_fraction\"],\n                [0.2173, 0.2240, 0.2824, 0.2763],\n                specie=\"CO2\",\n            )\n            fill(\n                f.species_configs[\"unperturbed_lifetime\"], [1e9, 394.4, 36.54, 4.304], specie=\"CO2\"\n            )\n            fill(f.species_configs[\"baseline_concentration\"], 278.3, specie=\"CO2\")\n            fill(f.species_configs[\"forcing_reference_concentration\"], 278.3, specie=\"CO2\")\n            fill(f.species_configs[\"molecular_weight\"], 44.009, specie=\"CO2\")\n            fill(\n                f.species_configs[\"greenhouse_gas_radiative_efficiency\"],\n                1.3344985680386619e-05,\n                specie=\"CO2\",\n            )\n            f.calculate_iirf0()\n            f.calculate_g()\n            f.calculate_concentration_per_emission()\n            fill(f.species_configs[\"iirf_0\"], 29, specie=\"CO2\")\n            fill(f.species_configs[\"iirf_airborne\"], [0.000819 * 2], specie=\"CO2\")\n            fill(f.species_configs[\"iirf_uptake\"], [0.00846 * 2], specie=\"CO2\")\n            fill(f.species_configs[\"iirf_temperature\"], [8], specie=\"CO2\")\n            fill(f.species_configs[\"aci_scale\"], -2.09841432)\n\n        if specie == \"World CH4\":\n            fill(f.species_configs[\"partition_fraction\"], [1, 0, 0, 0], specie=specie)\n            fill(f.species_configs[\"unperturbed_lifetime\"], 8.25, specie=specie)\n            fill(f.species_configs[\"baseline_concentration\"], 729, specie=specie)  # ppb\n            fill(f.species_configs[\"forcing_reference_concentration\"], 729, specie=specie)\n            fill(f.species_configs[\"molecular_weight\"], 16.043, specie=specie)\n            fill(\n                f.species_configs[\"greenhouse_gas_radiative_efficiency\"],\n                0.00038864402860869495,\n                specie=specie,\n            )\n            f.calculate_iirf0()\n            f.calculate_g()\n            f.calculate_concentration_per_emission()\n            fill(f.species_configs[\"iirf_airborne\"], 0.00032, specie=specie)\n            fill(f.species_configs[\"iirf_uptake\"], 0, specie=specie)\n            fill(f.species_configs[\"iirf_temperature\"], -0.3, specie=specie)\n            fill(\n                f.species_configs[\"erfari_radiative_efficiency\"],\n                -0.002653 / 1023.2219696044921,\n                specie=specie,\n            )  # W m-2 ppb-1\n            fill(f.species_configs[\"aci_scale\"], -2.09841432)\n\n        if specie == \"Aviation sulfur\":\n            erf_aci_sulfur = 0.0\n            fill(\n                f.species_configs[\"erfari_radiative_efficiency\"],\n                -0.0199 + erf_aci_sulfur,\n                specie=specie,\n            )  # W m-2 MtSO2-1 yr\n            fill(f.species_configs[\"aci_shape\"], 0.0, specie=specie)\n\n        if specie == \"Aviation soot\":\n            erf_aci_BC = 0.0\n            fill(\n                f.species_configs[\"erfari_radiative_efficiency\"], 0.1007 + erf_aci_BC, specie=specie\n            )  # W m-2 MtC-1 yr\n            fill(f.species_configs[\"aci_shape\"], 0.0, specie=specie)\n\n    # Run\n    f.run()\n\n    return (\n        f.temperature.loc[dict(config=f.configs[0], layer=0)].data,\n        f.forcing_sum.loc[dict(config=f.configs[0])].data,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.constants/","title":"<code>aeromaps.models.constants</code>","text":""},{"location":"full_doc/aeromaps.models.constants/#aeromaps.models.constants.ModelType","title":"ModelType","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of model type.</p>"},{"location":"full_doc/aeromaps.models.impacts.climate.climate/","title":"<code>aeromaps.models.impacts.climate.climate</code>","text":"Warning <p>Module to be deprecated before V1</p>"},{"location":"full_doc/aeromaps.models.impacts.climate.climate/#aeromaps.models.impacts.climate.climate.TemperatureGWPStar","title":"TemperatureGWPStar","text":"<pre><code>TemperatureGWPStar(name='temperature_gwpstar', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> Source code in <code>aeromaps/models/impacts/climate/climate.py</code> <pre><code>def __init__(self, name=\"temperature_gwpstar\", *args, **kwargs):\n    super().__init__(name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.climate.climate/#aeromaps.models.impacts.climate.climate.TemperatureGWPStar.compute","title":"compute","text":"<pre><code>compute(contrails_gwpstar_variation_duration, contrails_gwpstar_s_coefficient, nox_short_term_o3_increase_gwpstar_variation_duration, nox_short_term_o3_increase_gwpstar_s_coefficient, nox_long_term_o3_decrease_gwpstar_variation_duration, nox_long_term_o3_decrease_gwpstar_s_coefficient, nox_ch4_decrease_gwpstar_variation_duration, nox_ch4_decrease_gwpstar_s_coefficient, nox_stratospheric_water_vapor_decrease_gwpstar_variation_duration, nox_stratospheric_water_vapor_decrease_gwpstar_s_coefficient, soot_gwpstar_variation_duration, soot_gwpstar_s_coefficient, h2o_gwpstar_variation_duration, h2o_gwpstar_s_coefficient, sulfur_gwpstar_variation_duration, sulfur_gwpstar_s_coefficient, contrails_erf, nox_short_term_o3_increase_erf, nox_long_term_o3_decrease_erf, nox_ch4_decrease_erf, nox_stratospheric_water_vapor_decrease_erf, soot_erf, h2o_erf, sulfur_erf, co2_erf, total_erf, co2_emissions, tcre_coefficient)\n</code></pre> <p>Temperature calculation using equivalent emissions (with GWP* method) and TCRE.</p> Source code in <code>aeromaps/models/impacts/climate/climate.py</code> <pre><code>def compute(\n    self,\n    contrails_gwpstar_variation_duration: float,\n    contrails_gwpstar_s_coefficient: float,\n    nox_short_term_o3_increase_gwpstar_variation_duration: float,\n    nox_short_term_o3_increase_gwpstar_s_coefficient: float,\n    nox_long_term_o3_decrease_gwpstar_variation_duration: float,\n    nox_long_term_o3_decrease_gwpstar_s_coefficient: float,\n    nox_ch4_decrease_gwpstar_variation_duration: float,\n    nox_ch4_decrease_gwpstar_s_coefficient: float,\n    nox_stratospheric_water_vapor_decrease_gwpstar_variation_duration: float,\n    nox_stratospheric_water_vapor_decrease_gwpstar_s_coefficient: float,\n    soot_gwpstar_variation_duration: float,\n    soot_gwpstar_s_coefficient: float,\n    h2o_gwpstar_variation_duration: float,\n    h2o_gwpstar_s_coefficient: float,\n    sulfur_gwpstar_variation_duration: float,\n    sulfur_gwpstar_s_coefficient: float,\n    contrails_erf: pd.Series,\n    nox_short_term_o3_increase_erf: pd.Series,\n    nox_long_term_o3_decrease_erf: pd.Series,\n    nox_ch4_decrease_erf: pd.Series,\n    nox_stratospheric_water_vapor_decrease_erf: pd.Series,\n    soot_erf: pd.Series,\n    h2o_erf: pd.Series,\n    sulfur_erf: pd.Series,\n    co2_erf: pd.Series,\n    total_erf: pd.Series,\n    co2_emissions: pd.Series,\n    tcre_coefficient: float,\n) -&gt; Tuple[\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n]:\n    \"\"\"Temperature calculation using equivalent emissions (with GWP* method) and TCRE.\"\"\"\n\n    # EQUIVALENT EMISSIONS\n\n    ## Contrails\n    contrails_equivalent_emissions = GWPStarEquivalentEmissionsFunction(\n        self,\n        emissions_erf=contrails_erf,\n        gwpstar_variation_duration=contrails_gwpstar_variation_duration,\n        gwpstar_s_coefficient=contrails_gwpstar_s_coefficient,\n    )\n    self.df_climate[\"contrails_equivalent_emissions\"] = contrails_equivalent_emissions\n\n    ## NOx short-term O3 increase\n    nox_short_term_o3_increase_equivalent_emissions = GWPStarEquivalentEmissionsFunction(\n        self,\n        emissions_erf=nox_short_term_o3_increase_erf,\n        gwpstar_variation_duration=nox_short_term_o3_increase_gwpstar_variation_duration,\n        gwpstar_s_coefficient=nox_short_term_o3_increase_gwpstar_s_coefficient,\n    )\n    self.df_climate[\"nox_short_term_o3_increase_equivalent_emissions\"] = (\n        nox_short_term_o3_increase_equivalent_emissions\n    )\n\n    ## NOx long-term O3 decrease\n    nox_long_term_o3_decrease_equivalent_emissions = GWPStarEquivalentEmissionsFunction(\n        self,\n        emissions_erf=nox_long_term_o3_decrease_erf,\n        gwpstar_variation_duration=nox_long_term_o3_decrease_gwpstar_variation_duration,\n        gwpstar_s_coefficient=nox_long_term_o3_decrease_gwpstar_s_coefficient,\n    )\n    self.df_climate[\"nox_long_term_o3_decrease_equivalent_emissions\"] = (\n        nox_long_term_o3_decrease_equivalent_emissions\n    )\n\n    ## NOx CH4 decrease\n    nox_ch4_decrease_equivalent_emissions = GWPStarEquivalentEmissionsFunction(\n        self,\n        emissions_erf=nox_ch4_decrease_erf,\n        gwpstar_variation_duration=nox_ch4_decrease_gwpstar_variation_duration,\n        gwpstar_s_coefficient=nox_ch4_decrease_gwpstar_s_coefficient,\n    )\n    self.df_climate[\"nox_ch4_decrease_equivalent_emissions\"] = (\n        nox_ch4_decrease_equivalent_emissions\n    )\n\n    ## NOx stratospheric water vapor decrease\n    nox_stratospheric_water_vapor_decrease_equivalent_emissions = GWPStarEquivalentEmissionsFunction(\n        self,\n        emissions_erf=nox_stratospheric_water_vapor_decrease_erf,\n        gwpstar_variation_duration=nox_stratospheric_water_vapor_decrease_gwpstar_variation_duration,\n        gwpstar_s_coefficient=nox_stratospheric_water_vapor_decrease_gwpstar_s_coefficient,\n    )\n    self.df_climate[\"nox_stratospheric_water_vapor_decrease_equivalent_emissions\"] = (\n        nox_stratospheric_water_vapor_decrease_equivalent_emissions\n    )\n\n    ## Soot\n    soot_equivalent_emissions = GWPStarEquivalentEmissionsFunction(\n        self,\n        emissions_erf=soot_erf,\n        gwpstar_variation_duration=soot_gwpstar_variation_duration,\n        gwpstar_s_coefficient=soot_gwpstar_s_coefficient,\n    )\n    self.df_climate[\"soot_equivalent_emissions\"] = soot_equivalent_emissions\n\n    ## H2O\n    h2o_equivalent_emissions = GWPStarEquivalentEmissionsFunction(\n        self,\n        emissions_erf=h2o_erf,\n        gwpstar_variation_duration=h2o_gwpstar_variation_duration,\n        gwpstar_s_coefficient=h2o_gwpstar_s_coefficient,\n    )\n    self.df_climate[\"h2o_equivalent_emissions\"] = h2o_equivalent_emissions\n\n    ## Sulfur\n    sulfur_equivalent_emissions = GWPStarEquivalentEmissionsFunction(\n        self,\n        emissions_erf=sulfur_erf,\n        gwpstar_variation_duration=sulfur_gwpstar_variation_duration,\n        gwpstar_s_coefficient=sulfur_gwpstar_s_coefficient,\n    )\n    self.df_climate[\"sulfur_equivalent_emissions\"] = sulfur_equivalent_emissions\n\n    ## Total\n    non_co2_equivalent_emissions = (\n        contrails_equivalent_emissions\n        + nox_short_term_o3_increase_equivalent_emissions\n        + nox_long_term_o3_decrease_equivalent_emissions\n        + nox_ch4_decrease_equivalent_emissions\n        + nox_stratospheric_water_vapor_decrease_equivalent_emissions\n        + soot_equivalent_emissions\n        + h2o_equivalent_emissions\n        + sulfur_equivalent_emissions\n    )\n    total_equivalent_emissions = co2_emissions + non_co2_equivalent_emissions\n    self.df_climate[\"non_co2_equivalent_emissions\"] = non_co2_equivalent_emissions\n    self.df_climate[\"total_equivalent_emissions\"] = total_equivalent_emissions\n\n    ## Cumulative CO2, non-CO2 and total equivalent emissions (Gtwe)\n\n    ### From 1940\n    self.df_climate.loc[\n        self.climate_historic_start_year, \"historical_cumulative_co2_emissions\"\n    ] = co2_emissions.loc[self.climate_historic_start_year] / 1000\n    self.df_climate.loc[\n        self.climate_historic_start_year, \"historical_cumulative_contrails_equivalent_emissions\"\n    ] = contrails_equivalent_emissions.loc[self.climate_historic_start_year] / 1000\n    self.df_climate.loc[\n        self.climate_historic_start_year,\n        \"historical_cumulative_nox_short_term_o3_increase_equivalent_emissions\",\n    ] = (\n        nox_short_term_o3_increase_equivalent_emissions.loc[self.climate_historic_start_year]\n        / 1000\n    )\n    self.df_climate.loc[\n        self.climate_historic_start_year,\n        \"historical_cumulative_nox_long_term_o3_decrease_equivalent_emissions\",\n    ] = (\n        nox_long_term_o3_decrease_equivalent_emissions.loc[self.climate_historic_start_year]\n        / 1000\n    )\n    self.df_climate.loc[\n        self.climate_historic_start_year,\n        \"historical_cumulative_nox_ch4_decrease_equivalent_emissions\",\n    ] = nox_ch4_decrease_equivalent_emissions.loc[self.climate_historic_start_year] / 1000\n    self.df_climate.loc[\n        self.climate_historic_start_year,\n        \"historical_cumulative_nox_stratospheric_water_vapor_decrease_equivalent_emissions\",\n    ] = (\n        nox_stratospheric_water_vapor_decrease_equivalent_emissions.loc[\n            self.climate_historic_start_year\n        ]\n        / 1000\n    )\n    self.df_climate.loc[\n        self.climate_historic_start_year, \"historical_cumulative_soot_equivalent_emissions\"\n    ] = soot_equivalent_emissions.loc[self.climate_historic_start_year] / 1000\n    self.df_climate.loc[\n        self.climate_historic_start_year, \"historical_cumulative_h2o_equivalent_emissions\"\n    ] = h2o_equivalent_emissions.loc[self.climate_historic_start_year] / 1000\n    self.df_climate.loc[\n        self.climate_historic_start_year, \"historical_cumulative_sulfur_equivalent_emissions\"\n    ] = sulfur_equivalent_emissions.loc[self.climate_historic_start_year] / 1000\n    self.df_climate.loc[\n        self.climate_historic_start_year, \"historical_cumulative_non_co2_equivalent_emissions\"\n    ] = non_co2_equivalent_emissions[self.climate_historic_start_year] / 1000\n    for k in range(self.climate_historic_start_year + 1, self.end_year + 1):\n        self.df_climate.loc[k, \"historical_cumulative_co2_emissions\"] = (\n            self.df_climate.loc[k - 1, \"historical_cumulative_co2_emissions\"]\n            + co2_emissions.loc[k] / 1000\n        )\n        self.df_climate.loc[k, \"historical_cumulative_contrails_equivalent_emissions\"] = (\n            self.df_climate.loc[k - 1, \"historical_cumulative_contrails_equivalent_emissions\"]\n            + contrails_equivalent_emissions.loc[k] / 1000\n        )\n        self.df_climate.loc[\n            k, \"historical_cumulative_nox_short_term_o3_increase_equivalent_emissions\"\n        ] = (\n            self.df_climate.loc[\n                k - 1, \"historical_cumulative_nox_short_term_o3_increase_equivalent_emissions\"\n            ]\n            + nox_short_term_o3_increase_equivalent_emissions.loc[k] / 1000\n        )\n        self.df_climate.loc[\n            k, \"historical_cumulative_nox_long_term_o3_decrease_equivalent_emissions\"\n        ] = (\n            self.df_climate.loc[\n                k - 1, \"historical_cumulative_nox_long_term_o3_decrease_equivalent_emissions\"\n            ]\n            + nox_long_term_o3_decrease_equivalent_emissions.loc[k] / 1000\n        )\n        self.df_climate.loc[\n            k, \"historical_cumulative_nox_ch4_decrease_equivalent_emissions\"\n        ] = (\n            self.df_climate.loc[\n                k - 1, \"historical_cumulative_nox_ch4_decrease_equivalent_emissions\"\n            ]\n            + nox_ch4_decrease_equivalent_emissions.loc[k] / 1000\n        )\n        self.df_climate.loc[\n            k,\n            \"historical_cumulative_nox_stratospheric_water_vapor_decrease_equivalent_emissions\",\n        ] = (\n            self.df_climate.loc[\n                k - 1,\n                \"historical_cumulative_nox_stratospheric_water_vapor_decrease_equivalent_emissions\",\n            ]\n            + nox_stratospheric_water_vapor_decrease_equivalent_emissions.loc[k] / 1000\n        )\n        self.df_climate.loc[k, \"historical_cumulative_soot_equivalent_emissions\"] = (\n            self.df_climate.loc[k - 1, \"historical_cumulative_soot_equivalent_emissions\"]\n            + soot_equivalent_emissions.loc[k] / 1000\n        )\n        self.df_climate.loc[k, \"historical_cumulative_h2o_equivalent_emissions\"] = (\n            self.df_climate.loc[k - 1, \"historical_cumulative_h2o_equivalent_emissions\"]\n            + h2o_equivalent_emissions.loc[k] / 1000\n        )\n        self.df_climate.loc[k, \"historical_cumulative_sulfur_equivalent_emissions\"] = (\n            self.df_climate.loc[k - 1, \"historical_cumulative_sulfur_equivalent_emissions\"]\n            + sulfur_equivalent_emissions.loc[k] / 1000\n        )\n\n        self.df_climate.loc[k, \"historical_cumulative_non_co2_equivalent_emissions\"] = (\n            self.df_climate.loc[k - 1, \"historical_cumulative_non_co2_equivalent_emissions\"]\n            + non_co2_equivalent_emissions.loc[k] / 1000\n        )\n\n    historical_cumulative_co2_emissions = self.df_climate[\"historical_cumulative_co2_emissions\"]\n    historical_cumulative_contrails_equivalent_emissions = self.df_climate[\n        \"historical_cumulative_contrails_equivalent_emissions\"\n    ]\n    historical_cumulative_nox_short_term_o3_increase_equivalent_emissions = self.df_climate[\n        \"historical_cumulative_nox_short_term_o3_increase_equivalent_emissions\"\n    ]\n    historical_cumulative_nox_long_term_o3_decrease_equivalent_emissions = self.df_climate[\n        \"historical_cumulative_nox_long_term_o3_decrease_equivalent_emissions\"\n    ]\n    historical_cumulative_nox_ch4_decrease_equivalent_emissions = self.df_climate[\n        \"historical_cumulative_nox_ch4_decrease_equivalent_emissions\"\n    ]\n    historical_cumulative_nox_stratospheric_water_vapor_decrease_equivalent_emissions = (\n        self.df_climate[\n            \"historical_cumulative_nox_stratospheric_water_vapor_decrease_equivalent_emissions\"\n        ]\n    )\n    historical_cumulative_soot_equivalent_emissions = self.df_climate[\n        \"historical_cumulative_soot_equivalent_emissions\"\n    ]\n    historical_cumulative_h2o_equivalent_emissions = self.df_climate[\n        \"historical_cumulative_h2o_equivalent_emissions\"\n    ]\n    historical_cumulative_sulfur_equivalent_emissions = self.df_climate[\n        \"historical_cumulative_sulfur_equivalent_emissions\"\n    ]\n    historical_cumulative_non_co2_equivalent_emissions = self.df_climate[\n        \"historical_cumulative_non_co2_equivalent_emissions\"\n    ]\n    historical_cumulative_total_equivalent_emissions = (\n        historical_cumulative_co2_emissions + historical_cumulative_non_co2_equivalent_emissions\n    )\n    self.df_climate[\"cumulative_total_equivalent_emissions\"] = (\n        historical_cumulative_total_equivalent_emissions\n    )\n\n    ### From 2020\n    self.df_climate.loc[\n        self.prospection_start_year - 1, \"cumulative_non_co2_equivalent_emissions\"\n    ] = 0.0\n    self.df_climate.loc[\n        self.prospection_start_year - 1, \"cumulative_total_equivalent_emissions\"\n    ] = 0.0\n    for k in range(self.prospection_start_year, self.end_year + 1):\n        self.df_climate.loc[k, \"cumulative_non_co2_equivalent_emissions\"] = (\n            self.df_climate.loc[k - 1, \"cumulative_non_co2_equivalent_emissions\"]\n            + non_co2_equivalent_emissions.loc[k] / 1000\n        )\n        self.df_climate.loc[k, \"cumulative_total_equivalent_emissions\"] = (\n            self.df_climate.loc[k - 1, \"cumulative_total_equivalent_emissions\"]\n            + total_equivalent_emissions.loc[k] / 1000\n        )\n    cumulative_non_co2_equivalent_emissions = self.df_climate[\n        \"cumulative_non_co2_equivalent_emissions\"\n    ]\n    cumulative_total_equivalent_emissions = self.df_climate[\n        \"cumulative_total_equivalent_emissions\"\n    ]\n\n    ## Share CO2/non-CO2\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        self.df_climate.loc[k, \"total_co2_equivalent_emissions_ratio\"] = (\n            total_equivalent_emissions.loc[k] / co2_emissions.loc[k]\n        )\n    total_co2_equivalent_emissions_ratio = self.df_climate[\n        \"total_co2_equivalent_emissions_ratio\"\n    ]\n\n    co2_total_erf_ratio = co2_erf / total_erf * 100\n    self.df_climate.loc[:, \"co2_total_erf_ratio\"] = co2_total_erf_ratio\n\n    # TEMPERATURE\n\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        self.df_climate.loc[k, \"temperature_increase_from_co2_from_aviation\"] = (\n            tcre_coefficient * historical_cumulative_co2_emissions.loc[k]\n        )\n        self.df_climate.loc[k, \"temperature_increase_from_contrails_from_aviation\"] = (\n            tcre_coefficient * historical_cumulative_contrails_equivalent_emissions.loc[k]\n        )\n        self.df_climate.loc[\n            k, \"temperature_increase_from_nox_short_term_o3_increase_from_aviation\"\n        ] = (\n            tcre_coefficient\n            * historical_cumulative_nox_short_term_o3_increase_equivalent_emissions.loc[k]\n        )\n        self.df_climate.loc[\n            k, \"temperature_increase_from_nox_long_term_o3_decrease_from_aviation\"\n        ] = (\n            tcre_coefficient\n            * historical_cumulative_nox_long_term_o3_decrease_equivalent_emissions.loc[k]\n        )\n        self.df_climate.loc[k, \"temperature_increase_from_nox_ch4_decrease_from_aviation\"] = (\n            tcre_coefficient\n            * historical_cumulative_nox_ch4_decrease_equivalent_emissions.loc[k]\n        )\n        self.df_climate.loc[\n            k, \"temperature_increase_from_nox_stratospheric_water_vapor_decrease_from_aviation\"\n        ] = (\n            tcre_coefficient\n            * historical_cumulative_nox_stratospheric_water_vapor_decrease_equivalent_emissions.loc[\n                k\n            ]\n        )\n        self.df_climate.loc[k, \"temperature_increase_from_soot_from_aviation\"] = (\n            tcre_coefficient * historical_cumulative_soot_equivalent_emissions.loc[k]\n        )\n        self.df_climate.loc[k, \"temperature_increase_from_h2o_from_aviation\"] = (\n            tcre_coefficient * historical_cumulative_h2o_equivalent_emissions.loc[k]\n        )\n        self.df_climate.loc[k, \"temperature_increase_from_sulfur_from_aviation\"] = (\n            tcre_coefficient * historical_cumulative_sulfur_equivalent_emissions.loc[k]\n        )\n        self.df_climate.loc[k, \"temperature_increase_from_non_co2_from_aviation\"] = (\n            tcre_coefficient * historical_cumulative_non_co2_equivalent_emissions.loc[k]\n        )\n    temperature_increase_from_co2_from_aviation = self.df_climate[\n        \"temperature_increase_from_co2_from_aviation\"\n    ]\n    temperature_increase_from_contrails_from_aviation = self.df_climate[\n        \"temperature_increase_from_contrails_from_aviation\"\n    ]\n    temperature_increase_from_nox_short_term_o3_increase_from_aviation = self.df_climate[\n        \"temperature_increase_from_nox_short_term_o3_increase_from_aviation\"\n    ]\n    temperature_increase_from_nox_long_term_o3_decrease_from_aviation = self.df_climate[\n        \"temperature_increase_from_nox_long_term_o3_decrease_from_aviation\"\n    ]\n    temperature_increase_from_nox_ch4_decrease_from_aviation = self.df_climate[\n        \"temperature_increase_from_nox_ch4_decrease_from_aviation\"\n    ]\n    temperature_increase_from_nox_stratospheric_water_vapor_decrease_from_aviation = (\n        self.df_climate[\n            \"temperature_increase_from_nox_stratospheric_water_vapor_decrease_from_aviation\"\n        ]\n    )\n    temperature_increase_from_h2o_from_aviation = self.df_climate[\n        \"temperature_increase_from_h2o_from_aviation\"\n    ]\n    temperature_increase_from_soot_from_aviation = self.df_climate[\n        \"temperature_increase_from_soot_from_aviation\"\n    ]\n    temperature_increase_from_sulfur_from_aviation = self.df_climate[\n        \"temperature_increase_from_sulfur_from_aviation\"\n    ]\n    temperature_increase_from_non_co2_from_aviation = self.df_climate[\n        \"temperature_increase_from_non_co2_from_aviation\"\n    ]\n    temperature_increase_from_aviation = (\n        temperature_increase_from_co2_from_aviation\n        + temperature_increase_from_non_co2_from_aviation\n    )\n    self.df_climate[\"temperature_increase_from_aviation\"] = temperature_increase_from_aviation\n\n    return (\n        contrails_equivalent_emissions,\n        nox_short_term_o3_increase_equivalent_emissions,\n        nox_long_term_o3_decrease_equivalent_emissions,\n        nox_ch4_decrease_equivalent_emissions,\n        nox_stratospheric_water_vapor_decrease_equivalent_emissions,\n        soot_equivalent_emissions,\n        h2o_equivalent_emissions,\n        sulfur_equivalent_emissions,\n        non_co2_equivalent_emissions,\n        cumulative_non_co2_equivalent_emissions,\n        total_equivalent_emissions,\n        cumulative_total_equivalent_emissions,\n        total_co2_equivalent_emissions_ratio,\n        co2_total_erf_ratio,\n        temperature_increase_from_aviation,\n        temperature_increase_from_co2_from_aviation,\n        temperature_increase_from_non_co2_from_aviation,\n        temperature_increase_from_contrails_from_aviation,\n        temperature_increase_from_nox_short_term_o3_increase_from_aviation,\n        temperature_increase_from_nox_long_term_o3_decrease_from_aviation,\n        temperature_increase_from_nox_ch4_decrease_from_aviation,\n        temperature_increase_from_nox_stratospheric_water_vapor_decrease_from_aviation,\n        temperature_increase_from_h2o_from_aviation,\n        temperature_increase_from_sulfur_from_aviation,\n        temperature_increase_from_soot_from_aviation,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.climate.climate/#aeromaps.models.impacts.climate.climate.TemperatureSimpleGWPStar","title":"TemperatureSimpleGWPStar","text":"<pre><code>TemperatureSimpleGWPStar(name='temperature_simple_gwpstar', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> Source code in <code>aeromaps/models/impacts/climate/climate.py</code> <pre><code>def __init__(self, name=\"temperature_simple_gwpstar\", *args, **kwargs):\n    super().__init__(name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.climate.climate/#aeromaps.models.impacts.climate.climate.TemperatureSimpleGWPStar.compute","title":"compute","text":"<pre><code>compute(total_erf, co2_erf, co2_emissions, tcre_coefficient)\n</code></pre> <p>Temperature calculation using equivalent emissions (with simple and smooth GWP* method) and TCRE.</p> Source code in <code>aeromaps/models/impacts/climate/climate.py</code> <pre><code>def compute(\n    self,\n    total_erf: pd.Series,\n    co2_erf: pd.Series,\n    co2_emissions: pd.Series,\n    tcre_coefficient: float,\n) -&gt; Tuple[\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n]:\n    \"\"\"Temperature calculation using equivalent emissions (with simple and smooth GWP* method) and TCRE.\"\"\"\n\n    # EQUIVALENT EMISSIONS\n\n    # Smooth on 5 years (except for extrem values)\n\n    self.df_climate.loc[self.climate_historic_start_year, \"total_erf_smooth\"] = (\n        total_erf.loc[self.climate_historic_start_year]\n        + total_erf.loc[self.climate_historic_start_year + 1]\n        + total_erf.loc[self.climate_historic_start_year + 2]\n    ) / 3\n    self.df_climate.loc[self.climate_historic_start_year, \"co2_erf_smooth\"] = (\n        co2_erf.loc[self.climate_historic_start_year]\n        + co2_erf.loc[self.climate_historic_start_year + 1]\n        + co2_erf.loc[self.climate_historic_start_year + 2]\n    ) / 3\n    self.df_climate.loc[self.climate_historic_start_year, \"co2_emissions_smooth\"] = (\n        co2_emissions.loc[self.climate_historic_start_year]\n        + co2_emissions.loc[self.climate_historic_start_year + 1]\n        + co2_emissions.loc[self.climate_historic_start_year + 2]\n    ) / 3\n\n    self.df_climate.loc[self.climate_historic_start_year + 1, \"total_erf_smooth\"] = (\n        total_erf.loc[self.climate_historic_start_year]\n        + total_erf.loc[self.climate_historic_start_year + 1]\n        + total_erf.loc[self.climate_historic_start_year + 2]\n        + total_erf.loc[self.climate_historic_start_year + 3]\n    ) / 4\n    self.df_climate.loc[self.climate_historic_start_year + 1, \"co2_erf_smooth\"] = (\n        co2_erf.loc[self.climate_historic_start_year]\n        + co2_erf.loc[self.climate_historic_start_year + 1]\n        + co2_erf.loc[self.climate_historic_start_year + 2]\n        + co2_erf.loc[self.climate_historic_start_year + 3]\n    ) / 4\n    self.df_climate.loc[self.climate_historic_start_year + 1, \"co2_emissions_smooth\"] = (\n        co2_emissions.loc[self.climate_historic_start_year]\n        + co2_emissions.loc[self.climate_historic_start_year + 1]\n        + co2_emissions.loc[self.climate_historic_start_year + 2]\n        + co2_emissions.loc[self.climate_historic_start_year + 3]\n    ) / 4\n\n    for k in range(self.climate_historic_start_year + 2, self.end_year - 1):\n        self.df_climate.loc[k, \"total_erf_smooth\"] = (\n            total_erf.loc[k - 2]\n            + total_erf.loc[k - 1]\n            + total_erf.loc[k]\n            + total_erf.loc[k + 1]\n            + total_erf.loc[k + 2]\n        ) / 5\n        self.df_climate.loc[k, \"co2_erf_smooth\"] = (\n            co2_erf.loc[k - 2]\n            + co2_erf.loc[k - 1]\n            + co2_erf.loc[k]\n            + co2_erf.loc[k + 1]\n            + co2_erf.loc[k + 2]\n        ) / 5\n        self.df_climate.loc[k, \"co2_emissions_smooth\"] = (\n            co2_emissions.loc[k - 2]\n            + co2_emissions.loc[k - 1]\n            + co2_emissions.loc[k]\n            + co2_emissions.loc[k + 1]\n            + co2_emissions.loc[k + 2]\n        ) / 5\n\n    self.df_climate.loc[self.end_year - 1, \"total_erf_smooth\"] = (\n        total_erf.loc[self.end_year - 3]\n        + total_erf.loc[self.end_year - 2]\n        + total_erf.loc[self.end_year - 1]\n        + total_erf.loc[self.end_year]\n    ) / 4\n    self.df_climate.loc[self.end_year - 1, \"co2_erf_smooth\"] = (\n        co2_erf.loc[self.end_year - 3]\n        + co2_erf.loc[self.end_year - 2]\n        + co2_erf.loc[self.end_year - 1]\n        + co2_erf.loc[self.end_year]\n    ) / 4\n    self.df_climate.loc[self.end_year - 1, \"co2_emissions_smooth\"] = (\n        co2_emissions.loc[self.end_year - 3]\n        + co2_emissions.loc[self.end_year - 2]\n        + co2_emissions.loc[self.end_year - 1]\n        + co2_emissions.loc[self.end_year]\n    ) / 4\n\n    self.df_climate.loc[self.end_year, \"total_erf_smooth\"] = (\n        total_erf.loc[self.end_year - 2]\n        + total_erf.loc[self.end_year - 1]\n        + total_erf.loc[self.end_year]\n    ) / 3\n    self.df_climate.loc[self.end_year, \"co2_erf_smooth\"] = (\n        co2_erf.loc[self.end_year - 2]\n        + co2_erf.loc[self.end_year - 1]\n        + co2_erf.loc[self.end_year]\n    ) / 3\n    self.df_climate.loc[self.end_year, \"co2_emissions_smooth\"] = (\n        co2_emissions.loc[self.end_year - 2]\n        + co2_emissions.loc[self.end_year - 1]\n        + co2_emissions.loc[self.end_year]\n    ) / 3\n\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        self.df_climate.loc[k, \"non_co2_erf_smooth\"] = (\n            self.df_climate.loc[k, \"total_erf_smooth\"]\n            - self.df_climate.loc[k, \"co2_erf_smooth\"]\n        )\n\n    total_erf_smooth = self.df_climate[\"total_erf_smooth\"]\n    co2_erf_smooth = self.df_climate[\"co2_erf_smooth\"]\n    co2_emissions_smooth = self.df_climate[\"co2_emissions_smooth\"]\n    non_co2_erf_smooth = self.df_climate[\"non_co2_erf_smooth\"]\n\n    # Equivalent emissions (Mtwe)\n\n    ## DeltaF/Deltat\n    gwpstar_variation_duration = 20\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        if k - self.climate_historic_start_year &gt;= gwpstar_variation_duration:\n            self.df_climate.loc[k, \"non_co2_erf_smooth_variation\"] = (\n                self.df_climate.loc[k, \"non_co2_erf_smooth\"]\n                - self.df_climate.loc[k - gwpstar_variation_duration, \"non_co2_erf_smooth\"]\n            ) / gwpstar_variation_duration\n        else:\n            self.df_climate.loc[k, \"non_co2_erf_smooth_variation\"] = (\n                self.df_climate.loc[k, \"non_co2_erf_smooth\"] / gwpstar_variation_duration\n            )\n    non_co2_erf_smooth_variation = self.df_climate[\"non_co2_erf_smooth_variation\"]\n\n    ## Non-CO2 equivalent emissions\n    climate_time_horizon = 100\n    co2_agwp_h = AbsoluteGlobalWarmingPotentialCO2Function(climate_time_horizon)\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        self.df_climate.loc[k, \"non_co2_equivalent_emissions\"] = (\n            self.df_climate.loc[k, \"non_co2_erf_smooth_variation\"]\n            * climate_time_horizon\n            / co2_agwp_h\n        )\n    non_co2_equivalent_emissions = self.df_climate[\"non_co2_equivalent_emissions\"]\n\n    ## Total equivalent emissions\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        self.df_climate.loc[k, \"total_equivalent_emissions\"] = (\n            self.df_climate.loc[k, \"non_co2_equivalent_emissions\"]\n            + self.df_climate.loc[k, \"co2_emissions_smooth\"]\n        )\n    total_equivalent_emissions = self.df_climate[\"total_equivalent_emissions\"]\n\n    ## Cumulative smooth CO2, non-CO2 and total equivalent emissions (Gtwe)\n\n    ### From 1940\n    self.df_climate.loc[\n        self.climate_historic_start_year, \"historical_cumulative_co2_emissions_smooth\"\n    ] = co2_emissions_smooth.loc[self.climate_historic_start_year] / 1000\n    self.df_climate.loc[\n        self.climate_historic_start_year, \"historical_cumulative_non_co2_equivalent_emissions\"\n    ] = non_co2_equivalent_emissions[self.climate_historic_start_year] / 1000\n    for k in range(self.climate_historic_start_year + 1, self.end_year + 1):\n        self.df_climate.loc[k, \"historical_cumulative_co2_emissions_smooth\"] = (\n            self.df_climate.loc[k - 1, \"historical_cumulative_co2_emissions_smooth\"]\n            + co2_emissions_smooth.loc[k] / 1000\n        )\n        self.df_climate.loc[k, \"historical_cumulative_non_co2_equivalent_emissions\"] = (\n            self.df_climate.loc[k - 1, \"historical_cumulative_non_co2_equivalent_emissions\"]\n            + non_co2_equivalent_emissions.loc[k] / 1000\n        )\n    historical_cumulative_co2_emissions_smooth = self.df_climate[\n        \"historical_cumulative_co2_emissions_smooth\"\n    ]\n    historical_cumulative_non_co2_equivalent_emissions = self.df_climate[\n        \"historical_cumulative_non_co2_equivalent_emissions\"\n    ]\n    historical_cumulative_total_equivalent_emissions = (\n        historical_cumulative_co2_emissions_smooth\n        + historical_cumulative_non_co2_equivalent_emissions\n    )\n    self.df_climate[\"cumulative_total_equivalent_emissions\"] = (\n        historical_cumulative_total_equivalent_emissions\n    )\n\n    ### From 2020\n    self.df_climate.loc[self.prospection_start_year - 1, \"cumulative_co2_emissions_smooth\"] = (\n        0.0\n    )\n    self.df_climate.loc[\n        self.prospection_start_year - 1, \"cumulative_non_co2_equivalent_emissions\"\n    ] = 0.0\n    for k in range(self.prospection_start_year, self.end_year + 1):\n        self.df_climate.loc[k, \"cumulative_co2_emissions_smooth\"] = (\n            self.df_climate.loc[k - 1, \"cumulative_co2_emissions_smooth\"]\n            + co2_emissions_smooth.loc[k] / 1000\n        )\n        self.df_climate.loc[k, \"cumulative_non_co2_equivalent_emissions\"] = (\n            self.df_climate.loc[k - 1, \"cumulative_non_co2_equivalent_emissions\"]\n            + non_co2_equivalent_emissions.loc[k] / 1000\n        )\n    cumulative_co2_emissions_smooth = self.df_climate[\"cumulative_co2_emissions_smooth\"]\n    cumulative_non_co2_equivalent_emissions = self.df_climate[\n        \"cumulative_non_co2_equivalent_emissions\"\n    ]\n    cumulative_total_equivalent_emissions = (\n        cumulative_co2_emissions_smooth + cumulative_non_co2_equivalent_emissions\n    )\n    self.df_climate[\"cumulative_total_equivalent_emissions\"] = (\n        cumulative_total_equivalent_emissions\n    )\n\n    ## Share CO2/non-CO2\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        self.df_climate.loc[k, \"total_co2_equivalent_emissions_ratio\"] = (\n            total_equivalent_emissions.loc[k] / co2_emissions.loc[k]\n        )\n    total_co2_equivalent_emissions_ratio = self.df_climate[\n        \"total_co2_equivalent_emissions_ratio\"\n    ]\n\n    co2_total_erf_ratio = co2_erf / total_erf * 100\n    self.df_climate.loc[:, \"co2_total_erf_ratio\"] = co2_total_erf_ratio\n\n    # TEMPERATURE\n\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        self.df_climate.loc[k, \"temperature_increase_from_co2_from_aviation\"] = (\n            tcre_coefficient * historical_cumulative_co2_emissions_smooth.loc[k]\n        )\n        self.df_climate.loc[k, \"temperature_increase_from_non_co2_from_aviation\"] = (\n            tcre_coefficient * historical_cumulative_non_co2_equivalent_emissions.loc[k]\n        )\n    temperature_increase_from_co2_from_aviation = self.df_climate[\n        \"temperature_increase_from_co2_from_aviation\"\n    ]\n    temperature_increase_from_non_co2_from_aviation = self.df_climate[\n        \"temperature_increase_from_non_co2_from_aviation\"\n    ]\n\n    temperature_increase_from_aviation = (\n        temperature_increase_from_co2_from_aviation\n        + temperature_increase_from_non_co2_from_aviation\n    )\n    self.df_climate[\"temperature_increase_from_aviation\"] = temperature_increase_from_aviation\n\n    return (\n        total_erf_smooth,\n        co2_erf_smooth,\n        co2_emissions_smooth,\n        cumulative_co2_emissions_smooth,\n        non_co2_erf_smooth,\n        non_co2_erf_smooth_variation,\n        non_co2_equivalent_emissions,\n        cumulative_non_co2_equivalent_emissions,\n        total_equivalent_emissions,\n        cumulative_total_equivalent_emissions,\n        total_co2_equivalent_emissions_ratio,\n        co2_total_erf_ratio,\n        temperature_increase_from_aviation,\n        temperature_increase_from_co2_from_aviation,\n        temperature_increase_from_non_co2_from_aviation,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.climate.climate/#aeromaps.models.impacts.climate.climate.TemperatureFair","title":"TemperatureFair","text":"<pre><code>TemperatureFair(name='temperature_fair', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> Source code in <code>aeromaps/models/impacts/climate/climate.py</code> <pre><code>def __init__(self, name=\"temperature_fair\", *args, **kwargs):\n    super().__init__(name, *args, **kwargs)\n    # Load dataset\n    rcp26_data_path = pth.join(RCP.__path__[0], \"RCP26.csv\")\n    rcp26_data_df = pd.read_csv(rcp26_data_path)\n    self.rcp26_data_df = rcp26_data_df\n    rcp45_data_path = pth.join(RCP.__path__[0], \"RCP45.csv\")\n    rcp45_data_df = pd.read_csv(rcp45_data_path)\n    self.rcp45_data_df = rcp45_data_df\n    rcp60_data_path = pth.join(RCP.__path__[0], \"RCP60.csv\")\n    rcp60_data_df = pd.read_csv(rcp60_data_path)\n    self.rcp60_data_df = rcp60_data_df\n    rcp85_data_path = pth.join(RCP.__path__[0], \"RCP85.csv\")\n    rcp85_data_df = pd.read_csv(rcp85_data_path)\n    self.rcp85_data_df = rcp85_data_df\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.climate.climate/#aeromaps.models.impacts.climate.climate.TemperatureFair.compute","title":"compute","text":"<pre><code>compute(co2_emissions, contrails_erf, nox_short_term_o3_increase_erf, nox_long_term_o3_decrease_erf, nox_ch4_decrease_erf, nox_stratospheric_water_vapor_decrease_erf, h2o_erf, sulfur_emissions, soot_emissions, nox_long_term_o3_decrease_gwpstar_variation_duration, nox_long_term_o3_decrease_gwpstar_s_coefficient, nox_ch4_decrease_gwpstar_variation_duration, nox_ch4_decrease_gwpstar_s_coefficient, nox_stratospheric_water_vapor_decrease_gwpstar_variation_duration, nox_stratospheric_water_vapor_decrease_gwpstar_s_coefficient)\n</code></pre> <p>Temperature calculation using FaIR.</p> Source code in <code>aeromaps/models/impacts/climate/climate.py</code> <pre><code>def compute(\n    self,\n    co2_emissions: pd.Series,\n    contrails_erf: pd.Series,\n    nox_short_term_o3_increase_erf: pd.Series,\n    nox_long_term_o3_decrease_erf: pd.Series,\n    nox_ch4_decrease_erf: pd.Series,\n    nox_stratospheric_water_vapor_decrease_erf: pd.Series,\n    h2o_erf: pd.Series,\n    sulfur_emissions: pd.Series,\n    soot_emissions: pd.Series,\n    nox_long_term_o3_decrease_gwpstar_variation_duration: float,\n    nox_long_term_o3_decrease_gwpstar_s_coefficient: float,\n    nox_ch4_decrease_gwpstar_variation_duration: float,\n    nox_ch4_decrease_gwpstar_s_coefficient: float,\n    nox_stratospheric_water_vapor_decrease_gwpstar_variation_duration: float,\n    nox_stratospheric_water_vapor_decrease_gwpstar_s_coefficient: float,\n) -&gt; Tuple[\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n]:\n    \"\"\"Temperature calculation using FaIR.\"\"\"\n\n    # SPECIES QUANTITIES\n    species_quantities = np.zeros((11, self.end_year - 1765 + 1))\n    rcp_data_df = self.rcp45_data_df\n\n    ## CO2\n\n    ### World CO2\n    species_quantities[0] = (\n        (\n            rcp_data_df[\"FossilCO2\"][0 : self.end_year - 1765 + 1].values\n            + rcp_data_df[\"OtherCO2\"][0 : self.end_year - 1765 + 1].values\n        )\n        * 44\n        / 12\n    )  # Conversion from GtC to GtCO2\n\n    ### Aviation CO2\n    species_quantities[1] = np.zeros(len(species_quantities[0]))\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        species_quantities[1][k - 1765] = (\n            co2_emissions.loc[k] / 1000\n        )  # Conversion from MtCO2 to GtCO2\n\n    ### Aviation NOx - Long-term O3 decrease\n    species_quantities[2] = np.zeros(len(species_quantities[0]))\n    nox_long_term_o3_decrease_equivalent_emissions = GWPStarEquivalentEmissionsFunction(\n        self,\n        emissions_erf=nox_long_term_o3_decrease_erf,\n        gwpstar_variation_duration=nox_long_term_o3_decrease_gwpstar_variation_duration,\n        gwpstar_s_coefficient=nox_long_term_o3_decrease_gwpstar_s_coefficient,\n    )\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        species_quantities[2][k - 1765] = (\n            nox_long_term_o3_decrease_equivalent_emissions.loc[k] / 1000\n        )  # Conversion from MtCO2-we to GtCO2-we\n\n    ### Aviation NOx - CH4 decrease\n    species_quantities[3] = np.zeros(len(species_quantities[0]))\n    nox_ch4_decrease_equivalent_emissions = GWPStarEquivalentEmissionsFunction(\n        self,\n        emissions_erf=nox_ch4_decrease_erf,\n        gwpstar_variation_duration=nox_ch4_decrease_gwpstar_variation_duration,\n        gwpstar_s_coefficient=nox_ch4_decrease_gwpstar_s_coefficient,\n    )\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        species_quantities[3][k - 1765] = (\n            nox_ch4_decrease_equivalent_emissions.loc[k] / 1000\n        )  # Conversion from MtCO2-we  to GtCO2-we\n\n    ### Aviation NOx - Stratospheric water vapor decrease\n    species_quantities[4] = np.zeros(len(species_quantities[0]))\n    nox_stratospheric_water_vapor_decrease_equivalent_emissions = GWPStarEquivalentEmissionsFunction(\n        self,\n        emissions_erf=nox_stratospheric_water_vapor_decrease_erf,\n        gwpstar_variation_duration=nox_stratospheric_water_vapor_decrease_gwpstar_variation_duration,\n        gwpstar_s_coefficient=nox_stratospheric_water_vapor_decrease_gwpstar_s_coefficient,\n    )\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        species_quantities[4][k - 1765] = (\n            nox_stratospheric_water_vapor_decrease_equivalent_emissions.loc[k] / 1000\n        )  # Conversion from MtCO2-we  to GtCO2-we\n\n    ## World CH4\n    species_quantities[5] = rcp_data_df[\"CH4\"][\n        0 : self.end_year - 1765 + 1\n    ].values  # Unit: MtCH4\n\n    ## Aviation contrails\n    species_quantities[6] = np.zeros(len(species_quantities[0]))\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        species_quantities[6][k - 1765] = (\n            contrails_erf.loc[k] / 1000\n        )  # Conversion from mW/m\u00b2 to W/m\u00b2\n\n    ## Aviation NOx - Short-term O3 increase\n    species_quantities[7] = np.zeros(len(species_quantities[0]))\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        species_quantities[7][k - 1765] = (\n            nox_short_term_o3_increase_erf.loc[k] / 1000\n        )  # Conversion from mW/m\u00b2 to W/m\u00b2\n\n    ## Aviation H2O\n    species_quantities[8] = np.zeros(len(species_quantities[0]))\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        species_quantities[8][k - 1765] = h2o_erf.loc[k] / 1000  # Conversion from mW/m\u00b2 to W/m\u00b2\n\n    ## Aviation sulfur\n    species_quantities[9] = np.zeros(len(species_quantities[0]))\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        species_quantities[9][k - 1765] = sulfur_emissions.loc[k]  # Unit: MtSO2\n\n    ## Aviation soot\n    species_quantities[10] = np.zeros(len(species_quantities[0]))\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        species_quantities[10][k - 1765] = soot_emissions.loc[k]  # Unit: MtBC\n\n    # TEMPERATURE ESTIMATION\n\n    ## Total temperature and forcing (world + aviation)\n    total_temperature_list, total_forcing_list = RunFair(\n        self,\n        species_quantities,\n    )\n    ## Temperature increase due to aviation species\n    total_temperature_without_co2_list, total_forcing_without_co2_list = RunFair(\n        self,\n        species_quantities,\n        without=\"Aviation CO2\",\n    )\n    temperature_increase_from_co2_from_aviation_list = (\n        total_temperature_list - total_temperature_without_co2_list\n    )\n    co2_erf_list = 1000 * (total_forcing_list - total_forcing_without_co2_list)\n    temperature_increase_from_contrails_from_aviation_list = (\n        total_temperature_list\n        - RunFair(\n            self,\n            species_quantities,\n            without=\"Aviation contrails\",\n        )[0]\n    )\n    temperature_increase_from_nox_short_term_o3_increase_from_aviation_list = (\n        total_temperature_list\n        - RunFair(\n            self,\n            species_quantities,\n            without=\"Aviation NOx ST O3 increase\",\n        )[0]\n    )\n    temperature_increase_from_nox_long_term_o3_decrease_from_aviation_list = (\n        total_temperature_list\n        - RunFair(\n            self,\n            species_quantities,\n            without=\"Aviation NOx LT O3 decrease\",\n        )[0]\n    )\n    temperature_increase_from_nox_ch4_decrease_from_aviation_list = (\n        total_temperature_list\n        - RunFair(\n            self,\n            species_quantities,\n            without=\"Aviation NOx CH4 decrease\",\n        )[0]\n    )\n    temperature_increase_from_nox_stratospheric_water_vapor_decrease_from_aviation_list = (\n        total_temperature_list\n        - RunFair(\n            self,\n            species_quantities,\n            without=\"Aviation NOx H2O decrease\",\n        )[0]\n    )\n    temperature_increase_from_h2o_from_aviation_list = (\n        total_temperature_list\n        - RunFair(\n            self,\n            species_quantities,\n            without=\"Aviation H2O\",\n        )[0]\n    )\n    temperature_increase_from_sulfur_from_aviation_list = (\n        total_temperature_list\n        - RunFair(\n            self,\n            species_quantities,\n            without=\"Aviation sulfur\",\n        )[0]\n    )\n    temperature_increase_from_soot_from_aviation_list = (\n        total_temperature_list\n        - RunFair(\n            self,\n            species_quantities,\n            without=\"Aviation soot\",\n        )[0]\n    )\n    # temperature_increase_from_aviation_list = total_temperature_list - RunFair(\n    #     self,\n    #     species_quantities,\n    #     without=\"All aviation\",\n    # )\n\n    ## List to dataframe\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        self.df_climate.loc[k, \"temperature_increase_from_co2_from_aviation\"] = (\n            temperature_increase_from_co2_from_aviation_list[k - 1765]\n        )\n        self.df_climate.loc[k, \"co2_erf\"] = co2_erf_list[k - 1765]\n        self.df_climate.loc[k, \"temperature_increase_from_contrails_from_aviation\"] = (\n            temperature_increase_from_contrails_from_aviation_list[k - 1765]\n        )\n        self.df_climate.loc[\n            k, \"temperature_increase_from_nox_short_term_o3_increase_from_aviation\"\n        ] = temperature_increase_from_nox_short_term_o3_increase_from_aviation_list[k - 1765]\n        self.df_climate.loc[\n            k, \"temperature_increase_from_nox_long_term_o3_decrease_from_aviation\"\n        ] = temperature_increase_from_nox_long_term_o3_decrease_from_aviation_list[k - 1765]\n        self.df_climate.loc[k, \"temperature_increase_from_nox_ch4_decrease_from_aviation\"] = (\n            temperature_increase_from_nox_ch4_decrease_from_aviation_list[k - 1765]\n        )\n        self.df_climate.loc[\n            k, \"temperature_increase_from_nox_stratospheric_water_vapor_decrease_from_aviation\"\n        ] = temperature_increase_from_nox_stratospheric_water_vapor_decrease_from_aviation_list[\n            k - 1765\n        ]\n        self.df_climate.loc[k, \"temperature_increase_from_h2o_from_aviation\"] = (\n            temperature_increase_from_h2o_from_aviation_list[k - 1765]\n        )\n        self.df_climate.loc[k, \"temperature_increase_from_sulfur_from_aviation\"] = (\n            temperature_increase_from_sulfur_from_aviation_list[k - 1765]\n        )\n        self.df_climate.loc[k, \"temperature_increase_from_soot_from_aviation\"] = (\n            temperature_increase_from_soot_from_aviation_list[k - 1765]\n        )\n\n    temperature_increase_from_co2_from_aviation = self.df_climate[\n        \"temperature_increase_from_co2_from_aviation\"\n    ]\n    co2_erf = self.df_climate[\"co2_erf\"]\n    temperature_increase_from_contrails_from_aviation = self.df_climate[\n        \"temperature_increase_from_contrails_from_aviation\"\n    ]\n    temperature_increase_from_nox_short_term_o3_increase_from_aviation = self.df_climate[\n        \"temperature_increase_from_nox_short_term_o3_increase_from_aviation\"\n    ]\n    temperature_increase_from_nox_long_term_o3_decrease_from_aviation = self.df_climate[\n        \"temperature_increase_from_nox_long_term_o3_decrease_from_aviation\"\n    ]\n    temperature_increase_from_nox_ch4_decrease_from_aviation = self.df_climate[\n        \"temperature_increase_from_nox_ch4_decrease_from_aviation\"\n    ]\n    temperature_increase_from_nox_stratospheric_water_vapor_decrease_from_aviation = (\n        self.df_climate[\n            \"temperature_increase_from_nox_stratospheric_water_vapor_decrease_from_aviation\"\n        ]\n    )\n    temperature_increase_from_h2o_from_aviation = self.df_climate[\n        \"temperature_increase_from_h2o_from_aviation\"\n    ]\n    temperature_increase_from_sulfur_from_aviation = self.df_climate[\n        \"temperature_increase_from_sulfur_from_aviation\"\n    ]\n    temperature_increase_from_soot_from_aviation = self.df_climate[\n        \"temperature_increase_from_soot_from_aviation\"\n    ]\n\n    ## Temperature increase due to aviation\n    temperature_increase_from_non_co2_from_aviation = (\n        temperature_increase_from_contrails_from_aviation\n        + temperature_increase_from_nox_short_term_o3_increase_from_aviation\n        + temperature_increase_from_nox_long_term_o3_decrease_from_aviation\n        + temperature_increase_from_nox_ch4_decrease_from_aviation\n        + temperature_increase_from_nox_stratospheric_water_vapor_decrease_from_aviation\n        + temperature_increase_from_h2o_from_aviation\n        + temperature_increase_from_sulfur_from_aviation\n        + temperature_increase_from_soot_from_aviation\n    )\n    temperature_increase_from_aviation = (\n        temperature_increase_from_co2_from_aviation\n        + temperature_increase_from_non_co2_from_aviation\n    )\n\n    self.df_climate[\"temperature_increase_from_non_co2_from_aviation\"] = (\n        temperature_increase_from_non_co2_from_aviation\n    )\n    self.df_climate[\"temperature_increase_from_aviation\"] = temperature_increase_from_aviation\n\n    return (\n        temperature_increase_from_aviation,\n        temperature_increase_from_co2_from_aviation,\n        co2_erf,\n        temperature_increase_from_non_co2_from_aviation,\n        temperature_increase_from_contrails_from_aviation,\n        temperature_increase_from_nox_short_term_o3_increase_from_aviation,\n        temperature_increase_from_nox_long_term_o3_decrease_from_aviation,\n        temperature_increase_from_nox_ch4_decrease_from_aviation,\n        temperature_increase_from_nox_stratospheric_water_vapor_decrease_from_aviation,\n        temperature_increase_from_h2o_from_aviation,\n        temperature_increase_from_sulfur_from_aviation,\n        temperature_increase_from_soot_from_aviation,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.climate/","title":"<code>aeromaps.models.impacts.climate</code>","text":"Warning <p>Package to be deprecated before V1</p>"},{"location":"full_doc/aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing/","title":"<code>aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing</code>","text":"Warning <p>Module to be deprecated before V1</p>"},{"location":"full_doc/aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing/#aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing.SimplifiedERFCo2","title":"SimplifiedERFCo2","text":"<pre><code>SimplifiedERFCo2(name='simplified_effective_radiative_forcing_co2', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> Source code in <code>aeromaps/models/impacts/effective_radiative_forcing/effective_radiative_forcing.py</code> <pre><code>def __init__(self, name=\"simplified_effective_radiative_forcing_co2\", *args, **kwargs):\n    super().__init__(name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing/#aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing.SimplifiedERFCo2.compute","title":"compute","text":"<pre><code>compute(co2_emissions)\n</code></pre> <p>ERF calculation for CO2 emissions with a simplified method.</p> Source code in <code>aeromaps/models/impacts/effective_radiative_forcing/effective_radiative_forcing.py</code> <pre><code>def compute(\n    self,\n    co2_emissions: pd.Series,\n) -&gt; Tuple[\n    pd.Series,\n    pd.Series,\n]:\n    \"\"\"ERF calculation for CO2 emissions with a simplified method.\"\"\"\n\n    # CO2\n    h = 100  # Climate time horizon\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        self.df_climate.loc[k, \"annual_co2_erf\"] = (\n            co2_emissions.loc[k] * AbsoluteGlobalWarmingPotentialCO2Function(h) / h\n        )\n    self.df_climate.loc[self.climate_historic_start_year, \"co2_erf\"] = self.df_climate.loc[\n        self.climate_historic_start_year, \"annual_co2_erf\"\n    ]\n    for k in range(self.climate_historic_start_year + 1, self.end_year + 1):\n        self.df_climate.loc[k, \"co2_erf\"] = (\n            self.df_climate.loc[k - 1, \"co2_erf\"] + self.df_climate.loc[k, \"annual_co2_erf\"]\n        )\n    annual_co2_erf = self.df_climate[\"annual_co2_erf\"]\n    co2_erf = self.df_climate[\"co2_erf\"]\n\n    return (\n        annual_co2_erf,\n        co2_erf,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing/#aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing.SimplifiedERFNox","title":"SimplifiedERFNox","text":"<pre><code>SimplifiedERFNox(name='simplified_effective_radiative_forcing_nox', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> Source code in <code>aeromaps/models/impacts/effective_radiative_forcing/effective_radiative_forcing.py</code> <pre><code>def __init__(self, name=\"simplified_effective_radiative_forcing_nox\", *args, **kwargs):\n    super().__init__(name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing/#aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing.SimplifiedERFNox.compute","title":"compute","text":"<pre><code>compute(nox_emissions, erf_coefficient_nox)\n</code></pre> <p>ERF calculation for NOx emissions with a simplified method.</p> Source code in <code>aeromaps/models/impacts/effective_radiative_forcing/effective_radiative_forcing.py</code> <pre><code>def compute(\n    self,\n    nox_emissions: pd.Series,\n    erf_coefficient_nox: float,\n) -&gt; pd.Series:\n    \"\"\"ERF calculation for NOx emissions with a simplified method.\"\"\"\n\n    # NOx\n    n_emissions = nox_emissions * 14 / 46\n    self.df_climate[\"nox_erf\"] = n_emissions * erf_coefficient_nox\n    nox_erf = self.df_climate[\"nox_erf\"]\n\n    return nox_erf\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing/#aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing.ERFNox","title":"ERFNox","text":"<pre><code>ERFNox(name='effective_radiative_forcing_nox', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> Source code in <code>aeromaps/models/impacts/effective_radiative_forcing/effective_radiative_forcing.py</code> <pre><code>def __init__(self, name=\"effective_radiative_forcing_nox\", *args, **kwargs):\n    super().__init__(name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing/#aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing.ERFNox.compute","title":"compute","text":"<pre><code>compute(nox_emissions, erf_coefficient_nox_short_term_o3_increase, erf_coefficient_nox_long_term_o3_decrease, erf_coefficient_nox_ch4_decrease, erf_coefficient_nox_stratospheric_water_vapor_decrease)\n</code></pre> <p>ERF calculation for NOx emissions.</p> Source code in <code>aeromaps/models/impacts/effective_radiative_forcing/effective_radiative_forcing.py</code> <pre><code>def compute(\n    self,\n    nox_emissions: pd.Series,\n    erf_coefficient_nox_short_term_o3_increase: float,\n    erf_coefficient_nox_long_term_o3_decrease: float,\n    erf_coefficient_nox_ch4_decrease: float,\n    erf_coefficient_nox_stratospheric_water_vapor_decrease: float,\n) -&gt; Tuple[\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n]:\n    \"\"\"ERF calculation for NOx emissions.\"\"\"\n\n    # NOx\n    n_emissions = nox_emissions * 14 / 46  # Molar masses of N and NOx\n    self.df_climate[\"nox_short_term_o3_increase_erf\"] = (\n        n_emissions * erf_coefficient_nox_short_term_o3_increase\n    )\n    self.df_climate[\"nox_long_term_o3_decrease_erf\"] = (\n        n_emissions * erf_coefficient_nox_long_term_o3_decrease\n    )\n    self.df_climate[\"nox_ch4_decrease_erf\"] = n_emissions * erf_coefficient_nox_ch4_decrease\n    self.df_climate[\"nox_stratospheric_water_vapor_decrease_erf\"] = (\n        n_emissions * erf_coefficient_nox_stratospheric_water_vapor_decrease\n    )\n    nox_short_term_o3_increase_erf = self.df_climate[\"nox_short_term_o3_increase_erf\"]\n    nox_long_term_o3_decrease_erf = self.df_climate[\"nox_long_term_o3_decrease_erf\"]\n    nox_ch4_decrease_erf = self.df_climate[\"nox_ch4_decrease_erf\"]\n    nox_stratospheric_water_vapor_decrease_erf = self.df_climate[\n        \"nox_stratospheric_water_vapor_decrease_erf\"\n    ]\n    nox_erf = (\n        nox_short_term_o3_increase_erf\n        + nox_long_term_o3_decrease_erf\n        + nox_ch4_decrease_erf\n        + nox_stratospheric_water_vapor_decrease_erf\n    )\n    self.df_climate[\"nox_erf\"] = nox_erf\n\n    return (\n        nox_short_term_o3_increase_erf,\n        nox_long_term_o3_decrease_erf,\n        nox_ch4_decrease_erf,\n        nox_stratospheric_water_vapor_decrease_erf,\n        nox_erf,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing/#aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing.ERFOthers","title":"ERFOthers","text":"<pre><code>ERFOthers(name='effective_radiative_forcing_others', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> Source code in <code>aeromaps/models/impacts/effective_radiative_forcing/effective_radiative_forcing.py</code> <pre><code>def __init__(self, name=\"effective_radiative_forcing_others\", *args, **kwargs):\n    super().__init__(name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing/#aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing.ERFOthers.compute","title":"compute","text":"<pre><code>compute(soot_emissions, h2o_emissions, sulfur_emissions, erf_coefficient_contrails, erf_coefficient_soot, erf_coefficient_h2o, erf_coefficient_sulfur, total_aircraft_distance, operations_contrails_gain, fuel_effect_correction_contrails)\n</code></pre> <p>ERF calculation for the other climate impacts of aviation.</p> Source code in <code>aeromaps/models/impacts/effective_radiative_forcing/effective_radiative_forcing.py</code> <pre><code>def compute(\n    self,\n    soot_emissions: pd.Series,\n    h2o_emissions: pd.Series,\n    sulfur_emissions: pd.Series,\n    erf_coefficient_contrails: float,\n    erf_coefficient_soot: float,\n    erf_coefficient_h2o: float,\n    erf_coefficient_sulfur: float,\n    total_aircraft_distance: pd.Series,\n    operations_contrails_gain: pd.Series,\n    fuel_effect_correction_contrails: pd.Series,\n) -&gt; Tuple[pd.Series, pd.Series, pd.Series, pd.Series, pd.Series]:\n    \"\"\"ERF calculation for the other climate impacts of aviation.\"\"\"\n\n    # Contrails\n    for k in range(self.climate_historic_start_year, self.end_year + 1):\n        self.df_climate.loc[k, \"contrails_erf\"] = (\n            total_aircraft_distance.loc[k] * erf_coefficient_contrails\n        )\n    for k in range(self.historic_start_year, self.end_year + 1):\n        self.df_climate.loc[k, \"contrails_erf\"] = (\n            total_aircraft_distance.loc[k]\n            * erf_coefficient_contrails\n            * (1 - operations_contrails_gain.loc[k] / 100)\n            * fuel_effect_correction_contrails.loc[k]\n        )\n    contrails_erf = self.df_climate[\"contrails_erf\"]\n\n    # Others\n    self.df_climate[\"soot_erf\"] = soot_emissions * erf_coefficient_soot\n    self.df_climate[\"h2o_erf\"] = h2o_emissions * erf_coefficient_h2o\n    self.df_climate[\"sulfur_erf\"] = sulfur_emissions * erf_coefficient_sulfur\n    soot_erf = self.df_climate[\"soot_erf\"]\n    h2o_erf = self.df_climate[\"h2o_erf\"]\n    sulfur_erf = self.df_climate[\"sulfur_erf\"]\n    self.df_climate[\"aerosol_erf\"] = soot_erf + sulfur_erf\n    aerosol_erf = self.df_climate[\"aerosol_erf\"]\n\n    return (\n        contrails_erf,\n        soot_erf,\n        h2o_erf,\n        sulfur_erf,\n        aerosol_erf,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing/#aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing.ERFTotal","title":"ERFTotal","text":"<pre><code>ERFTotal(name='effective_radiative_forcing_total', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> Source code in <code>aeromaps/models/impacts/effective_radiative_forcing/effective_radiative_forcing.py</code> <pre><code>def __init__(self, name=\"effective_radiative_forcing_total\", *args, **kwargs):\n    super().__init__(name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing/#aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing.ERFTotal.compute","title":"compute","text":"<pre><code>compute(co2_erf, contrails_erf, h2o_erf, nox_erf, soot_erf, sulfur_erf)\n</code></pre> <p>ERF calculation for the total climate impact of aviation.</p> Source code in <code>aeromaps/models/impacts/effective_radiative_forcing/effective_radiative_forcing.py</code> <pre><code>def compute(\n    self,\n    co2_erf: pd.Series,\n    contrails_erf: pd.Series,\n    h2o_erf: pd.Series,\n    nox_erf: pd.Series,\n    soot_erf: pd.Series,\n    sulfur_erf: pd.Series,\n) -&gt; pd.Series:\n    \"\"\"ERF calculation for the total climate impact of aviation.\"\"\"\n\n    self.df_climate[\"total_erf\"] = (\n        co2_erf + contrails_erf + h2o_erf + nox_erf + soot_erf + sulfur_erf\n    )\n    total_erf = self.df_climate[\"total_erf\"]\n\n    return total_erf\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing/#aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing.ERFDetailed","title":"ERFDetailed","text":"<pre><code>ERFDetailed(name='effective_radiative_forcing_detailed', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> Source code in <code>aeromaps/models/impacts/effective_radiative_forcing/effective_radiative_forcing.py</code> <pre><code>def __init__(self, name=\"effective_radiative_forcing_detailed\", *args, **kwargs):\n    super().__init__(name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing/#aeromaps.models.impacts.effective_radiative_forcing.effective_radiative_forcing.ERFDetailed.compute","title":"compute","text":"<pre><code>compute(co2_erf, contrails_erf, h2o_erf, nox_erf)\n</code></pre> <p>ERF calculation for helping plot display.</p> Source code in <code>aeromaps/models/impacts/effective_radiative_forcing/effective_radiative_forcing.py</code> <pre><code>def compute(\n    self,\n    co2_erf: pd.Series,\n    contrails_erf: pd.Series,\n    h2o_erf: pd.Series,\n    nox_erf: pd.Series,\n) -&gt; Tuple[pd.Series, pd.Series, pd.Series]:\n    \"\"\"ERF calculation for helping plot display.\"\"\"\n\n    self.df_climate[\"co2_h2o_erf\"] = co2_erf + h2o_erf\n    self.df_climate[\"co2_h2o_nox_erf\"] = co2_erf + h2o_erf + nox_erf\n    self.df_climate[\"co2_h2o_nox_contrails_erf\"] = co2_erf + h2o_erf + nox_erf + contrails_erf\n\n    co2_h2o_erf = self.df_climate[\"co2_h2o_erf\"]\n    co2_h2o_nox_erf = self.df_climate[\"co2_h2o_nox_erf\"]\n    co2_h2o_nox_contrails_erf = self.df_climate[\"co2_h2o_nox_contrails_erf\"]\n\n    return co2_h2o_erf, co2_h2o_nox_erf, co2_h2o_nox_contrails_erf\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.effective_radiative_forcing/","title":"<code>aeromaps.models.impacts.effective_radiative_forcing</code>","text":"Warning <p>Package to be deprecated before V1</p>"},{"location":"full_doc/aeromaps.models.impacts.emissions.carbon_offset/","title":"<code>aeromaps.models.impacts.emissions.carbon_offset</code>","text":"<p>carbon_offset</p> <p>=============================== Module to compute effects of carbon offsets.</p>"},{"location":"full_doc/aeromaps.models.impacts.emissions.carbon_offset/#aeromaps.models.impacts.emissions.carbon_offset.LevelCarbonOffset","title":"LevelCarbonOffset","text":"<pre><code>LevelCarbonOffset(name='level_carbon_offset', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute carbon offset required to level emissions to offsetting targets compared to 2019 emissions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('level_carbon_offset' by default).</p> <code>'level_carbon_offset'</code> Source code in <code>aeromaps/models/impacts/emissions/carbon_offset.py</code> <pre><code>def __init__(self, name=\"level_carbon_offset\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.carbon_offset/#aeromaps.models.impacts.emissions.carbon_offset.LevelCarbonOffset.compute","title":"compute","text":"<pre><code>compute(co2_emissions, carbon_offset_baseline_level_vs_2019_reference_periods, carbon_offset_baseline_level_vs_2019_reference_periods_values)\n</code></pre> <p>Execute the computation of carbon offset required to level emissions.</p> <p>Parameters:</p> Name Type Description Default <code>co2_emissions</code> <code>Series</code> <p>CO2 emissions trajectory [MtCO2].</p> required <code>carbon_offset_baseline_level_vs_2019_reference_periods</code> <code>list</code> <p>Reference periods for the level of CO2 emissions relative to 2019 from which higher emissions are offset [years].</p> required <code>carbon_offset_baseline_level_vs_2019_reference_periods_values</code> <code>list</code> <p>Level of CO2 emissions relative to 2019 from which higher emissions are offset for the reference periods [%].</p> required <p>Returns:</p> Type Description <code>carbon_offset_baseline_level_vs_2019</code> <p>Level of CO2 emissions relative to 2019 from which higher emissions are offset [%].</p> <code>level_carbon_offset</code> <p>Annual carbon offset due to offsetting for a given level of emissions [MtCO2].</p> Source code in <code>aeromaps/models/impacts/emissions/carbon_offset.py</code> <pre><code>def compute(\n    self,\n    co2_emissions: pd.Series,\n    carbon_offset_baseline_level_vs_2019_reference_periods: list,\n    carbon_offset_baseline_level_vs_2019_reference_periods_values: list,\n) -&gt; Tuple[pd.Series, pd.Series]:\n    \"\"\"\n    Execute the computation of carbon offset required to level emissions.\n\n    Parameters\n    ----------\n    co2_emissions\n        CO2 emissions trajectory [MtCO2].\n    carbon_offset_baseline_level_vs_2019_reference_periods\n        Reference periods for the level of CO2 emissions relative to 2019 from which higher emissions are offset [years].\n    carbon_offset_baseline_level_vs_2019_reference_periods_values\n        Level of CO2 emissions relative to 2019 from which higher emissions are offset for the reference periods [%].\n\n    Returns\n    -------\n    carbon_offset_baseline_level_vs_2019\n        Level of CO2 emissions relative to 2019 from which higher emissions are offset [%].\n    level_carbon_offset\n        Annual carbon offset due to offsetting for a given level of emissions [MtCO2].\n\n    \"\"\"\n    carbon_offset_baseline_level_vs_2019 = aeromaps_leveling_function(\n        self,\n        carbon_offset_baseline_level_vs_2019_reference_periods,\n        carbon_offset_baseline_level_vs_2019_reference_periods_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"carbon_offset_baseline_level_vs_2019\"] = (\n        carbon_offset_baseline_level_vs_2019\n    )\n\n    for k in range(self.historic_start_year, self.prospection_start_year):\n        self.df.loc[k, \"level_carbon_offset\"] = 0.0\n\n    for k in range(self.prospection_start_year, self.end_year + 1):\n        if (\n            co2_emissions.loc[k]\n            &gt; co2_emissions.loc[2019]\n            * self.df.loc[k, \"carbon_offset_baseline_level_vs_2019\"]\n            / 100\n        ):\n            self.df.loc[k, \"level_carbon_offset\"] = (\n                co2_emissions.loc[k]\n                - co2_emissions.loc[2019]\n                * self.df.loc[k, \"carbon_offset_baseline_level_vs_2019\"]\n                / 100\n            )\n        else:\n            self.df.loc[k, \"level_carbon_offset\"] = 0.0\n\n    level_carbon_offset = self.df[\"level_carbon_offset\"]\n\n    return (carbon_offset_baseline_level_vs_2019, level_carbon_offset)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.carbon_offset/#aeromaps.models.impacts.emissions.carbon_offset.ResidualCarbonOffset","title":"ResidualCarbonOffset","text":"<pre><code>ResidualCarbonOffset(name='residual_carbon_offset', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute carbon offset to match a share of residual emissions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('residual_carbon_offset' by default).</p> <code>'residual_carbon_offset'</code> Source code in <code>aeromaps/models/impacts/emissions/carbon_offset.py</code> <pre><code>def __init__(self, name=\"residual_carbon_offset\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.carbon_offset/#aeromaps.models.impacts.emissions.carbon_offset.ResidualCarbonOffset.compute","title":"compute","text":"<pre><code>compute(co2_emissions, level_carbon_offset, residual_carbon_offset_share_reference_years, residual_carbon_offset_share_reference_years_values)\n</code></pre> <p>Execute the computation of carbon offset to match a share of residual emissions.</p> <p>Parameters:</p> Name Type Description Default <code>co2_emissions</code> <code>Series</code> <p>CO2 emissions trajectory [MtCO2].</p> required <code>level_carbon_offset</code> <code>Series</code> <p>Annual carbon offset due to offsetting for a given level of emissions [MtCO2].</p> required <code>residual_carbon_offset_share_reference_years</code> <code>list</code> <p>Reference years for the share of remaining CO2 emissions offset [years].</p> required <code>residual_carbon_offset_share_reference_years_values</code> <code>list</code> <p>Share of residual emissions to be offset for the reference years [%].</p> required <p>Returns:</p> Type Description <code>residual_carbon_offset_share</code> <p>Share of residual emissions to be offset [%].</p> <code>residual_carbon_offset</code> <p>Annual carbon offset due to offsetting of a given share of the remaining emissions [MtCO2].</p> Source code in <code>aeromaps/models/impacts/emissions/carbon_offset.py</code> <pre><code>def compute(\n    self,\n    co2_emissions: pd.Series,\n    level_carbon_offset: pd.Series,\n    residual_carbon_offset_share_reference_years: list,\n    residual_carbon_offset_share_reference_years_values: list,\n) -&gt; Tuple[pd.Series, pd.Series]:\n    \"\"\"\n    Execute the computation of carbon offset to match a share of residual emissions.\n\n    Parameters\n    ----------\n    co2_emissions\n        CO2 emissions trajectory [MtCO2].\n    level_carbon_offset\n        Annual carbon offset due to offsetting for a given level of emissions [MtCO2].\n    residual_carbon_offset_share_reference_years\n        Reference years for the share of remaining CO2 emissions offset [years].\n    residual_carbon_offset_share_reference_years_values\n        Share of residual emissions to be offset for the reference years [%].\n\n    Returns\n    -------\n    residual_carbon_offset_share\n        Share of residual emissions to be offset [%].\n    residual_carbon_offset\n        Annual carbon offset due to offsetting of a given share of the remaining emissions [MtCO2].\n\n    \"\"\"\n    residual_carbon_offset_share_prospective = aeromaps_interpolation_function(\n        self,\n        residual_carbon_offset_share_reference_years,\n        residual_carbon_offset_share_reference_years_values,\n        model_name=self.name,\n    )\n    self.df.loc[:, \"residual_carbon_offset_share\"] = residual_carbon_offset_share_prospective\n    for k in range(self.historic_start_year, self.prospection_start_year):\n        self.df.loc[k, \"residual_carbon_offset_share\"] = 0.0\n    residual_carbon_offset_share = self.df[\"residual_carbon_offset_share\"]\n\n    for k in range(self.historic_start_year, self.end_year + 1):\n        self.df.loc[k, \"residual_carbon_offset\"] = (\n            self.df.loc[k, \"residual_carbon_offset_share\"]\n            / 100\n            * (co2_emissions.loc[k] - level_carbon_offset.loc[k])\n        )\n\n    residual_carbon_offset = self.df[\"residual_carbon_offset\"]\n\n    return (residual_carbon_offset_share, residual_carbon_offset)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.carbon_offset/#aeromaps.models.impacts.emissions.carbon_offset.CarbonOffset","title":"CarbonOffset","text":"<pre><code>CarbonOffset(name='carbon_offset', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute total carbon offset.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('carbon_offset' by default).</p> <code>'carbon_offset'</code> Source code in <code>aeromaps/models/impacts/emissions/carbon_offset.py</code> <pre><code>def __init__(self, name=\"carbon_offset\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.carbon_offset/#aeromaps.models.impacts.emissions.carbon_offset.CarbonOffset.compute","title":"compute","text":"<pre><code>compute(level_carbon_offset, residual_carbon_offset)\n</code></pre> <p>Execute the computation of total carbon offset.</p> <p>Parameters:</p> Name Type Description Default <code>level_carbon_offset</code> <code>Series</code> <p>Annual carbon offset due to offsetting for a given level of emissions [MtCO2].</p> required <code>residual_carbon_offset</code> <code>Series</code> <p>Annual carbon offset due to offsetting of a given share of the remaining emissions [MtCO2].</p> required <p>Returns:</p> Type Description <code>carbon_offset</code> <p>Total annual carbon offset [MtCO2].</p> Source code in <code>aeromaps/models/impacts/emissions/carbon_offset.py</code> <pre><code>def compute(\n    self,\n    level_carbon_offset: pd.Series,\n    residual_carbon_offset: pd.Series,\n) -&gt; pd.Series:\n    \"\"\"\n    Execute the computation of total carbon offset.\n\n    Parameters\n    ----------\n    level_carbon_offset\n        Annual carbon offset due to offsetting for a given level of emissions [MtCO2].\n    residual_carbon_offset\n        Annual carbon offset due to offsetting of a given share of the remaining emissions [MtCO2].\n\n    Returns\n    -------\n    carbon_offset\n        Total annual carbon offset [MtCO2].\n\n    \"\"\"\n    carbon_offset = level_carbon_offset + residual_carbon_offset\n\n    self.df.loc[:, \"carbon_offset\"] = carbon_offset\n\n    return carbon_offset\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.carbon_offset/#aeromaps.models.impacts.emissions.carbon_offset.CumulativeCarbonOffset","title":"CumulativeCarbonOffset","text":"<pre><code>CumulativeCarbonOffset(name='cumulative_carbon_offset', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute cumulative carbon offset.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('cumulative_carbon_offset' by default).</p> <code>'cumulative_carbon_offset'</code> Source code in <code>aeromaps/models/impacts/emissions/carbon_offset.py</code> <pre><code>def __init__(self, name=\"cumulative_carbon_offset\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.carbon_offset/#aeromaps.models.impacts.emissions.carbon_offset.CumulativeCarbonOffset.compute","title":"compute","text":"<pre><code>compute(carbon_offset)\n</code></pre> <p>Execute the computation of cumulative carbon offset.</p> <p>Parameters:</p> Name Type Description Default <code>carbon_offset</code> <code>Series</code> <p>Total annual carbon offset [MtCO2].</p> required <p>Returns:</p> Type Description <code>cumulative_carbon_offset</code> <p>Cumulative carbon offset from air transport [GtCO2].</p> Source code in <code>aeromaps/models/impacts/emissions/carbon_offset.py</code> <pre><code>def compute(\n    self,\n    carbon_offset: pd.Series,\n) -&gt; pd.Series:\n    \"\"\"\n    Execute the computation of cumulative carbon offset.\n\n    Parameters\n    ----------\n    carbon_offset\n        Total annual carbon offset [MtCO2].\n\n    Returns\n    -------\n    cumulative_carbon_offset\n        Cumulative carbon offset from air transport [GtCO2].\n\n    \"\"\"\n    self.df.loc[self.prospection_start_year - 1, \"cumulative_carbon_offset\"] = 0.0\n    for k in range(self.prospection_start_year, self.end_year + 1):\n        self.df.loc[k, \"cumulative_carbon_offset\"] = (\n            self.df.loc[k - 1, \"cumulative_carbon_offset\"] + carbon_offset.loc[k] / 1000\n        )\n\n    cumulative_carbon_offset = self.df[\"cumulative_carbon_offset\"]\n\n    return cumulative_carbon_offset\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.co2_emissions/","title":"<code>aeromaps.models.impacts.emissions.co2_emissions</code>","text":""},{"location":"full_doc/aeromaps.models.impacts.emissions.co2_emissions/#aeromaps.models.impacts.emissions.co2_emissions--co2_emissions","title":"co2_emissions","text":"<p>This module contains models for calculating CO2 emissions and related factors.</p>"},{"location":"full_doc/aeromaps.models.impacts.emissions.co2_emissions/#aeromaps.models.impacts.emissions.co2_emissions.KayaFactors","title":"KayaFactors","text":"<pre><code>KayaFactors(name='kaya_factors', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute Kaya factors for CO2 emissions calculation.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('kaya_factors' by default).</p> <code>'kaya_factors'</code> Source code in <code>aeromaps/models/impacts/emissions/co2_emissions.py</code> <pre><code>def __init__(self, name=\"kaya_factors\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.co2_emissions/#aeromaps.models.impacts.emissions.co2_emissions.KayaFactors.compute","title":"compute","text":"<pre><code>compute(ask, rtk, energy_consumption_passenger_dropin_fuel_without_operations, energy_consumption_passenger_hydrogen_without_operations, energy_consumption_passenger_electric_without_operations, energy_consumption_passenger_dropin_fuel, energy_consumption_passenger_hydrogen, energy_consumption_passenger_electric, energy_consumption_freight_dropin_fuel_without_operations, energy_consumption_freight_hydrogen_without_operations, energy_consumption_freight_electric_without_operations, energy_consumption_freight_dropin_fuel, energy_consumption_freight_hydrogen, energy_consumption_freight_electric, energy_consumption_dropin_fuel, energy_consumption_hydrogen, energy_consumption_electric, energy_consumption, dropin_fuel_mean_co2_emission_factor, hydrogen_mean_co2_emission_factor, electric_mean_co2_emission_factor)\n</code></pre> <p>Execute the computation of Kaya factors for CO2 emissions calculation.</p> <p>Parameters:</p> Name Type Description Default <code>ask</code> <code>Series</code> <p>Available seat kilometers (ASK) [ASK].</p> required <code>rtk</code> <code>Series</code> <p>Revenue ton kilometers (RTK) [RTK].</p> required <code>energy_consumption_passenger_dropin_fuel_without_operations</code> <code>Series</code> <p>Energy consumption for passenger transport using drop-in fuels without operational improvements [MJ].</p> required <code>energy_consumption_passenger_hydrogen_without_operations</code> <code>Series</code> <p>Energy consumption for passenger transport using hydrogen without operational improvements [MJ].</p> required <code>energy_consumption_passenger_electric_without_operations</code> <code>Series</code> <p>Energy consumption for passenger transport using electricity without operational improvements [MJ].</p> required <code>energy_consumption_passenger_dropin_fuel</code> <code>Series</code> <p>Energy consumption for passenger transport using drop-in fuels [MJ].</p> required <code>energy_consumption_passenger_hydrogen</code> <code>Series</code> <p>Energy consumption for passenger transport using hydrogen [MJ].</p> required <code>energy_consumption_passenger_electric</code> <code>Series</code> <p>Energy consumption for passenger transport using electricity [MJ].</p> required <code>energy_consumption_freight_dropin_fuel_without_operations</code> <code>Series</code> <p>Energy consumption for freight transport using drop-in fuels without operational improvements [MJ].</p> required <code>energy_consumption_freight_hydrogen_without_operations</code> <code>Series</code> <p>Energy consumption for freight transport using hydrogen without operational improvements [MJ].</p> required <code>energy_consumption_freight_electric_without_operations</code> <code>Series</code> <p>Energy consumption for freight transport using electricity without operational improvements [MJ].</p> required <code>energy_consumption_freight_dropin_fuel</code> <code>Series</code> <p>Energy consumption for freight transport using drop-in fuels [MJ].</p> required <code>energy_consumption_freight_hydrogen</code> <code>Series</code> <p>Energy consumption for freight transport using hydrogen [MJ].</p> required <code>energy_consumption_freight_electric</code> <code>Series</code> <p>Energy consumption for freight transport using electricity [MJ].</p> required <code>energy_consumption_dropin_fuel</code> <code>Series</code> <p>Total energy consumption using drop-in fuels [MJ].</p> required <code>energy_consumption_hydrogen</code> <code>Series</code> <p>Total energy consumption using hydrogen [MJ].</p> required <code>energy_consumption_electric</code> <code>Series</code> <p>Total energy consumption using electricity [MJ].</p> required <code>energy_consumption</code> <code>Series</code> <p>Total energy consumption [MJ].</p> required <code>dropin_fuel_mean_co2_emission_factor</code> <code>Series</code> <p>Mean CO2 emission factor for drop-in fuels [gCO2/MJ].</p> required <code>hydrogen_mean_co2_emission_factor</code> <code>Series</code> <p>Mean CO2 emission factor for hydrogen [gCO2/MJ].</p> required <code>electric_mean_co2_emission_factor</code> <code>Series</code> <p>Mean CO2 emission factor for electricity [gCO2/MJ].</p> required <p>Returns:</p> Type Description <code>energy_per_ask_mean_without_operations</code> <p>Energy consumption per ASK without operational improvements [MJ/ASK].</p> <code>energy_per_ask_mean</code> <p>Energy consumption per ASK [MJ/ASK].</p> <code>energy_per_rtk_mean_without_operations</code> <p>Energy consumption per RTK without operational improvements [MJ/RTK].</p> <code>energy_per_rtk_mean</code> <p>Energy consumption per RTK [MJ/RTK].</p> <code>co2_per_energy_mean</code> <p>CO2 emissions per unit of energy consumed [gCO2/MJ].</p> Source code in <code>aeromaps/models/impacts/emissions/co2_emissions.py</code> <pre><code>def compute(\n    self,\n    ask: pd.Series,\n    rtk: pd.Series,\n    energy_consumption_passenger_dropin_fuel_without_operations: pd.Series,\n    energy_consumption_passenger_hydrogen_without_operations: pd.Series,\n    energy_consumption_passenger_electric_without_operations: pd.Series,\n    energy_consumption_passenger_dropin_fuel: pd.Series,\n    energy_consumption_passenger_hydrogen: pd.Series,\n    energy_consumption_passenger_electric: pd.Series,\n    energy_consumption_freight_dropin_fuel_without_operations: pd.Series,\n    energy_consumption_freight_hydrogen_without_operations: pd.Series,\n    energy_consumption_freight_electric_without_operations: pd.Series,\n    energy_consumption_freight_dropin_fuel: pd.Series,\n    energy_consumption_freight_hydrogen: pd.Series,\n    energy_consumption_freight_electric: pd.Series,\n    energy_consumption_dropin_fuel: pd.Series,\n    energy_consumption_hydrogen: pd.Series,\n    energy_consumption_electric: pd.Series,\n    energy_consumption: pd.Series,\n    dropin_fuel_mean_co2_emission_factor: pd.Series,\n    hydrogen_mean_co2_emission_factor: pd.Series,\n    electric_mean_co2_emission_factor: pd.Series,\n) -&gt; Tuple[pd.Series, pd.Series, pd.Series, pd.Series, pd.Series]:\n    \"\"\"\n    Execute the computation of Kaya factors for CO2 emissions calculation.\n\n    Parameters\n    ----------\n    ask\n        Available seat kilometers (ASK) [ASK].\n    rtk\n        Revenue ton kilometers (RTK) [RTK].\n    energy_consumption_passenger_dropin_fuel_without_operations\n        Energy consumption for passenger transport using drop-in fuels without operational improvements [MJ].\n    energy_consumption_passenger_hydrogen_without_operations\n        Energy consumption for passenger transport using hydrogen without operational improvements [MJ].\n    energy_consumption_passenger_electric_without_operations\n        Energy consumption for passenger transport using electricity without operational improvements [MJ].\n    energy_consumption_passenger_dropin_fuel\n        Energy consumption for passenger transport using drop-in fuels [MJ].\n    energy_consumption_passenger_hydrogen\n        Energy consumption for passenger transport using hydrogen [MJ].\n    energy_consumption_passenger_electric\n        Energy consumption for passenger transport using electricity [MJ].\n    energy_consumption_freight_dropin_fuel_without_operations\n        Energy consumption for freight transport using drop-in fuels without operational improvements [MJ].\n    energy_consumption_freight_hydrogen_without_operations\n        Energy consumption for freight transport using hydrogen without operational improvements [MJ].\n    energy_consumption_freight_electric_without_operations\n        Energy consumption for freight transport using electricity without operational improvements [MJ].\n    energy_consumption_freight_dropin_fuel\n        Energy consumption for freight transport using drop-in fuels [MJ].\n    energy_consumption_freight_hydrogen\n        Energy consumption for freight transport using hydrogen [MJ].\n    energy_consumption_freight_electric\n        Energy consumption for freight transport using electricity [MJ].\n    energy_consumption_dropin_fuel\n        Total energy consumption using drop-in fuels [MJ].\n    energy_consumption_hydrogen\n        Total energy consumption using hydrogen [MJ].\n    energy_consumption_electric\n        Total energy consumption using electricity [MJ].\n    energy_consumption\n        Total energy consumption [MJ].\n    dropin_fuel_mean_co2_emission_factor\n        Mean CO2 emission factor for drop-in fuels [gCO2/MJ].\n    hydrogen_mean_co2_emission_factor\n        Mean CO2 emission factor for hydrogen [gCO2/MJ].\n    electric_mean_co2_emission_factor\n        Mean CO2 emission factor for electricity [gCO2/MJ].\n\n    Returns\n    -------\n    energy_per_ask_mean_without_operations\n        Energy consumption per ASK without operational improvements [MJ/ASK].\n    energy_per_ask_mean\n        Energy consumption per ASK [MJ/ASK].\n    energy_per_rtk_mean_without_operations\n        Energy consumption per RTK without operational improvements [MJ/RTK].\n    energy_per_rtk_mean\n        Energy consumption per RTK [MJ/RTK].\n    co2_per_energy_mean\n        CO2 emissions per unit of energy consumed [gCO2/MJ].\n    \"\"\"\n    energy_per_ask_mean_without_operations = (\n        +energy_consumption_passenger_dropin_fuel_without_operations\n        + energy_consumption_passenger_hydrogen_without_operations\n        + energy_consumption_passenger_electric_without_operations\n    ) / ask\n\n    energy_per_ask_mean = (\n        +energy_consumption_passenger_dropin_fuel\n        + energy_consumption_passenger_hydrogen\n        + energy_consumption_passenger_electric\n    ) / ask\n\n    energy_per_rtk_mean_without_operations = (\n        +energy_consumption_freight_dropin_fuel_without_operations\n        + energy_consumption_freight_hydrogen_without_operations\n        + energy_consumption_freight_electric_without_operations\n    ) / rtk\n\n    energy_per_rtk_mean = (\n        +energy_consumption_freight_dropin_fuel\n        + energy_consumption_freight_hydrogen\n        + energy_consumption_freight_electric\n    ) / rtk\n\n    # TODO\n    #  --&gt; Better way than fillna to handle years where no energy is produced?\n\n    co2_per_energy_mean = (\n        +dropin_fuel_mean_co2_emission_factor.fillna(0) * energy_consumption_dropin_fuel\n        + hydrogen_mean_co2_emission_factor.fillna(0) * energy_consumption_hydrogen\n        + electric_mean_co2_emission_factor.fillna(0) * energy_consumption_electric\n    ) / energy_consumption\n\n    self.df.loc[:, \"energy_per_ask_mean_without_operations\"] = (\n        energy_per_ask_mean_without_operations\n    )\n    self.df.loc[:, \"energy_per_rtk_mean_without_operations\"] = (\n        energy_per_rtk_mean_without_operations\n    )\n    self.df.loc[:, \"energy_per_ask_mean\"] = energy_per_ask_mean\n    self.df.loc[:, \"energy_per_rtk_mean\"] = energy_per_rtk_mean\n    self.df.loc[:, \"co2_per_energy_mean\"] = co2_per_energy_mean\n\n    return (\n        energy_per_ask_mean_without_operations,\n        energy_per_ask_mean,\n        energy_per_rtk_mean_without_operations,\n        energy_per_rtk_mean,\n        co2_per_energy_mean,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.co2_emissions/#aeromaps.models.impacts.emissions.co2_emissions.CO2Emissions","title":"CO2Emissions","text":"<pre><code>CO2Emissions(name='co2_emissions', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute CO2 emissions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('co2_emissions' by default).</p> <code>'co2_emissions'</code> Source code in <code>aeromaps/models/impacts/emissions/co2_emissions.py</code> <pre><code>def __init__(self, name=\"co2_emissions\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n    self.climate_historical_data = None\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.co2_emissions/#aeromaps.models.impacts.emissions.co2_emissions.CO2Emissions.compute","title":"compute","text":"<pre><code>compute(rpk_short_range, rpk_medium_range, rpk_long_range, rtk, load_factor, energy_per_ask_short_range_dropin_fuel, energy_per_ask_medium_range_dropin_fuel, energy_per_ask_long_range_dropin_fuel, energy_per_rtk_freight_dropin_fuel, energy_per_ask_short_range_hydrogen, energy_per_ask_medium_range_hydrogen, energy_per_ask_long_range_hydrogen, energy_per_rtk_freight_hydrogen, energy_per_ask_short_range_electric, energy_per_ask_medium_range_electric, energy_per_ask_long_range_electric, energy_per_rtk_freight_electric, ask_short_range_dropin_fuel_share, ask_medium_range_dropin_fuel_share, ask_long_range_dropin_fuel_share, rtk_dropin_fuel_share, ask_short_range_hydrogen_share, ask_medium_range_hydrogen_share, ask_long_range_hydrogen_share, rtk_hydrogen_share, ask_short_range_electric_share, ask_medium_range_electric_share, ask_long_range_electric_share, rtk_electric_share, dropin_fuel_mean_co2_emission_factor, hydrogen_mean_co2_emission_factor, electric_mean_co2_emission_factor)\n</code></pre> <p>CO2 emissions calculation.</p> <p>Parameters:</p> Name Type Description Default <code>rpk_short_range</code> <code>Series</code> <p>Revenue passenger kilometers for short-range flights [RPK].</p> required <code>rpk_medium_range</code> <code>Series</code> <p>Revenue passenger kilometers for medium-range flights [RPK].</p> required <code>rpk_long_range</code> <code>Series</code> <p>Revenue passenger kilometers for long-range flights [RPK].</p> required <code>rtk</code> <code>Series</code> <p>Revenue ton kilometers [RTK].</p> required <code>load_factor</code> <code>Series</code> <p>Load factor [%].</p> required <code>energy_per_ask_short_range_dropin_fuel</code> <code>Series</code> <p>Energy consumption per ASK for short-range flights using drop-in fuels [MJ/ASK].</p> required <code>energy_per_ask_medium_range_dropin_fuel</code> <code>Series</code> <p>Energy consumption per ASK for medium-range flights using drop-in fuels [MJ/ASK].</p> required <code>energy_per_ask_long_range_dropin_fuel</code> <code>Series</code> <p>Energy consumption per ASK for long-range flights using drop-in fuels [MJ/ASK].</p> required <code>energy_per_rtk_freight_dropin_fuel</code> <code>Series</code> <p>Energy consumption per RTK for freight using drop-in fuels [MJ/RTK].</p> required <code>energy_per_ask_short_range_hydrogen</code> <code>Series</code> <p>Energy consumption per ASK for short-range flights using hydrogen [MJ/ASK].</p> required <code>energy_per_ask_medium_range_hydrogen</code> <code>Series</code> <p>Energy consumption per ASK for medium-range flights using hydrogen [MJ/ASK].</p> required <code>energy_per_ask_long_range_hydrogen</code> <code>Series</code> <p>Energy consumption per ASK for long-range flights using hydrogen [MJ/ASK].</p> required <code>energy_per_rtk_freight_hydrogen</code> <code>Series</code> <p>Energy consumption per RTK for freight using hydrogen [MJ/RTK].</p> required <code>energy_per_ask_short_range_electric</code> <code>Series</code> <p>Energy consumption per ASK for short-range flights using electricity [MJ/ASK].</p> required <code>energy_per_ask_medium_range_electric</code> <code>Series</code> <p>Energy consumption per ASK for medium-range flights using electricity [MJ/ASK].</p> required <code>energy_per_ask_long_range_electric</code> <code>Series</code> <p>Energy consumption per ASK for long-range flights using electricity [MJ/ASK].</p> required <code>energy_per_rtk_freight_electric</code> <code>Series</code> <p>Energy consumption per RTK for freight using electricity [MJ/RTK].</p> required <code>ask_short_range_dropin_fuel_share</code> <code>Series</code> <p>Share of drop-in fuels in ASK for short-range flights [%].</p> required <code>ask_medium_range_dropin_fuel_share</code> <code>Series</code> <p>Share of drop-in fuels in ASK for medium-range flights [%].</p> required <code>ask_long_range_dropin_fuel_share</code> <code>Series</code> <p>Share of drop-in fuels in ASK for long-range flights [%].</p> required <code>rtk_dropin_fuel_share</code> <code>Series</code> <p>Share of drop-in fuels in RTK for freight [%].</p> required <code>ask_short_range_hydrogen_share</code> <code>Series</code> <p>Share of hydrogen in ASK for short-range flights [%].</p> required <code>ask_medium_range_hydrogen_share</code> <code>Series</code> <p>Share of hydrogen in ASK for medium-range flights [%].</p> required <code>ask_long_range_hydrogen_share</code> <code>Series</code> <p>Share of hydrogen in ASK for long-range flights [%].</p> required <code>rtk_hydrogen_share</code> <code>Series</code> <p>Share of hydrogen in RTK for freight [%].</p> required <code>ask_short_range_electric_share</code> <code>Series</code> <p>Share of electricity in ASK for short-range flights [%].</p> required <code>ask_medium_range_electric_share</code> <code>Series</code> <p>Share of electricity in ASK for medium-range flights [%].</p> required <code>ask_long_range_electric_share</code> <code>Series</code> <p>Share of electricity in ASK for long-range flights [%].</p> required <code>rtk_electric_share</code> <code>Series</code> <p>Share of electricity in RTK for freight [%].</p> required <code>dropin_fuel_mean_co2_emission_factor</code> <code>Series</code> <p>Mean CO2 emission factor for drop-in fuels [gCO2/MJ].</p> required <code>hydrogen_mean_co2_emission_factor</code> <code>Series</code> <p>Mean CO2 emission factor for hydrogen [gCO2/MJ].</p> required <code>electric_mean_co2_emission_factor</code> <code>Series</code> <p>Mean CO2 emission factor for electricity [gCO2/MJ].</p> required <p>Returns:</p> Type Description <code>co2_emissions_short_range</code> <p>CO2 emissions from short-range flights [MtCO2].</p> <code>co2_emissions_medium_range</code> <p>CO2 emissions from medium-range flights [MtCO2].</p> <code>co2_emissions_long_range</code> <p>CO2 emissions from long-range flights [MtCO2].</p> <code>co2_emissions_passenger</code> <p>CO2 emissions from passenger transport [MtCO2].</p> <code>co2_emissions_freight</code> <p>CO2 emissions from freight transport [MtCO2].</p> <code>co2_emissions</code> <p>Total CO2 emissions [MtCO2].</p> Source code in <code>aeromaps/models/impacts/emissions/co2_emissions.py</code> <pre><code>def compute(\n    self,\n    rpk_short_range: pd.Series,\n    rpk_medium_range: pd.Series,\n    rpk_long_range: pd.Series,\n    rtk: pd.Series,\n    load_factor: pd.Series,\n    energy_per_ask_short_range_dropin_fuel: pd.Series,\n    energy_per_ask_medium_range_dropin_fuel: pd.Series,\n    energy_per_ask_long_range_dropin_fuel: pd.Series,\n    energy_per_rtk_freight_dropin_fuel: pd.Series,\n    energy_per_ask_short_range_hydrogen: pd.Series,\n    energy_per_ask_medium_range_hydrogen: pd.Series,\n    energy_per_ask_long_range_hydrogen: pd.Series,\n    energy_per_rtk_freight_hydrogen: pd.Series,\n    energy_per_ask_short_range_electric: pd.Series,\n    energy_per_ask_medium_range_electric: pd.Series,\n    energy_per_ask_long_range_electric: pd.Series,\n    energy_per_rtk_freight_electric: pd.Series,\n    ask_short_range_dropin_fuel_share: pd.Series,\n    ask_medium_range_dropin_fuel_share: pd.Series,\n    ask_long_range_dropin_fuel_share: pd.Series,\n    rtk_dropin_fuel_share: pd.Series,\n    ask_short_range_hydrogen_share: pd.Series,\n    ask_medium_range_hydrogen_share: pd.Series,\n    ask_long_range_hydrogen_share: pd.Series,\n    rtk_hydrogen_share: pd.Series,\n    ask_short_range_electric_share: pd.Series,\n    ask_medium_range_electric_share: pd.Series,\n    ask_long_range_electric_share: pd.Series,\n    rtk_electric_share: pd.Series,\n    dropin_fuel_mean_co2_emission_factor: pd.Series,\n    hydrogen_mean_co2_emission_factor: pd.Series,\n    electric_mean_co2_emission_factor: pd.Series,\n) -&gt; Tuple[pd.Series, pd.Series, pd.Series, pd.Series, pd.Series, pd.Series]:\n    \"\"\"\n    CO2 emissions calculation.\n\n    Parameters\n    ----------\n    rpk_short_range\n        Revenue passenger kilometers for short-range flights [RPK].\n    rpk_medium_range\n        Revenue passenger kilometers for medium-range flights [RPK].\n    rpk_long_range\n        Revenue passenger kilometers for long-range flights [RPK].\n    rtk\n        Revenue ton kilometers [RTK].\n    load_factor\n        Load factor [%].\n    energy_per_ask_short_range_dropin_fuel\n        Energy consumption per ASK for short-range flights using drop-in fuels [MJ/ASK].\n    energy_per_ask_medium_range_dropin_fuel\n        Energy consumption per ASK for medium-range flights using drop-in fuels [MJ/ASK].\n    energy_per_ask_long_range_dropin_fuel\n        Energy consumption per ASK for long-range flights using drop-in fuels [MJ/ASK].\n    energy_per_rtk_freight_dropin_fuel\n        Energy consumption per RTK for freight using drop-in fuels [MJ/RTK].\n    energy_per_ask_short_range_hydrogen\n        Energy consumption per ASK for short-range flights using hydrogen [MJ/ASK].\n    energy_per_ask_medium_range_hydrogen\n        Energy consumption per ASK for medium-range flights using hydrogen [MJ/ASK].\n    energy_per_ask_long_range_hydrogen\n        Energy consumption per ASK for long-range flights using hydrogen [MJ/ASK].\n    energy_per_rtk_freight_hydrogen\n        Energy consumption per RTK for freight using hydrogen [MJ/RTK].\n    energy_per_ask_short_range_electric\n        Energy consumption per ASK for short-range flights using electricity [MJ/ASK].\n    energy_per_ask_medium_range_electric\n        Energy consumption per ASK for medium-range flights using electricity [MJ/ASK].\n    energy_per_ask_long_range_electric\n        Energy consumption per ASK for long-range flights using electricity [MJ/ASK].\n    energy_per_rtk_freight_electric\n        Energy consumption per RTK for freight using electricity [MJ/RTK].\n    ask_short_range_dropin_fuel_share\n        Share of drop-in fuels in ASK for short-range flights [%].\n    ask_medium_range_dropin_fuel_share\n        Share of drop-in fuels in ASK for medium-range flights [%].\n    ask_long_range_dropin_fuel_share\n        Share of drop-in fuels in ASK for long-range flights [%].\n    rtk_dropin_fuel_share\n        Share of drop-in fuels in RTK for freight [%].\n    ask_short_range_hydrogen_share\n        Share of hydrogen in ASK for short-range flights [%].\n    ask_medium_range_hydrogen_share\n        Share of hydrogen in ASK for medium-range flights [%].\n    ask_long_range_hydrogen_share\n        Share of hydrogen in ASK for long-range flights [%].\n    rtk_hydrogen_share\n        Share of hydrogen in RTK for freight [%].\n    ask_short_range_electric_share\n        Share of electricity in ASK for short-range flights [%].\n    ask_medium_range_electric_share\n        Share of electricity in ASK for medium-range flights [%].\n    ask_long_range_electric_share\n        Share of electricity in ASK for long-range flights [%].\n    rtk_electric_share\n        Share of electricity in RTK for freight [%].\n    dropin_fuel_mean_co2_emission_factor\n        Mean CO2 emission factor for drop-in fuels [gCO2/MJ].\n    hydrogen_mean_co2_emission_factor\n        Mean CO2 emission factor for hydrogen [gCO2/MJ].\n    electric_mean_co2_emission_factor\n        Mean CO2 emission factor for electricity [gCO2/MJ].\n\n    Returns\n    -------\n    co2_emissions_short_range\n        CO2 emissions from short-range flights [MtCO2].\n    co2_emissions_medium_range\n        CO2 emissions from medium-range flights [MtCO2].\n    co2_emissions_long_range\n        CO2 emissions from long-range flights [MtCO2].\n    co2_emissions_passenger\n        CO2 emissions from passenger transport [MtCO2].\n    co2_emissions_freight\n        CO2 emissions from freight transport [MtCO2].\n    co2_emissions\n        Total CO2 emissions [MtCO2].\n    \"\"\"\n    # Locally filling incomplete emission factors with zeros so that sums are not nan if one is undefined\n    dropin_fuel_mean_co2_emission_factor.fillna(0, inplace=True)\n    hydrogen_mean_co2_emission_factor.fillna(0, inplace=True)\n    electric_mean_co2_emission_factor.fillna(0, inplace=True)\n\n    # Short range\n    co2_emissions_short_range = (\n        rpk_short_range\n        / (load_factor / 100)\n        * (\n            ask_short_range_dropin_fuel_share\n            / 100\n            * (dropin_fuel_mean_co2_emission_factor * energy_per_ask_short_range_dropin_fuel)\n            + ask_short_range_hydrogen_share\n            / 100\n            * (energy_per_ask_short_range_hydrogen * hydrogen_mean_co2_emission_factor)\n            + ask_short_range_electric_share\n            / 100\n            * (energy_per_ask_short_range_electric * electric_mean_co2_emission_factor)\n        )\n        * 10 ** (-12)\n    )\n\n    # Medium range\n    co2_emissions_medium_range = (\n        rpk_medium_range\n        / (load_factor / 100)\n        * (\n            ask_medium_range_dropin_fuel_share\n            / 100\n            * (dropin_fuel_mean_co2_emission_factor * energy_per_ask_medium_range_dropin_fuel)\n            + ask_medium_range_hydrogen_share\n            / 100\n            * (energy_per_ask_medium_range_hydrogen * hydrogen_mean_co2_emission_factor)\n            + ask_medium_range_electric_share\n            / 100\n            * (energy_per_ask_medium_range_electric * electric_mean_co2_emission_factor)\n        )\n        * 10 ** (-12)\n    )\n\n    # Long range\n    co2_emissions_long_range = (\n        rpk_long_range\n        / (load_factor / 100)\n        * (\n            ask_long_range_dropin_fuel_share\n            / 100\n            * (dropin_fuel_mean_co2_emission_factor * energy_per_ask_long_range_dropin_fuel)\n            + ask_long_range_hydrogen_share\n            / 100\n            * (energy_per_ask_long_range_hydrogen * hydrogen_mean_co2_emission_factor)\n            + ask_long_range_electric_share\n            / 100\n            * (energy_per_ask_long_range_electric * electric_mean_co2_emission_factor)\n        )\n        * 10 ** (-12)\n    )\n\n    # Freight\n    co2_emissions_freight = (\n        rtk\n        * (\n            rtk_dropin_fuel_share\n            / 100\n            * (dropin_fuel_mean_co2_emission_factor * energy_per_rtk_freight_dropin_fuel)\n            + rtk_hydrogen_share\n            / 100\n            * (energy_per_rtk_freight_hydrogen * hydrogen_mean_co2_emission_factor)\n            + rtk_electric_share\n            / 100\n            * (energy_per_rtk_freight_electric * electric_mean_co2_emission_factor)\n        )\n        * 10 ** (-12)\n    )\n\n    # Passenger\n    co2_emissions_passenger = (\n        co2_emissions_short_range + co2_emissions_medium_range + co2_emissions_long_range\n    )\n\n    # Total: new way to affect without for loops\n    historical_co2_emissions_for_temperature = self.climate_historical_data[:, 1]\n    self.df_climate.loc[\n        self.climate_historic_start_year : self.historic_start_year - 1, \"co2_emissions\"\n    ] = historical_co2_emissions_for_temperature[\n        : self.historic_start_year - self.climate_historic_start_year\n    ]\n    self.df_climate.loc[self.historic_start_year : self.end_year, \"co2_emissions\"] = (\n        co2_emissions_passenger + co2_emissions_freight\n    )\n\n    self.df[\"co2_emissions_short_range\"] = co2_emissions_short_range\n    self.df[\"co2_emissions_medium_range\"] = co2_emissions_medium_range\n    self.df[\"co2_emissions_long_range\"] = co2_emissions_long_range\n    self.df[\"co2_emissions_freight\"] = co2_emissions_freight\n    self.df[\"co2_emissions_passenger\"] = co2_emissions_passenger\n    co2_emissions = self.df_climate[\"co2_emissions\"]\n\n    return (\n        co2_emissions_short_range,\n        co2_emissions_medium_range,\n        co2_emissions_long_range,\n        co2_emissions_passenger,\n        co2_emissions_freight,\n        co2_emissions,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.co2_emissions/#aeromaps.models.impacts.emissions.co2_emissions.CumulativeCO2Emissions","title":"CumulativeCO2Emissions","text":"<pre><code>CumulativeCO2Emissions(name='cumulative_co2_emissions', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute cumulative CO2 emissions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('cumulative_co2_emissions' by default).</p> <code>'cumulative_co2_emissions'</code> Source code in <code>aeromaps/models/impacts/emissions/co2_emissions.py</code> <pre><code>def __init__(self, name=\"cumulative_co2_emissions\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.co2_emissions/#aeromaps.models.impacts.emissions.co2_emissions.CumulativeCO2Emissions.compute","title":"compute","text":"<pre><code>compute(co2_emissions)\n</code></pre> <p>Execute the computation of cumulative CO2 emissions.</p> <p>Parameters:</p> Name Type Description Default <code>co2_emissions</code> <code>Series</code> <p>Annual CO2 emissions [MtCO2].</p> required <p>Returns:</p> Type Description <code>cumulative_co2_emissions</code> <p>Cumulative CO2 emissions [GtCO2].</p> Source code in <code>aeromaps/models/impacts/emissions/co2_emissions.py</code> <pre><code>def compute(\n    self,\n    co2_emissions: pd.Series,\n) -&gt; pd.Series:\n    \"\"\"\n    Execute the computation of cumulative CO2 emissions.\n\n    Parameters\n    ----------\n    co2_emissions\n        Annual CO2 emissions [MtCO2].\n\n    Returns\n    -------\n    cumulative_co2_emissions\n        Cumulative CO2 emissions [GtCO2].\n\n    \"\"\"\n    cumulative_co2_emissions = (\n        co2_emissions.loc[self.prospection_start_year : self.end_year] / 1000\n    ).cumsum()\n\n    self.df[\"cumulative_co2_emissions\"] = cumulative_co2_emissions\n\n    return cumulative_co2_emissions\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.co2_emissions/#aeromaps.models.impacts.emissions.co2_emissions.DetailedCo2Emissions","title":"DetailedCo2Emissions","text":"<pre><code>DetailedCo2Emissions(name='detailed_co2_emissions', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute detailed CO2 emissions breakdown.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('detailed_co2_emissions' by default).</p> <code>'detailed_co2_emissions'</code> Source code in <code>aeromaps/models/impacts/emissions/co2_emissions.py</code> <pre><code>def __init__(self, name=\"detailed_co2_emissions\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.co2_emissions/#aeromaps.models.impacts.emissions.co2_emissions.DetailedCo2Emissions.compute","title":"compute","text":"<pre><code>compute(rpk_reference, rtk_reference, rpk, rtk, load_factor, energy_per_ask_mean, energy_per_rtk_mean, energy_per_ask_mean_without_operations, energy_per_rtk_mean_without_operations, co2_per_energy_mean)\n</code></pre> <p>Execute the computation of detailed CO2 emissions breakdown.</p> <p>Parameters:</p> Name Type Description Default <code>rpk_reference</code> <code>Series</code> <p>Number of Revenue Passenger Kilometer (RPK) for all passenger air transport with a baseline air traffic growth [RPK].</p> required <code>rtk_reference</code> <code>Series</code> <p>Number of Revenue Tonne Kilometer (RTK) for freight air transport with a baseline air traffic growth [RTK].</p> required <code>rpk</code> <code>Series</code> <p>Revenue passenger kilometers (RPK) [RPK].</p> required <code>rtk</code> <code>Series</code> <p>Revenue ton kilometers (RTK) [RTK].</p> required <code>load_factor</code> <code>Series</code> <p>Load factor [%].</p> required <code>energy_per_ask_mean</code> <code>Series</code> <p>Mean energy consumption per ASK for passenger market [MJ/ASK].</p> required <code>energy_per_rtk_mean</code> <code>Series</code> <p>Mean energy consumption per RTK for freight market [MJ/RTK].</p> required <code>energy_per_ask_mean_without_operations</code> <code>Series</code> <p>Mean energy consumption per ASK for passenger market without considering operation improvements [MJ/ASK].</p> required <code>energy_per_rtk_mean_without_operations</code> <code>Series</code> <p>Mean energy consumption per RTK for freight market without considering operation improvements [MJ/RTK].</p> required <code>co2_per_energy_mean</code> <code>Series</code> <p>Mean emission factor of aircraft energy [gCO2/MJ].</p> required <p>Returns:</p> Type Description <code>co2_emissions_2019technology_baseline3</code> <p>CO2 emissions from all commercial air transport based on 2019 technological level with a baseline air traffic growth [MtCO2].</p> <code>co2_emissions_2019technology</code> <p>CO2 emissions from all commercial air transport based on 2019 technological level [MtCO2].</p> <code>co2_emissions_including_aircraft_efficiency</code> <p>CO2 emissions from all commercial air transport including aircraft efficiency improvements [MtCO2].</p> <code>co2_emissions_including_operations</code> <p>CO2 emissions from all commercial air transport including aircraft efficiency and operation improvements [MtCO2].</p> <code>co2_emissions_including_load_factor</code> <p>CO2 emissions from all commercial air transport including aircraft efficiency, operation and load factor improvements [MtCO2].</p> <code>co2_emissions_including_energy</code> <p>CO2 emissions from all commercial air transport including aircraft efficiency, operation and load factor improvements and energy decarbonization [MtCO2].</p> Source code in <code>aeromaps/models/impacts/emissions/co2_emissions.py</code> <pre><code>def compute(\n    self,\n    rpk_reference: pd.Series,\n    rtk_reference: pd.Series,\n    rpk: pd.Series,\n    rtk: pd.Series,\n    load_factor: pd.Series,\n    energy_per_ask_mean: pd.Series,\n    energy_per_rtk_mean: pd.Series,\n    energy_per_ask_mean_without_operations: pd.Series,\n    energy_per_rtk_mean_without_operations: pd.Series,\n    co2_per_energy_mean: pd.Series,\n) -&gt; Tuple[pd.Series, pd.Series, pd.Series, pd.Series, pd.Series, pd.Series]:\n    \"\"\"\n    Execute the computation of detailed CO2 emissions breakdown.\n\n    Parameters\n    ----------\n    rpk_reference\n        Number of Revenue Passenger Kilometer (RPK) for all passenger air transport with a baseline air traffic growth [RPK].\n    rtk_reference\n        Number of Revenue Tonne Kilometer (RTK) for freight air transport with a baseline air traffic growth [RTK].\n    rpk\n        Revenue passenger kilometers (RPK) [RPK].\n    rtk\n        Revenue ton kilometers (RTK) [RTK].\n    load_factor\n        Load factor [%].\n    energy_per_ask_mean\n        Mean energy consumption per ASK for passenger market [MJ/ASK].\n    energy_per_rtk_mean\n        Mean energy consumption per RTK for freight market [MJ/RTK].\n    energy_per_ask_mean_without_operations\n        Mean energy consumption per ASK for passenger market without considering operation improvements [MJ/ASK].\n    energy_per_rtk_mean_without_operations\n        Mean energy consumption per RTK for freight market without considering operation improvements [MJ/RTK].\n    co2_per_energy_mean\n        Mean emission factor of aircraft energy [gCO2/MJ].\n\n\n    Returns\n    -------\n    co2_emissions_2019technology_baseline3\n        CO2 emissions from all commercial air transport based on 2019 technological level with a baseline air traffic growth [MtCO2].\n    co2_emissions_2019technology\n        CO2 emissions from all commercial air transport based on 2019 technological level [MtCO2].\n    co2_emissions_including_aircraft_efficiency\n        CO2 emissions from all commercial air transport including aircraft efficiency improvements [MtCO2].\n    co2_emissions_including_operations\n        CO2 emissions from all commercial air transport including aircraft efficiency and operation improvements [MtCO2].\n    co2_emissions_including_load_factor\n        CO2 emissions from all commercial air transport including aircraft efficiency, operation and load factor improvements [MtCO2].\n    co2_emissions_including_energy\n        CO2 emissions from all commercial air transport including aircraft efficiency, operation and load factor improvements and energy decarbonization [MtCO2].\n\n    \"\"\"\n    years = range(self.prospection_start_year - 1, self.end_year + 1)\n\n    # Speedup operations: access right portions of vectors\n    rpk_reference_local = rpk_reference.loc[years]\n    rtk_reference_local = rtk_reference.loc[years]\n    rpk_local = rpk.loc[years]\n    rtk_local = rtk.loc[years]\n    load_factor_local = load_factor.loc[years]\n    energy_per_ask_mean_local = energy_per_ask_mean.loc[years]\n    energy_per_rtk_mean_local = energy_per_rtk_mean.loc[years]\n    energy_per_ask_mean_without_operations_local = energy_per_ask_mean_without_operations.loc[\n        years\n    ]\n    energy_per_rtk_mean_without_operations_local = energy_per_rtk_mean_without_operations.loc[\n        years\n    ]\n    co2_per_energy_mean_local = co2_per_energy_mean.loc[years]\n\n    # Start year values\n    load_factor_start_year_local = load_factor.loc[self.prospection_start_year - 1]\n    energy_per_ask_mean_start_year_local = energy_per_ask_mean.loc[\n        self.prospection_start_year - 1\n    ]\n    energy_per_rtk_mean_start_year_local = energy_per_rtk_mean.loc[\n        self.prospection_start_year - 1\n    ]\n    energy_per_ask_mean_without_operations_start_year_local = (\n        energy_per_ask_mean_without_operations.loc[self.prospection_start_year - 1]\n    )\n    energy_per_rtk_mean_without_operations_start_year_local = (\n        energy_per_rtk_mean_without_operations.loc[self.prospection_start_year - 1]\n    )\n    co2_per_energy_mean_start_year_local = co2_per_energy_mean.loc[\n        self.prospection_start_year - 1\n    ]\n\n    co2_emissions_2019technology_baseline3 = (\n        rpk_reference_local\n        * energy_per_ask_mean_without_operations_start_year_local\n        * energy_per_ask_mean_start_year_local\n        / energy_per_ask_mean_without_operations_start_year_local\n        / (load_factor_start_year_local / 100)\n        * co2_per_energy_mean_start_year_local\n        * 10 ** (-12)\n    ) + (\n        rtk_reference_local\n        * energy_per_rtk_mean_without_operations_start_year_local\n        * energy_per_rtk_mean_start_year_local\n        / energy_per_rtk_mean_without_operations_start_year_local\n        * co2_per_energy_mean_start_year_local\n        * 10 ** (-12)\n    )\n\n    co2_emissions_2019technology = (\n        rpk_local\n        * energy_per_ask_mean_without_operations_start_year_local\n        * energy_per_ask_mean_start_year_local\n        / energy_per_ask_mean_without_operations_start_year_local\n        / (load_factor_start_year_local / 100)\n        * co2_per_energy_mean_start_year_local\n        * 10 ** (-12)\n    ) + (\n        rtk_local\n        * energy_per_rtk_mean_without_operations_start_year_local\n        * energy_per_rtk_mean_start_year_local\n        / energy_per_rtk_mean_without_operations_start_year_local\n        * co2_per_energy_mean_start_year_local\n        * 10 ** (-12)\n    )\n\n    co2_emissions_including_aircraft_efficiency = (\n        rpk_local\n        * energy_per_ask_mean_without_operations_local\n        * energy_per_ask_mean_start_year_local\n        / energy_per_ask_mean_without_operations_start_year_local\n        / (load_factor_start_year_local / 100)\n        * co2_per_energy_mean_start_year_local\n        * 10 ** (-12)\n    ) + (\n        rtk_local\n        * energy_per_rtk_mean_without_operations_local\n        * energy_per_rtk_mean_start_year_local\n        / energy_per_rtk_mean_without_operations_start_year_local\n        * co2_per_energy_mean_start_year_local\n        * 10 ** (-12)\n    )\n\n    co2_emissions_including_operations = (\n        rpk_local\n        * energy_per_ask_mean_without_operations_local\n        * energy_per_ask_mean_local\n        / energy_per_ask_mean_without_operations_local\n        / (load_factor_start_year_local / 100)\n        * co2_per_energy_mean_start_year_local\n        * 10 ** (-12)\n    ) + (\n        rtk_local\n        * energy_per_rtk_mean_without_operations_local\n        * energy_per_rtk_mean_local\n        / energy_per_rtk_mean_without_operations_local\n        * co2_per_energy_mean_start_year_local\n        * 10 ** (-12)\n    )\n\n    co2_emissions_including_load_factor = (\n        rpk_local\n        * energy_per_ask_mean_without_operations_local\n        * energy_per_ask_mean_local\n        / energy_per_ask_mean_without_operations_local\n        / (load_factor_local / 100)\n        * co2_per_energy_mean_start_year_local\n        * 10 ** (-12)\n    ) + (\n        rtk_local\n        * energy_per_rtk_mean_without_operations_local\n        * energy_per_rtk_mean_local\n        / energy_per_rtk_mean_without_operations_local\n        * co2_per_energy_mean_start_year_local\n        * 10 ** (-12)\n    )\n\n    co2_emissions_including_energy = (\n        rpk_local\n        * energy_per_ask_mean_without_operations_local\n        * energy_per_ask_mean_local\n        / energy_per_ask_mean_without_operations_local\n        / (load_factor_local / 100)\n        * co2_per_energy_mean_local\n        * 10 ** (-12)\n    ) + (\n        rtk_local\n        * energy_per_rtk_mean_without_operations_local\n        * energy_per_rtk_mean_local\n        / energy_per_rtk_mean_without_operations_local\n        * co2_per_energy_mean_local\n        * 10 ** (-12)\n    )\n\n    self.df.loc[years, \"co2_emissions_2019technology_baseline3\"] = (\n        co2_emissions_2019technology_baseline3\n    )\n    self.df.loc[years, \"co2_emissions_2019technology\"] = co2_emissions_2019technology\n    self.df.loc[years, \"co2_emissions_including_aircraft_efficiency\"] = (\n        co2_emissions_including_aircraft_efficiency\n    )\n    self.df.loc[years, \"co2_emissions_including_operations\"] = (\n        co2_emissions_including_operations\n    )\n    self.df.loc[years, \"co2_emissions_including_load_factor\"] = (\n        co2_emissions_including_load_factor\n    )\n    self.df.loc[years, \"co2_emissions_including_energy\"] = co2_emissions_including_energy\n\n    return (\n        co2_emissions_2019technology_baseline3,\n        co2_emissions_2019technology,\n        co2_emissions_including_aircraft_efficiency,\n        co2_emissions_including_operations,\n        co2_emissions_including_load_factor,\n        co2_emissions_including_energy,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.co2_emissions/#aeromaps.models.impacts.emissions.co2_emissions.DetailedCumulativeCO2Emissions","title":"DetailedCumulativeCO2Emissions","text":"<pre><code>DetailedCumulativeCO2Emissions(name='detailed_cumulative_co2_emissions', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute detailed cumulative CO2 emissions breakdown.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('detailed_cumulative_co2_emissions' by default).</p> <code>'detailed_cumulative_co2_emissions'</code> Source code in <code>aeromaps/models/impacts/emissions/co2_emissions.py</code> <pre><code>def __init__(self, name=\"detailed_cumulative_co2_emissions\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.co2_emissions/#aeromaps.models.impacts.emissions.co2_emissions.DetailedCumulativeCO2Emissions.compute","title":"compute","text":"<pre><code>compute(co2_emissions_2019technology_baseline3, co2_emissions_2019technology, co2_emissions_including_load_factor, co2_emissions_including_energy)\n</code></pre> <p>Execute the computation of detailed cumulative CO2 emissions breakdown.</p> <p>Parameters:</p> Name Type Description Default <code>co2_emissions_2019technology_baseline3</code> <code>Series</code> <p>CO2 emissions from all commercial air transport based on 2019 technological level with a baseline air traffic growth [MtCO2].</p> required <code>co2_emissions_2019technology</code> <code>Series</code> <p>CO2 emissions from all commercial air transport based on 2019 technological level [MtCO2].</p> required <code>co2_emissions_including_load_factor</code> <code>Series</code> <p>CO2 emissions from all commercial air transport including aircraft efficiency, operation and load factor improvements [MtCO2].</p> required <code>co2_emissions_including_energy</code> <code>Series</code> <p>CO2 emissions from all commercial air transport including aircraft efficiency, operation and load factor improvements and energy decarbonization [MtCO2].</p> required <p>Returns:</p> Type Description <code>cumulative_co2_emissions_2019technology_baseline3</code> <p>Cumulative CO2 emissions from all commercial air transport based on 2019 technological level with a baseline air traffic growth [GtCO2].</p> <code>cumulative_co2_emissions_2019technology</code> <p>Cumulative CO2 emissions from all commercial air transport based on 2019 technological level [GtCO2].</p> <code>cumulative_co2_emissions_including_load_factor</code> <p>Cumulative CO2 emissions from all commercial air transport including aircraft efficiency, operation and load factor improvements [GtCO2].</p> <code>cumulative_co2_emissions_including_energy</code> <p>Cumulative CO2 emissions from all commercial air transport including aircraft efficiency, operation and load factor improvements and energy decarbonization [GtCO2].</p> Source code in <code>aeromaps/models/impacts/emissions/co2_emissions.py</code> <pre><code>def compute(\n    self,\n    co2_emissions_2019technology_baseline3: pd.Series,\n    co2_emissions_2019technology: pd.Series,\n    co2_emissions_including_load_factor: pd.Series,\n    co2_emissions_including_energy: pd.Series,\n) -&gt; Tuple[pd.Series, pd.Series, pd.Series, pd.Series]:\n    \"\"\"\n    Execute the computation of detailed cumulative CO2 emissions breakdown.\n    Parameters\n    ----------\n    co2_emissions_2019technology_baseline3\n        CO2 emissions from all commercial air transport based on 2019 technological level with a baseline air traffic growth [MtCO2].\n    co2_emissions_2019technology\n        CO2 emissions from all commercial air transport based on 2019 technological level [MtCO2].\n    co2_emissions_including_load_factor\n        CO2 emissions from all commercial air transport including aircraft efficiency, operation and load factor improvements [MtCO2].\n    co2_emissions_including_energy\n        CO2 emissions from all commercial air transport including aircraft efficiency, operation and load factor improvements and energy decarbonization [MtCO2].\n\n    Returns\n    -------\n    cumulative_co2_emissions_2019technology_baseline3\n        Cumulative CO2 emissions from all commercial air transport based on 2019 technological level with a baseline air traffic growth [GtCO2].\n    cumulative_co2_emissions_2019technology\n        Cumulative CO2 emissions from all commercial air transport based on 2019 technological level [GtCO2].\n    cumulative_co2_emissions_including_load_factor\n        Cumulative CO2 emissions from all commercial air transport including aircraft efficiency, operation and load factor\n        improvements [GtCO2].\n    cumulative_co2_emissions_including_energy\n        Cumulative CO2 emissions from all commercial air transport including aircraft efficiency, operation and load factor\n        improvements and energy decarbonization [GtCO2].\n\n    \"\"\"\n    cumulative_co2_emissions_2019technology_baseline3 = (\n        co2_emissions_2019technology_baseline3.loc[self.prospection_start_year : self.end_year]\n        / 1000\n    ).cumsum()\n\n    cumulative_co2_emissions_2019technology = (\n        co2_emissions_2019technology.loc[self.prospection_start_year : self.end_year] / 1000\n    ).cumsum()\n\n    cumulative_co2_emissions_including_load_factor = (\n        co2_emissions_including_load_factor.loc[self.prospection_start_year : self.end_year]\n        / 1000\n    ).cumsum()\n\n    cumulative_co2_emissions_including_energy = (\n        co2_emissions_including_energy.loc[self.prospection_start_year : self.end_year] / 1000\n    ).cumsum()\n\n    self.df[\"cumulative_co2_emissions_2019technology_baseline3\"] = (\n        cumulative_co2_emissions_2019technology_baseline3\n    )\n    self.df[\"cumulative_co2_emissions_2019technology\"] = cumulative_co2_emissions_2019technology\n    self.df[\"cumulative_co2_emissions_including_load_factor\"] = (\n        cumulative_co2_emissions_including_load_factor\n    )\n    self.df[\"cumulative_co2_emissions_including_energy\"] = (\n        cumulative_co2_emissions_including_energy\n    )\n\n    return (\n        cumulative_co2_emissions_2019technology_baseline3,\n        cumulative_co2_emissions_2019technology,\n        cumulative_co2_emissions_including_load_factor,\n        cumulative_co2_emissions_including_energy,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.co2_emissions/#aeromaps.models.impacts.emissions.co2_emissions.SimpleCO2Emissions","title":"SimpleCO2Emissions","text":"<pre><code>SimpleCO2Emissions(name='simple_co2_emissions', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute simple CO2 emissions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('simple_co2_emissions' by default).</p> <code>'simple_co2_emissions'</code> Source code in <code>aeromaps/models/impacts/emissions/co2_emissions.py</code> <pre><code>def __init__(self, name=\"simple_co2_emissions\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n    self.climate_historical_data = None\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.co2_emissions/#aeromaps.models.impacts.emissions.co2_emissions.SimpleCO2Emissions.compute","title":"compute","text":"<pre><code>compute(energy_consumption_init, dropin_fuel_mean_co2_emission_factor, hydrogen_mean_co2_emission_factor, electric_mean_co2_emission_factor, energy_consumption_dropin_fuel, energy_consumption_hydrogen, energy_consumption_electricity)\n</code></pre> <p>Simple CO2 emissions calculation</p> <p>Parameters:</p> Name Type Description Default <code>energy_consumption_init</code> <code>Series</code> <p>Historical energy consumption of aviation over 2000-2019 [MJ].</p> required <code>dropin_fuel_mean_co2_emission_factor</code> <code>Series</code> <p>Mean CO2 emission factor for drop-in fuels [gCO2/MJ].</p> required <code>hydrogen_mean_co2_emission_factor</code> <code>Series</code> <p>Mean CO2 emission factor for hydrogen [gCO2/MJ].</p> required <code>electric_mean_co2_emission_factor</code> <code>Series</code> <p>Mean CO2 emission factor for electric aviation [gCO2/MJ].</p> required <code>energy_consumption_dropin_fuel</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels from all commercial air transport [MJ].</p> required <code>energy_consumption_hydrogen</code> <code>Series</code> <p>Energy consumption in the form of hydrogen from all commercial air transport [MJ].</p> required <code>energy_consumption_electricity</code> <code>Series</code> <p>Energy consumption in the form of electricity from all commercial air transport [MJ].</p> required <p>Returns:</p> Type Description <code>co2_emissions</code> <p>CO2 emissions from all commercial air transport [MtCO2].</p> Source code in <code>aeromaps/models/impacts/emissions/co2_emissions.py</code> <pre><code>def compute(\n    self,\n    energy_consumption_init: pd.Series,\n    dropin_fuel_mean_co2_emission_factor: pd.Series,\n    hydrogen_mean_co2_emission_factor: pd.Series,\n    electric_mean_co2_emission_factor: pd.Series,\n    energy_consumption_dropin_fuel: pd.Series,\n    energy_consumption_hydrogen: pd.Series,\n    energy_consumption_electricity: pd.Series,\n) -&gt; pd.Series:\n    \"\"\"\n    Simple CO2 emissions calculation\n\n    Parameters\n    ----------\n    energy_consumption_init\n        Historical energy consumption of aviation over 2000-2019 [MJ].\n    dropin_fuel_mean_co2_emission_factor\n        Mean CO2 emission factor for drop-in fuels [gCO2/MJ].\n    hydrogen_mean_co2_emission_factor\n        Mean CO2 emission factor for hydrogen [gCO2/MJ].\n    electric_mean_co2_emission_factor\n        Mean CO2 emission factor for electric aviation [gCO2/MJ].\n    energy_consumption_dropin_fuel\n        Energy consumption in the form of drop-in fuels from all commercial air transport [MJ].\n    energy_consumption_hydrogen\n        Energy consumption in the form of hydrogen from all commercial air transport [MJ].\n    energy_consumption_electricity\n        Energy consumption in the form of electricity from all commercial air transport [MJ].\n\n    Returns\n    -------\n    co2_emissions\n        CO2 emissions from all commercial air transport [MtCO2].\n    \"\"\"\n\n    ## Initialization\n    historical_co2_emissions_for_temperature = self.climate_historical_data[:, 1]\n\n    # Calculation\n    for k in range(self.climate_historic_start_year, self.historic_start_year):\n        self.df_climate.loc[k, \"co2_emissions\"] = historical_co2_emissions_for_temperature[\n            k - self.climate_historic_start_year\n        ]\n\n    for k in range(self.historic_start_year, self.prospection_start_year):\n        self.df_climate.loc[k, \"co2_emissions\"] = (\n            dropin_fuel_mean_co2_emission_factor.loc[k]\n            / 10**12\n            * energy_consumption_init.loc[k]\n        )\n\n    for k in range(self.prospection_start_year, self.end_year + 1):\n        self.df_climate.loc[k, \"co2_emissions\"] = (\n            dropin_fuel_mean_co2_emission_factor.loc[k]\n            / 10**12\n            * energy_consumption_dropin_fuel.loc[k]\n            + electric_mean_co2_emission_factor.loc[k]\n            / 10**12\n            * energy_consumption_electricity.loc[k]\n            + hydrogen_mean_co2_emission_factor.loc[k]\n            / 10**12\n            * energy_consumption_hydrogen.loc[k]\n        )\n\n    co2_emissions = self.df_climate.loc[:, \"co2_emissions\"]\n\n    return co2_emissions\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions/","title":"<code>aeromaps.models.impacts.emissions</code>","text":""},{"location":"full_doc/aeromaps.models.impacts.emissions/#aeromaps.models.impacts.emissions--emissions","title":"emissions","text":"<p>This subpackage contains models and utilities related to emissions computation.</p>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/","title":"<code>aeromaps.models.impacts.emissions.non_co2_emissions</code>","text":"<p>non_co2_emissions</p> <p>========================= Module to compute non-CO2 emissions from various aircraft types and energy origins.</p>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.NOxEmissionIndex","title":"NOxEmissionIndex","text":"<pre><code>NOxEmissionIndex(name='nox_emission_index', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute NOx emission index.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('nox_emission_index' by default).</p> <code>'nox_emission_index'</code> <p>Attributes:</p> Name Type Description <code>pathways_manager</code> <code>EnergyCarrierManager</code> <p>EnergyCarrierManager instance to manage generic energy pathways and their data.</p> <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Warnings <ul> <li>Detailed i/o documentation is not yet provided for models defined wityh generic .yaml files?</li> </ul> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def __init__(self, name=\"nox_emission_index\", *args, **kwargs):\n    super().__init__(name=name, model_type=\"custom\", *args, **kwargs)\n    self.pathways_manager = None\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.NOxEmissionIndex.custom_setup","title":"custom_setup","text":"<pre><code>custom_setup()\n</code></pre> <p>Dynamically add all pathways variables to input_names and function outputs to output_names. Specific function for custom AeroMAPSModel instances.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def custom_setup(self):\n    \"\"\"\n    Dynamically add all pathways variables to input_names and function outputs to output_names.\n    Specific function for custom AeroMAPSModel instances.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    # TODO caution aircraft types not generic there\n    self.input_names = {\n        \"emission_index_nox_dropin_fuel_evolution\": 0.0,\n        \"emission_index_nox_hydrogen_evolution\": 0.0,\n    }\n    self.output_names = {}\n\n    for aircraft_type in self.pathways_manager.get_all_types(\"aircraft_type\"):\n        for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n            if self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            ):\n                self.output_names.update(\n                    {\n                        f\"{aircraft_type}_{energy_origin}_mean_emission_index_nox\": pd.Series(\n                            [0.0]\n                        ),\n                    }\n                )\n\n        for pathway in self.pathways_manager.get(aircraft_type=aircraft_type):\n            self.input_names.update(\n                {\n                    f\"{pathway.name}_emission_index_nox\": 0.0,\n                    f\"{pathway.name}_massic_share_{aircraft_type}_{pathway.energy_origin}\": pd.Series(\n                        [0.0]\n                    ),\n                }\n            )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.NOxEmissionIndex.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>NOx emission index calculation using simple method.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"\n    NOx emission index calculation using simple method.\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n\n    \"\"\"\n\n    output_data = {}\n\n    for aircraft_type in self.pathways_manager.get_all_types(\"aircraft_type\"):\n        cagr_aircraft = input_data.get(f\"emission_index_nox_{aircraft_type}_evolution\", 0.0)\n        growth_series = pd.Series(\n            np.concatenate(\n                (\n                    np.ones(self.prospection_start_year - self.historic_start_year),\n                    (1 + cagr_aircraft)\n                    ** np.arange(0, self.end_year - self.prospection_start_year + 1),\n                )\n            ),\n            index=range(self.historic_start_year, self.end_year + 1),\n        )\n\n        # intialize the mean values for the aircraft type\n        for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n            # Get the pathways for this aircraft type and energy origin\n            pathways = self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            )\n            if pathways:\n                origin_mean_emission_index_nox = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                origin_cumulative_share = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                for pathway in pathways:\n                    origin_share = input_data[\n                        f\"{pathway.name}_massic_share_{aircraft_type}_{energy_origin}\"\n                    ]\n                    origin_cumulative_share = (\n                        origin_cumulative_share + origin_share.fillna(0) / 100\n                    )\n                    pathway_emission_index_nox = input_data[\n                        f\"{pathway.name}_emission_index_nox\"\n                    ]\n\n                    origin_mean_emission_index_nox += (\n                        pathway_emission_index_nox * origin_share\n                    ).fillna(0) / 100\n\n                origin_valid_years = origin_cumulative_share.replace(0, np.nan)\n\n                output_data[f\"{aircraft_type}_{energy_origin}_mean_emission_index_nox\"] = (\n                    origin_mean_emission_index_nox * origin_valid_years * growth_series\n                )\n\n    self._store_outputs(output_data)\n\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.NOxEmissionIndexComplex","title":"NOxEmissionIndexComplex","text":"<pre><code>NOxEmissionIndexComplex(name='nox_emission_index_complex', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute NOx emission index using fleet renewal models.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('nox_emission_index_complex' by default).</p> <code>'nox_emission_index_complex'</code> <p>Attributes:</p> Name Type Description <code>fleet_model</code> <code>FleetModel(AeroMAPSModel)</code> <p>AeroMAPSModel instance to provide fleet renewal data for NOx emission index calculation.</p> <code>pathways_manager</code> <code>EnergyCarrierManager</code> <p>EnergyCarrierManager instance to manage generic energy pathways and their data.</p> <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Warnings <ul> <li>Detailed i/o documentation is not yet provided for models defined wityh generic .yaml files?</li> </ul> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def __init__(self, name=\"nox_emission_index_complex\", *args, **kwargs):\n    super().__init__(name=name, model_type=\"custom\", *args, **kwargs)\n    self.fleet_model = None\n    self.pathways_manager = None\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.NOxEmissionIndexComplex.custom_setup","title":"custom_setup","text":"<pre><code>custom_setup()\n</code></pre> <p>Dynamically add all pathways variables to input_names and function outputs to output_names. Specific function for custom AeroMAPSModel instances.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def custom_setup(self):\n    \"\"\"\n    Dynamically add all pathways variables to input_names and function outputs to output_names.\n    Specific function for custom AeroMAPSModel instances.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # TODO caution aircraft types not generic there\n    self.input_names = {\n        \"ask_long_range_dropin_fuel\": pd.Series([0.0]),\n        \"ask_medium_range_dropin_fuel\": pd.Series([0.0]),\n        \"ask_short_range_dropin_fuel\": pd.Series([0.0]),\n        \"ask_long_range_hydrogen\": pd.Series([0.0]),\n        \"ask_medium_range_hydrogen\": pd.Series([0.0]),\n        \"ask_short_range_hydrogen\": pd.Series([0.0]),\n        \"ask_long_range_electric\": pd.Series([0.0]),\n        \"ask_medium_range_electric\": pd.Series([0.0]),\n        \"ask_short_range_electric\": pd.Series([0.0]),\n    }\n\n    self.output_names = {}\n\n    aircraft_types = [\"dropin_fuel\", \"hydrogen\", \"electric\"]\n\n    for aircraft_type in aircraft_types:\n        for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n            if self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            ):\n                self.output_names.update(\n                    {\n                        f\"{aircraft_type}_{energy_origin}_mean_emission_index_nox\": pd.Series(\n                            [0.0]\n                        ),\n                    }\n                )\n\n        for pathway in self.pathways_manager.get(aircraft_type=aircraft_type):\n            self.input_names.update(\n                {\n                    f\"{pathway.name}_emission_index_nox\": 0.0,\n                    f\"{pathway.name}_massic_share_{aircraft_type}_{pathway.energy_origin}\": pd.Series(\n                        [0.0]\n                    ),\n                }\n            )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.NOxEmissionIndexComplex.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>NOx emission index calculation using fleet renewal models.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def compute(\n    self,\n    input_data,\n) -&gt; dict:\n    \"\"\"\n    NOx emission index calculation using fleet renewal models.\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n    \"\"\"\n    output_data = {}\n    # Getting fleet model data\n\n    aircraft_types = [\"dropin_fuel\", \"hydrogen\", \"electric\"]\n\n    for aircraft_type in aircraft_types:\n        emission_index_nox_short_range = self.fleet_model.df[\n            f\"Short Range:emission_index_nox:{aircraft_type}\"\n        ]\n        emission_index_nox_medium_range = self.fleet_model.df[\n            f\"Medium Range:emission_index_nox:{aircraft_type}\"\n        ]\n        emission_index_nox_long_range = self.fleet_model.df[\n            f\"Long Range:emission_index_nox:{aircraft_type}\"\n        ]\n\n        ask_short_range = input_data.get(\n            f\"ask_short_range_{aircraft_type}\",\n            get_default_series(self.historic_start_year, self.end_year),\n        )\n        ask_medium_range = input_data.get(\n            f\"ask_medium_range_{aircraft_type}\",\n            get_default_series(self.historic_start_year, self.end_year),\n        )\n        ask_long_range = input_data.get(\n            f\"ask_long_range_{aircraft_type}\",\n            get_default_series(self.historic_start_year, self.end_year),\n        )\n\n        emission_index_aircraft_type = (\n            (\n                emission_index_nox_short_range.loc[self.historic_start_year : self.end_year]\n                * ask_short_range.loc[self.historic_start_year : self.end_year].fillna(0)\n            )\n            + (\n                emission_index_nox_medium_range.loc[self.historic_start_year : self.end_year]\n                * ask_medium_range.loc[self.historic_start_year : self.end_year].fillna(0)\n            )\n            + (\n                emission_index_nox_long_range.loc[self.historic_start_year : self.end_year]\n                * ask_long_range.loc[self.historic_start_year : self.end_year].fillna(0)\n            )\n        ) / (\n            ask_short_range.loc[self.historic_start_year : self.end_year].fillna(0)\n            + ask_medium_range.loc[self.historic_start_year : self.end_year].fillna(0)\n            + ask_long_range.loc[self.historic_start_year : self.end_year].fillna(0)\n        )\n\n        relative_emission_index_aircraft_type = (\n            emission_index_aircraft_type\n            / emission_index_aircraft_type.loc[self.prospection_start_year - 1]\n        )\n\n        # intialize the mean values for the aircraft type\n        for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n            # Get the pathways for this aircraft type and energy origin\n            pathways = self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            )\n            if pathways:\n                origin_mean_emission_index_nox = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                origin_cumulative_share = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                for pathway in pathways:\n                    origin_share = input_data[\n                        f\"{pathway.name}_massic_share_{aircraft_type}_{energy_origin}\"\n                    ]\n                    origin_cumulative_share = (\n                        origin_cumulative_share + origin_share.fillna(0) / 100\n                    )\n                    pathway_emission_index_nox = input_data[\n                        f\"{pathway.name}_emission_index_nox\"\n                    ]\n\n                    origin_mean_emission_index_nox += (\n                        pathway_emission_index_nox * origin_share\n                    ).fillna(0) / 100\n\n                origin_valid_years = origin_cumulative_share.replace(0, np.nan)\n\n                output_data[f\"{aircraft_type}_{energy_origin}_mean_emission_index_nox\"] = (\n                    origin_mean_emission_index_nox\n                    * origin_valid_years\n                    * relative_emission_index_aircraft_type\n                )\n\n    # print(output_data)\n    self._store_outputs(output_data)\n\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.SootEmissionIndex","title":"SootEmissionIndex","text":"<pre><code>SootEmissionIndex(name='soot_emission_index', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute Soot emission index.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('soot_emission_index' by default).</p> <code>'soot_emission_index'</code> <p>Attributes:</p> Name Type Description <code>pathways_manager</code> <code>EnergyCarrierManager</code> <p>EnergyCarrierManager instance to manage generic energy pathways and their data.</p> <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Warnings <ul> <li>Detailed i/o documentation is not yet provided for models defined wityh generic .yaml files?</li> </ul> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def __init__(self, name=\"soot_emission_index\", *args, **kwargs):\n    super().__init__(name=name, model_type=\"custom\", *args, **kwargs)\n    self.pathways_manager = None\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.SootEmissionIndex.custom_setup","title":"custom_setup","text":"<pre><code>custom_setup()\n</code></pre> <p>Dynamically add all pathways variables to input_names and function outputs to output_names. Specific function for custom AeroMAPSModel instances.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def custom_setup(self):\n    \"\"\"\n    Dynamically add all pathways variables to input_names and function outputs to output_names.\n    Specific function for custom AeroMAPSModel instances.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # TODO caution aircraft types not generic there\n    self.input_names = {\"emission_index_soot_dropin_fuel_evolution\": 0.0}\n\n    self.output_names = {}\n\n    for aircraft_type in self.pathways_manager.get_all_types(\"aircraft_type\"):\n        for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n            if self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            ):\n                self.output_names.update(\n                    {\n                        f\"{aircraft_type}_{energy_origin}_mean_emission_index_soot\": pd.Series(\n                            [0.0]\n                        ),\n                    }\n                )\n\n        for pathway in self.pathways_manager.get(aircraft_type=aircraft_type):\n            self.input_names.update(\n                {\n                    f\"{pathway.name}_emission_index_soot\": 0.0,\n                    f\"{pathway.name}_massic_share_{aircraft_type}_{pathway.energy_origin}\": pd.Series(\n                        [0.0]\n                    ),\n                }\n            )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.SootEmissionIndex.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Execute Soot emission index calculation using simple method.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"\n    Execute Soot emission index calculation using simple method.\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n\n    \"\"\"\n\n    output_data = {}\n\n    for aircraft_type in self.pathways_manager.get_all_types(\"aircraft_type\"):\n        cagr_aircraft = input_data.get(f\"emission_index_soot_{aircraft_type}_evolution\", 0.0)\n        growth_series = pd.Series(\n            np.concatenate(\n                (\n                    np.ones(self.prospection_start_year - self.historic_start_year),\n                    (1 + cagr_aircraft)\n                    ** np.arange(0, self.end_year - self.prospection_start_year + 1),\n                )\n            ),\n            index=range(self.historic_start_year, self.end_year + 1),\n        )\n\n        # initialise the mean values for the aircraft type\n        for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n            # Get the pathways for this aircraft type and energy origin\n            pathways = self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            )\n            if pathways:\n                origin_mean_emission_index_soot = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                origin_cumulative_share = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                for pathway in pathways:\n                    origin_share = input_data[\n                        f\"{pathway.name}_massic_share_{aircraft_type}_{energy_origin}\"\n                    ]\n                    origin_cumulative_share = (\n                        origin_cumulative_share + origin_share.fillna(0) / 100\n                    )\n                    pathway_emission_index_soot = input_data[\n                        f\"{pathway.name}_emission_index_soot\"\n                    ]\n\n                    origin_mean_emission_index_soot += (\n                        pathway_emission_index_soot * origin_share\n                    ).fillna(0) / 100\n\n                origin_valid_years = origin_cumulative_share.replace(0, np.nan)\n\n                output_data[f\"{aircraft_type}_{energy_origin}_mean_emission_index_soot\"] = (\n                    origin_mean_emission_index_soot * origin_valid_years * growth_series\n                )\n\n    self._store_outputs(output_data)\n\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.SootEmissionIndexComplex","title":"SootEmissionIndexComplex","text":"<pre><code>SootEmissionIndexComplex(name='soot_emission_index_complex', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute Soot emission index using fleet renewal models.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('soot_emission_index_complex' by default).</p> <code>'soot_emission_index_complex'</code> <p>Attributes:</p> Name Type Description <code>fleet_model</code> <code>FleetModel(AeroMAPSModel)</code> <p>AeroMAPSModel instance to provide fleet renewal data for Soot emission index calculation.</p> <code>pathways_manager</code> <code>EnergyCarrierManager</code> <p>EnergyCarrierManager instance to manage generic energy pathways and their data.</p> <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Warnings <ul> <li>Detailed i/o documentation is not yet provided for models defined wityh generic .yaml files?</li> </ul> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def __init__(self, name=\"soot_emission_index_complex\", *args, **kwargs):\n    super().__init__(name=name, model_type=\"custom\", *args, **kwargs)\n    self.fleet_model = None\n    self.pathways_manager = None\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.SootEmissionIndexComplex.custom_setup","title":"custom_setup","text":"<pre><code>custom_setup()\n</code></pre> <p>Dynamically add all pathways variables to input_names and function outputs to output_names. Specific function for custom AeroMAPSModel instances.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def custom_setup(self):\n    \"\"\"\n    Dynamically add all pathways variables to input_names and function outputs to output_names.\n    Specific function for custom AeroMAPSModel instances.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # TODO caution aircraft types not generic there\n    self.input_names = {\n        \"ask_long_range_dropin_fuel\": pd.Series([0.0]),\n        \"ask_medium_range_dropin_fuel\": pd.Series([0.0]),\n        \"ask_short_range_dropin_fuel\": pd.Series([0.0]),\n        \"ask_long_range_hydrogen\": pd.Series([0.0]),\n        \"ask_medium_range_hydrogen\": pd.Series([0.0]),\n        \"ask_short_range_hydrogen\": pd.Series([0.0]),\n        \"ask_long_range_electric\": pd.Series([0.0]),\n        \"ask_medium_range_electric\": pd.Series([0.0]),\n        \"ask_short_range_electric\": pd.Series([0.0]),\n    }\n\n    self.output_names = {}\n\n    aircraft_types = [\"dropin_fuel\", \"hydrogen\", \"electric\"]\n    for aircraft_type in aircraft_types:\n        for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n            if self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            ):\n                self.output_names.update(\n                    {\n                        f\"{aircraft_type}_{energy_origin}_mean_emission_index_soot\": pd.Series(\n                            [0.0]\n                        ),\n                    }\n                )\n\n        for pathway in self.pathways_manager.get(aircraft_type=aircraft_type):\n            self.input_names.update(\n                {\n                    f\"{pathway.name}_emission_index_soot\": 0.0,\n                    f\"{pathway.name}_massic_share_{aircraft_type}_{pathway.energy_origin}\": pd.Series(\n                        [0.0]\n                    ),\n                }\n            )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.SootEmissionIndexComplex.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Soot emission index calculation using fleet renewal models.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def compute(\n    self,\n    input_data,\n) -&gt; dict:\n    \"\"\"Soot emission index calculation using fleet renewal models.\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n\n    \"\"\"\n    output_data = {}\n    # Getting fleet model data\n\n    aircraft_types = [\"dropin_fuel\", \"hydrogen\", \"electric\"]\n\n    for aircraft_type in aircraft_types:\n        emission_index_soot_short_range = self.fleet_model.df[\n            f\"Short Range:emission_index_soot:{aircraft_type}\"\n        ]\n        emission_index_soot_medium_range = self.fleet_model.df[\n            f\"Medium Range:emission_index_soot:{aircraft_type}\"\n        ]\n        emission_index_soot_long_range = self.fleet_model.df[\n            f\"Long Range:emission_index_soot:{aircraft_type}\"\n        ]\n\n        ask_short_range = input_data[f\"ask_short_range_{aircraft_type}\"]\n        ask_medium_range = input_data[f\"ask_medium_range_{aircraft_type}\"]\n        ask_long_range = input_data[f\"ask_long_range_{aircraft_type}\"]\n\n        emission_index_aircraft_type = (\n            (\n                emission_index_soot_short_range.loc[self.historic_start_year : self.end_year]\n                * ask_short_range.loc[self.historic_start_year : self.end_year].fillna(0)\n            )\n            + (\n                emission_index_soot_medium_range.loc[self.historic_start_year : self.end_year]\n                * ask_medium_range.loc[self.historic_start_year : self.end_year].fillna(0)\n            )\n            + (\n                emission_index_soot_long_range.loc[self.historic_start_year : self.end_year]\n                * ask_long_range.loc[self.historic_start_year : self.end_year].fillna(0)\n            )\n        ) / (\n            ask_short_range.loc[self.historic_start_year : self.end_year].fillna(0)\n            + ask_medium_range.loc[self.historic_start_year : self.end_year].fillna(0)\n            + ask_long_range.loc[self.historic_start_year : self.end_year].fillna(0)\n        )\n\n        relative_emission_index_aircraft_type = (\n            emission_index_aircraft_type\n            / emission_index_aircraft_type.loc[self.prospection_start_year - 1]\n        )\n\n        # intialize the mean values for the aircraft type\n        for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n            # Get the pathways for this aircraft type and energy origin\n            pathways = self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            )\n            if pathways:\n                origin_mean_emission_index_soot = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                origin_cumulative_share = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                for pathway in pathways:\n                    origin_share = input_data[\n                        f\"{pathway.name}_massic_share_{aircraft_type}_{energy_origin}\"\n                    ]\n                    origin_cumulative_share = (\n                        origin_cumulative_share + origin_share.fillna(0) / 100\n                    )\n                    pathway_emission_index_soot = input_data[\n                        f\"{pathway.name}_emission_index_soot\"\n                    ]\n\n                    origin_mean_emission_index_soot += (\n                        pathway_emission_index_soot * origin_share\n                    ).fillna(0) / 100\n\n                origin_valid_years = origin_cumulative_share.replace(0, np.nan)\n\n                output_data[f\"{aircraft_type}_{energy_origin}_mean_emission_index_soot\"] = (\n                    origin_mean_emission_index_soot\n                    * origin_valid_years\n                    * relative_emission_index_aircraft_type\n                )\n    self._store_outputs(output_data)\n\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.H2OEmissionIndex","title":"H2OEmissionIndex","text":"<pre><code>H2OEmissionIndex(name='h2o_emission_index', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute H2O emission index.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('h2o_emission_index' by default).</p> <code>'h2o_emission_index'</code> <p>Attributes:</p> Name Type Description <code>pathways_manager</code> <code>EnergyCarrierManager</code> <p>EnergyCarrierManager instance to manage generic energy pathways and their data.</p> <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Warnings <ul> <li>Detailed i/o documentation is not yet provided for models defined wityh generic .yaml files?</li> </ul> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def __init__(self, name=\"h2o_emission_index\", *args, **kwargs):\n    super().__init__(name=name, model_type=\"custom\", *args, **kwargs)\n    self.pathways_manager = None\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.H2OEmissionIndex.custom_setup","title":"custom_setup","text":"<pre><code>custom_setup()\n</code></pre> <p>Dynamically add all pathways variables to input_names and function outputs to output_names. Specific function for custom AeroMAPSModel instances.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def custom_setup(self):\n    \"\"\"\n    Dynamically add all pathways variables to input_names and function outputs to output_names.\n    Specific function for custom AeroMAPSModel instances.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.input_names = {}\n    self.output_names = {}\n\n    for aircraft_type in self.pathways_manager.get_all_types(\"aircraft_type\"):\n        for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n            if self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            ):\n                self.output_names.update(\n                    {\n                        f\"{aircraft_type}_{energy_origin}_mean_emission_index_h2o\": pd.Series(\n                            [0.0]\n                        ),\n                    }\n                )\n\n        for pathway in self.pathways_manager.get(aircraft_type=aircraft_type):\n            self.input_names.update(\n                {\n                    f\"{pathway.name}_emission_index_h2o\": 0.0,\n                    f\"{pathway.name}_massic_share_{aircraft_type}_{pathway.energy_origin}\": pd.Series(\n                        [0.0]\n                    ),\n                }\n            )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.H2OEmissionIndex.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Average H20 emission index calculation</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"Average H20 emission index calculation\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n\n    \"\"\"\n\n    output_data = {}\n\n    for aircraft_type in self.pathways_manager.get_all_types(\"aircraft_type\"):\n        # initialise the mean values for the aircraft type\n        for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n            # Get the pathways for this aircraft type and energy origin\n            pathways = self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            )\n            if pathways:\n                origin_mean_emission_index_h2o = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                origin_cumulative_share = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                for pathway in pathways:\n                    origin_share = input_data[\n                        f\"{pathway.name}_massic_share_{aircraft_type}_{energy_origin}\"\n                    ]\n                    origin_cumulative_share = (\n                        origin_cumulative_share + origin_share.fillna(0) / 100\n                    )\n                    pathway_emission_index_h2o = input_data[\n                        f\"{pathway.name}_emission_index_h2o\"\n                    ]\n\n                    origin_mean_emission_index_h2o += (\n                        pathway_emission_index_h2o * origin_share\n                    ).fillna(0) / 100\n\n                origin_valid_years = origin_cumulative_share.replace(0, np.nan)\n\n                output_data[f\"{aircraft_type}_{energy_origin}_mean_emission_index_h2o\"] = (\n                    origin_mean_emission_index_h2o * origin_valid_years\n                )\n\n    self._store_outputs(output_data)\n\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.SulfurEmissionIndex","title":"SulfurEmissionIndex","text":"<pre><code>SulfurEmissionIndex(name='sulfur_emission_index', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute Sulfur emission index.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('sulfur_emission_index' by default).</p> <code>'sulfur_emission_index'</code> <p>Attributes:</p> Name Type Description <code>pathways_manager</code> <code>EnergyCarrierManager</code> <p>EnergyCarrierManager instance to manage generic energy pathways and their data.</p> <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Warnings <ul> <li>Detailed i/o documentation is not yet provided for models defined wityh generic .yaml files?</li> </ul> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def __init__(self, name=\"sulfur_emission_index\", *args, **kwargs):\n    super().__init__(name=name, model_type=\"custom\", *args, **kwargs)\n    self.pathways_manager = None\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.SulfurEmissionIndex.custom_setup","title":"custom_setup","text":"<pre><code>custom_setup()\n</code></pre> <p>Dynamically add all pathways variables to input_names and function outputs to output_names. Specific function for custom AeroMAPSModel instances.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def custom_setup(self):\n    \"\"\"\n    Dynamically add all pathways variables to input_names and function outputs to output_names.\n    Specific function for custom AeroMAPSModel instances.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.input_names = {}\n    self.output_names = {}\n\n    for aircraft_type in self.pathways_manager.get_all_types(\"aircraft_type\"):\n        for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n            if self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            ):\n                self.output_names.update(\n                    {\n                        f\"{aircraft_type}_{energy_origin}_mean_emission_index_sulfur\": pd.Series(\n                            [0.0]\n                        ),\n                    }\n                )\n\n        for pathway in self.pathways_manager.get(aircraft_type=aircraft_type):\n            self.input_names.update(\n                {\n                    f\"{pathway.name}_emission_index_sulfur\": 0.0,\n                    f\"{pathway.name}_massic_share_{aircraft_type}_{pathway.energy_origin}\": pd.Series(\n                        [0.0]\n                    ),\n                }\n            )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.SulfurEmissionIndex.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Average H20 emission index calculation</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"Average H20 emission index calculation\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n\n    \"\"\"\n\n    output_data = {}\n\n    for aircraft_type in self.pathways_manager.get_all_types(\"aircraft_type\"):\n        # initialise the mean values for the aircraft type\n        for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n            # Get the pathways for this aircraft type and energy origin\n            pathways = self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            )\n            if pathways:\n                origin_mean_emission_index_sulfur = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                origin_cumulative_share = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                for pathway in pathways:\n                    origin_share = input_data[\n                        f\"{pathway.name}_massic_share_{aircraft_type}_{energy_origin}\"\n                    ]\n                    origin_cumulative_share = (\n                        origin_cumulative_share + origin_share.fillna(0) / 100\n                    )\n                    pathway_emission_index_sulfur = input_data[\n                        f\"{pathway.name}_emission_index_sulfur\"\n                    ]\n\n                    origin_mean_emission_index_sulfur += (\n                        pathway_emission_index_sulfur * origin_share\n                    ).fillna(0) / 100\n\n                origin_valid_years = origin_cumulative_share.replace(0, np.nan)\n\n                output_data[f\"{aircraft_type}_{energy_origin}_mean_emission_index_sulfur\"] = (\n                    origin_mean_emission_index_sulfur * origin_valid_years\n                )\n\n    self._store_outputs(output_data)\n\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.NonCO2Emissions","title":"NonCO2Emissions","text":"<pre><code>NonCO2Emissions(name='non_co2_emissions', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to compute non-CO2 emissions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('non_co2_emissions' by default).</p> <code>'non_co2_emissions'</code> <p>Attributes:</p> Name Type Description <code>pathways_manager</code> <code>EnergyCarrierManager</code> <p>EnergyCarrierManager instance to manage generic energy pathways and their data.</p> <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Warnings <ul> <li>Detailed i/o documentation is not yet provided for models defined wityh generic .yaml files?</li> </ul> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def __init__(self, name=\"non_co2_emissions\", *args, **kwargs):\n    super().__init__(name=name, model_type=\"custom\", *args, **kwargs)\n    self.climate_historical_data = None\n    self.pathways_manager = None\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.NonCO2Emissions.custom_setup","title":"custom_setup","text":"<pre><code>custom_setup()\n</code></pre> <p>Dynamically add all pathways variables to input_names and function outputs to output_names. Specific function for custom AeroMAPSModel instances.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def custom_setup(self):\n    \"\"\"\n    Dynamically add all pathways variables to input_names and function outputs to output_names.\n    Specific function for custom AeroMAPSModel instances.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    None\n    \"\"\"\n    aircraft_type = [\"dropin_fuel\", \"hydrogen\"]\n\n    for aircraft_type in aircraft_type:\n        for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n            if self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            ):\n                self.input_names.update(\n                    {\n                        f\"{aircraft_type}_{energy_origin}_mean_emission_index_nox\": pd.Series(\n                            [0.0]\n                        ),\n                        f\"{aircraft_type}_{energy_origin}_mean_emission_index_soot\": pd.Series(\n                            [0.0]\n                        ),\n                        f\"{aircraft_type}_{energy_origin}_mean_emission_index_h2o\": pd.Series(\n                            [0.0]\n                        ),\n                        f\"{aircraft_type}_{energy_origin}_mean_emission_index_sulfur\": pd.Series(\n                            [0.0]\n                        ),\n                        f\"{aircraft_type}_{energy_origin}_mean_lhv\": pd.Series([0.0]),\n                        f\"{aircraft_type}_{energy_origin}_energy_consumption\": pd.Series([0.0]),\n                    }\n                )\n\n    self.output_names.update(\n        {\n            \"soot_emissions\": pd.Series([0.0]),\n            \"h2o_emissions\": pd.Series([0.0]),\n            \"nox_emissions\": pd.Series([0.0]),\n            \"sulfur_emissions\": pd.Series([0.0]),\n        }\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.emissions.non_co2_emissions/#aeromaps.models.impacts.emissions.non_co2_emissions.NonCO2Emissions.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Non-CO2 emissions calculation.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/emissions/non_co2_emissions.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"Non-CO2 emissions calculation.\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n    \"\"\"\n\n    soot_emissions = get_default_series(self.climate_historic_start_year, self.end_year)\n    h2o_emissions = get_default_series(self.climate_historic_start_year, self.end_year)\n    nox_emissions = get_default_series(self.climate_historic_start_year, self.end_year)\n    sulfur_emissions = get_default_series(self.climate_historic_start_year, self.end_year)\n\n    ## Initialization\n    historical_nox_emissions_for_temperature = self.climate_historical_data[:, 2]\n    historical_h2o_emissions_for_temperature = self.climate_historical_data[:, 3]\n    historical_soot_emissions_for_temperature = self.climate_historical_data[:, 4]\n    historical_sulfur_emissions_for_temperature = self.climate_historical_data[:, 5]\n\n    soot_emissions.loc[self.climate_historic_start_year : self.historic_start_year] = (\n        historical_soot_emissions_for_temperature\n    )\n    h2o_emissions.loc[self.climate_historic_start_year : self.historic_start_year] = (\n        historical_h2o_emissions_for_temperature\n    )\n    nox_emissions.loc[self.climate_historic_start_year : self.historic_start_year] = (\n        historical_nox_emissions_for_temperature\n    )\n    sulfur_emissions.loc[self.climate_historic_start_year : self.historic_start_year] = (\n        historical_sulfur_emissions_for_temperature\n    )\n\n    for aircraft_type in [\"dropin_fuel\", \"hydrogen\"]:\n        for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n            if self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            ):\n                mass_consumption = (\n                    input_data[f\"{aircraft_type}_{energy_origin}_energy_consumption\"]\n                    / input_data[f\"{aircraft_type}_{energy_origin}_mean_lhv\"]\n                    / 10**9  # convert MJ to Mt\n                )\n                soot_emissions.loc[self.historic_start_year + 1 : self.end_year] += (\n                    input_data[f\"{aircraft_type}_{energy_origin}_mean_emission_index_soot\"]\n                    * mass_consumption\n                ).fillna(0.0)\n                h2o_emissions.loc[self.historic_start_year + 1 : self.end_year] += (\n                    input_data[f\"{aircraft_type}_{energy_origin}_mean_emission_index_h2o\"]\n                    * mass_consumption\n                ).fillna(0.0)\n                nox_emissions.loc[self.historic_start_year + 1 : self.end_year] += (\n                    input_data[f\"{aircraft_type}_{energy_origin}_mean_emission_index_nox\"]\n                    * mass_consumption\n                ).fillna(0.0)\n                sulfur_emissions.loc[self.historic_start_year + 1 : self.end_year] += (\n                    input_data[f\"{aircraft_type}_{energy_origin}_mean_emission_index_sulfur\"]\n                    * mass_consumption\n                ).fillna(0.0)\n\n    output_data = {\n        \"soot_emissions\": soot_emissions,\n        \"h2o_emissions\": h2o_emissions,\n        \"nox_emissions\": nox_emissions,\n        \"sulfur_emissions\": sulfur_emissions,\n    }\n\n    self.df_climate.loc[:, \"soot_emissions\"] = soot_emissions\n    self.df_climate.loc[:, \"h2o_emissions\"] = h2o_emissions\n    self.df_climate.loc[:, \"nox_emissions\"] = nox_emissions\n    self.df_climate.loc[:, \"sulfur_emissions\"] = sulfur_emissions\n\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.energy_resources.energy_consumption/","title":"<code>aeromaps.models.impacts.energy_resources.energy_consumption</code>","text":""},{"location":"full_doc/aeromaps.models.impacts.energy_resources.energy_consumption/#aeromaps.models.impacts.energy_resources.energy_consumption--energy_consumption","title":"energy_consumption","text":"<p>Module to compute energy consumption from different aircraft types.</p>"},{"location":"full_doc/aeromaps.models.impacts.energy_resources.energy_consumption/#aeromaps.models.impacts.energy_resources.energy_consumption.DropInFuelConsumption","title":"DropInFuelConsumption","text":"<pre><code>DropInFuelConsumption(name='drop_in_fuel_consumption', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Total drop-in fuel consumption calculation.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('drop_in_fuel_consumption' by default).</p> <code>'drop_in_fuel_consumption'</code> Source code in <code>aeromaps/models/impacts/energy_resources/energy_consumption.py</code> <pre><code>def __init__(self, name=\"drop_in_fuel_consumption\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.energy_resources.energy_consumption/#aeromaps.models.impacts.energy_resources.energy_consumption.DropInFuelConsumption.compute","title":"compute","text":"<pre><code>compute(ask_short_range_dropin_fuel, ask_medium_range_dropin_fuel, ask_long_range_dropin_fuel, rtk_dropin_fuel, energy_per_ask_without_operations_short_range_dropin_fuel, energy_per_ask_without_operations_medium_range_dropin_fuel, energy_per_ask_without_operations_long_range_dropin_fuel, energy_per_rtk_without_operations_freight_dropin_fuel, energy_per_ask_short_range_dropin_fuel, energy_per_ask_medium_range_dropin_fuel, energy_per_ask_long_range_dropin_fuel, energy_per_rtk_freight_dropin_fuel)\n</code></pre> <p>Execute drop-in fuel consumption calculation.</p> <p>Parameters:</p> Name Type Description Default <code>ask_short_range_dropin_fuel</code> <code>Series</code> <p>Number of Available Seat Kilometer (ASK) for passenger short-range market from drop-in fuel aircraft [ASK].</p> required <code>ask_medium_range_dropin_fuel</code> <code>Series</code> <p>Number of Available Seat Kilometer (ASK) for passenger medium-range market from drop-in fuel aircraft [ASK].</p> required <code>ask_long_range_dropin_fuel</code> <code>Series</code> <p>Number of Available Seat Kilometer (ASK) for passenger long-range market from drop-in fuel aircraft [ASK].</p> required <code>rtk_dropin_fuel</code> <code>Series</code> <p>Number of Revenue Tonne Kilometer (RTK) for freight air transport from drop-in fuel aircraft [RTK].</p> required <code>energy_per_ask_without_operations_short_range_dropin_fuel</code> <code>Series</code> <p>Energy consumption per ASK for passenger short-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].</p> required <code>energy_per_ask_without_operations_medium_range_dropin_fuel</code> <code>Series</code> <p>Energy consumption per ASK for passenger medium-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].</p> required <code>energy_per_ask_without_operations_long_range_dropin_fuel</code> <code>Series</code> <p>Energy consumption per ASK for passenger long-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].</p> required <code>energy_per_rtk_without_operations_freight_dropin_fuel</code> <code>Series</code> <p>Energy consumption per RTK for freight market aircraft using drop-in fuel without considering operation improvements [MJ/RTK].</p> required <code>energy_per_ask_short_range_dropin_fuel</code> <code>Series</code> <p>Energy consumption per ASK for passenger short-range market aircraft using drop-in fuel [MJ/ASK].</p> required <code>energy_per_ask_medium_range_dropin_fuel</code> <code>Series</code> <p>Energy consumption per ASK for passenger medium-range market aircraft using drop-in fuel [MJ/ASK].</p> required <code>energy_per_ask_long_range_dropin_fuel</code> <code>Series</code> <p>Energy consumption per ASK for passenger long-range market aircraft using drop-in fuel [MJ/ASK].</p> required <code>energy_per_rtk_freight_dropin_fuel</code> <code>Series</code> <p>Energy consumption per RTK for freight market aircraft using drop-in fuel [MJ/RTK].</p> required <p>Returns:</p> Type Description <code>energy_consumption_short_range_dropin_fuel_without_operations</code> <p>Energy consumption in the form of drop-in fuels without considering operation improvements from passenger short-range market air transport [MJ].</p> <code>energy_consumption_medium_range_dropin_fuel_without_operations</code> <p>Energy consumption in the form of drop-in fuels without considering operation improvements from passenger medium-range market air transport [MJ].</p> <code>energy_consumption_long_range_dropin_fuel_without_operations</code> <p>Energy consumption in the form of drop-in fuels without considering operation improvements from passenger long-range market air transport [MJ].</p> <code>energy_consumption_passenger_dropin_fuel_without_operations</code> <p>Energy consumption in the form of drop-in fuels without considering operation improvements from total passenger air transport [MJ].</p> <code>energy_consumption_freight_dropin_fuel_without_operations</code> <p>Energy consumption in the form of drop-in fuels without considering operation improvements from freight air transport [MJ].</p> <code>energy_consumption_dropin_fuel_without_operations</code> <p>Energy consumption in the form of drop-in fuels without considering operation improvements from all commercial air transport [MJ].</p> <code>energy_consumption_short_range_dropin_fuel</code> <p>Energy consumption in the form of drop-in fuels from passenger short-range market air transport [MJ].</p> <code>energy_consumption_medium_range_dropin_fuel</code> <p>Energy consumption in the form of drop-in fuels from passenger medium-range market air transport [MJ].</p> <code>energy_consumption_long_range_dropin_fuel</code> <p>Energy consumption in the form of drop-in fuels from passenger long-range market air transport [MJ].</p> <code>energy_consumption_passenger_dropin_fuel</code> <p>Energy consumption in the form of drop-in fuels from total passenger air transport [MJ].</p> <code>energy_consumption_freight_dropin_fuel</code> <p>Energy consumption in the form of drop-in fuels from freight air transport [MJ].</p> <code>energy_consumption_dropin_fuel</code> <p>Energy consumption in the form of drop-in fuels from all commercial air transport [MJ].</p> Source code in <code>aeromaps/models/impacts/energy_resources/energy_consumption.py</code> <pre><code>def compute(\n    self,\n    ask_short_range_dropin_fuel: pd.Series,\n    ask_medium_range_dropin_fuel: pd.Series,\n    ask_long_range_dropin_fuel: pd.Series,\n    rtk_dropin_fuel: pd.Series,\n    energy_per_ask_without_operations_short_range_dropin_fuel: pd.Series,\n    energy_per_ask_without_operations_medium_range_dropin_fuel: pd.Series,\n    energy_per_ask_without_operations_long_range_dropin_fuel: pd.Series,\n    energy_per_rtk_without_operations_freight_dropin_fuel: pd.Series,\n    energy_per_ask_short_range_dropin_fuel: pd.Series,\n    energy_per_ask_medium_range_dropin_fuel: pd.Series,\n    energy_per_ask_long_range_dropin_fuel: pd.Series,\n    energy_per_rtk_freight_dropin_fuel: pd.Series,\n) -&gt; Tuple[\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n]:\n    \"\"\"\n    Execute drop-in fuel consumption calculation.\n    Parameters\n    ----------\n    ask_short_range_dropin_fuel\n        Number of Available Seat Kilometer (ASK) for passenger short-range market from drop-in fuel aircraft [ASK].\n    ask_medium_range_dropin_fuel\n        Number of Available Seat Kilometer (ASK) for passenger medium-range market from drop-in fuel aircraft [ASK].\n    ask_long_range_dropin_fuel\n        Number of Available Seat Kilometer (ASK) for passenger long-range market from drop-in fuel aircraft [ASK].\n    rtk_dropin_fuel\n        Number of Revenue Tonne Kilometer (RTK) for freight air transport from drop-in fuel aircraft [RTK].\n    energy_per_ask_without_operations_short_range_dropin_fuel\n        Energy consumption per ASK for passenger short-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_medium_range_dropin_fuel\n        Energy consumption per ASK for passenger medium-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_long_range_dropin_fuel\n        Energy consumption per ASK for passenger long-range market aircraft using drop-in fuel without considering operation improvements [MJ/ASK].\n    energy_per_rtk_without_operations_freight_dropin_fuel\n        Energy consumption per RTK for freight market aircraft using drop-in fuel without considering operation improvements [MJ/RTK].\n    energy_per_ask_short_range_dropin_fuel\n        Energy consumption per ASK for passenger short-range market aircraft using drop-in fuel [MJ/ASK].\n    energy_per_ask_medium_range_dropin_fuel\n        Energy consumption per ASK for passenger medium-range market aircraft using drop-in fuel [MJ/ASK].\n    energy_per_ask_long_range_dropin_fuel\n        Energy consumption per ASK for passenger long-range market aircraft using drop-in fuel [MJ/ASK].\n    energy_per_rtk_freight_dropin_fuel\n        Energy consumption per RTK for freight market aircraft using drop-in fuel [MJ/RTK].\n\n    Returns\n    -------\n    energy_consumption_short_range_dropin_fuel_without_operations\n            Energy consumption in the form of drop-in fuels without considering operation improvements from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_dropin_fuel_without_operations\n            Energy consumption in the form of drop-in fuels without considering operation improvements from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_dropin_fuel_without_operations\n            Energy consumption in the form of drop-in fuels without considering operation improvements from passenger long-range market air transport [MJ].\n    energy_consumption_passenger_dropin_fuel_without_operations\n            Energy consumption in the form of drop-in fuels without considering operation improvements from total passenger air transport [MJ].\n    energy_consumption_freight_dropin_fuel_without_operations\n            Energy consumption in the form of drop-in fuels without considering operation improvements from freight air transport [MJ].\n    energy_consumption_dropin_fuel_without_operations\n            Energy consumption in the form of drop-in fuels without considering operation improvements from all commercial air transport [MJ].\n    energy_consumption_short_range_dropin_fuel\n            Energy consumption in the form of drop-in fuels from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_dropin_fuel\n            Energy consumption in the form of drop-in fuels from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_dropin_fuel\n            Energy consumption in the form of drop-in fuels from passenger long-range market air transport [MJ].\n    energy_consumption_passenger_dropin_fuel\n            Energy consumption in the form of drop-in fuels from total passenger air transport [MJ].\n    energy_consumption_freight_dropin_fuel\n            Energy consumption in the form of drop-in fuels from freight air transport [MJ].\n    energy_consumption_dropin_fuel\n            Energy consumption in the form of drop-in fuels from all commercial air transport [MJ].\n    \"\"\"\n\n    # WITHOUT OPERATIONS\n    # Drop-in fuel\n    energy_consumption_short_range_dropin_fuel_without_operations = (\n        energy_per_ask_without_operations_short_range_dropin_fuel * ask_short_range_dropin_fuel\n    )\n    energy_consumption_medium_range_dropin_fuel_without_operations = (\n        energy_per_ask_without_operations_medium_range_dropin_fuel\n        * ask_medium_range_dropin_fuel\n    )\n    energy_consumption_long_range_dropin_fuel_without_operations = (\n        energy_per_ask_without_operations_long_range_dropin_fuel * ask_long_range_dropin_fuel\n    )\n    energy_consumption_passenger_dropin_fuel_without_operations = (\n        energy_consumption_short_range_dropin_fuel_without_operations\n        + energy_consumption_medium_range_dropin_fuel_without_operations\n        + energy_consumption_long_range_dropin_fuel_without_operations\n    )\n    energy_consumption_freight_dropin_fuel_without_operations = (\n        energy_per_rtk_without_operations_freight_dropin_fuel * rtk_dropin_fuel\n    )\n    energy_consumption_dropin_fuel_without_operations = (\n        energy_consumption_passenger_dropin_fuel_without_operations\n        + energy_consumption_freight_dropin_fuel_without_operations\n    )\n\n    self.df.loc[:, \"energy_consumption_short_range_dropin_fuel_without_operations\"] = (\n        energy_consumption_short_range_dropin_fuel_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_medium_range_dropin_fuel_without_operations\"] = (\n        energy_consumption_medium_range_dropin_fuel_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_long_range_dropin_fuel_without_operations\"] = (\n        energy_consumption_long_range_dropin_fuel_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_passenger_dropin_fuel_without_operations\"] = (\n        energy_consumption_passenger_dropin_fuel_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_freight_dropin_fuel_without_operations\"] = (\n        energy_consumption_freight_dropin_fuel_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_dropin_fuel_without_operations\"] = (\n        energy_consumption_dropin_fuel_without_operations\n    )\n\n    # WITH OPERATIONS\n    # Drop-in fuel\n    energy_consumption_short_range_dropin_fuel = (\n        energy_per_ask_short_range_dropin_fuel * ask_short_range_dropin_fuel\n    )\n    energy_consumption_medium_range_dropin_fuel = (\n        energy_per_ask_medium_range_dropin_fuel * ask_medium_range_dropin_fuel\n    )\n    energy_consumption_long_range_dropin_fuel = (\n        energy_per_ask_long_range_dropin_fuel * ask_long_range_dropin_fuel\n    )\n    energy_consumption_passenger_dropin_fuel = (\n        energy_consumption_short_range_dropin_fuel\n        + energy_consumption_medium_range_dropin_fuel\n        + energy_consumption_long_range_dropin_fuel\n    )\n    energy_consumption_freight_dropin_fuel = (\n        energy_per_rtk_freight_dropin_fuel * rtk_dropin_fuel\n    )\n    energy_consumption_dropin_fuel = (\n        energy_consumption_passenger_dropin_fuel + energy_consumption_freight_dropin_fuel\n    )\n\n    self.df.loc[:, \"energy_consumption_short_range_dropin_fuel\"] = (\n        energy_consumption_short_range_dropin_fuel\n    )\n    self.df.loc[:, \"energy_consumption_medium_range_dropin_fuel\"] = (\n        energy_consumption_medium_range_dropin_fuel\n    )\n    self.df.loc[:, \"energy_consumption_long_range_dropin_fuel\"] = (\n        energy_consumption_long_range_dropin_fuel\n    )\n    self.df.loc[:, \"energy_consumption_passenger_dropin_fuel\"] = (\n        energy_consumption_passenger_dropin_fuel\n    )\n    self.df.loc[:, \"energy_consumption_freight_dropin_fuel\"] = (\n        energy_consumption_freight_dropin_fuel\n    )\n    self.df.loc[:, \"energy_consumption_dropin_fuel\"] = energy_consumption_dropin_fuel\n\n    return (\n        energy_consumption_short_range_dropin_fuel_without_operations,\n        energy_consumption_medium_range_dropin_fuel_without_operations,\n        energy_consumption_long_range_dropin_fuel_without_operations,\n        energy_consumption_passenger_dropin_fuel_without_operations,\n        energy_consumption_freight_dropin_fuel_without_operations,\n        energy_consumption_dropin_fuel_without_operations,\n        energy_consumption_short_range_dropin_fuel,\n        energy_consumption_medium_range_dropin_fuel,\n        energy_consumption_long_range_dropin_fuel,\n        energy_consumption_passenger_dropin_fuel,\n        energy_consumption_freight_dropin_fuel,\n        energy_consumption_dropin_fuel,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.energy_resources.energy_consumption/#aeromaps.models.impacts.energy_resources.energy_consumption.DropInFuelDetailledConsumption","title":"DropInFuelDetailledConsumption","text":"<pre><code>DropInFuelDetailledConsumption(name='drop_in_fuel_detailled_consumption', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Detailled drop-in fuel consumption calculation.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('drop_in_fuel_detailled_consumption' by default).</p> <code>'drop_in_fuel_detailled_consumption'</code> Source code in <code>aeromaps/models/impacts/energy_resources/energy_consumption.py</code> <pre><code>def __init__(self, name=\"drop_in_fuel_detailled_consumption\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.energy_resources.energy_consumption/#aeromaps.models.impacts.energy_resources.energy_consumption.DropInFuelDetailledConsumption.compute","title":"compute","text":"<pre><code>compute(biomass_share_dropin_fuel, electricity_share_dropin_fuel, fossil_share_dropin_fuel, energy_consumption_short_range_dropin_fuel_without_operations, energy_consumption_medium_range_dropin_fuel_without_operations, energy_consumption_long_range_dropin_fuel_without_operations, energy_consumption_freight_dropin_fuel_without_operations, energy_consumption_short_range_dropin_fuel, energy_consumption_medium_range_dropin_fuel, energy_consumption_long_range_dropin_fuel, energy_consumption_freight_dropin_fuel)\n</code></pre> <p>Drop-in fuel consumption calculation.</p> <p>Parameters:</p> Name Type Description Default <code>biomass_share_dropin_fuel</code> <code>Series</code> <p>Share of biomass-based fuels in drop-in fuels [%].</p> required <code>electricity_share_dropin_fuel</code> <code>Series</code> <p>Share of electricity-based fuels in drop-in fuels [%].</p> required <code>fossil_share_dropin_fuel</code> <code>Series</code> <p>Share of fossil-based fuels in drop-in fuels [%].</p> required <code>energy_consumption_short_range_dropin_fuel_without_operations</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels without considering operation improvements from passenger short-range market air transport [MJ].</p> required <code>energy_consumption_medium_range_dropin_fuel_without_operations</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels without considering operation improvements from passenger medium-range market air transport [MJ].</p> required <code>energy_consumption_long_range_dropin_fuel_without_operations</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels without considering operation improvements from passenger long-range market air transport [MJ].</p> required <code>energy_consumption_freight_dropin_fuel_without_operations</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels without considering operation improvements from freight air transport [MJ].</p> required <code>energy_consumption_short_range_dropin_fuel</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels from passenger short-range market air transport [MJ].</p> required <code>energy_consumption_medium_range_dropin_fuel</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels from passenger medium-range market air transport [MJ].</p> required <code>energy_consumption_long_range_dropin_fuel</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels from passenger long-range market air transport [MJ].</p> required <code>energy_consumption_freight_dropin_fuel</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels from freight air transport [MJ].</p> required <p>Returns:</p> Type Description <code>energy_consumption_short_range_biofuel_without_operations</code> <p>Energy consumption in the form of biofuels without considering operation improvements from passenger short-range market air transport [MJ].</p> <code>energy_consumption_medium_range_biofuel_without_operations</code> <p>Energy consumption in the form of biofuels without considering operation improvements from passenger medium-range market air transport [MJ].</p> <code>energy_consumption_long_range_biofuel_without_operations</code> <p>Energy consumption in the form of biofuels without considering operation improvements from passenger long-range market air transport [MJ].</p> <code>energy_consumption_passenger_biofuel_without_operations</code> <p>Energy consumption in the form of biofuels without considering operation improvements from total passenger air transport [MJ].</p> <code>energy_consumption_freight_biofuel_without_operations</code> <p>Energy consumption in the form of biofuels without considering operation improvements from freight air transport [MJ].</p> <code>energy_consumption_biofuel_without_operations</code> <p>Energy consumption in the form of biofuels without considering operation improvements from all commercial air transport [MJ].</p> <code>energy_consumption_short_range_electrofuel_without_operations</code> <p>Energy consumption in the form of electrofuels without considering operation improvements from passenger short-range market air transport [MJ].</p> <code>energy_consumption_medium_range_electrofuel_without_operations</code> <p>Energy consumption in the form of electrofuels without considering operation improvements from passenger medium-range market air transport [MJ].</p> <code>energy_consumption_long_range_electrofuel_without_operations</code> <p>Energy consumption in the form of electrofuels without considering operation improvements from passenger long-range market air transport [MJ].</p> <code>energy_consumption_passenger_electrofuel_without_operations</code> <p>Energy consumption in the form of electrofuels without considering operation improvements from total passenger air transport [MJ].</p> <code>energy_consumption_freight_electrofuel_without_operations</code> <p>Energy consumption in the form of electrofuels without considering operation improvements from freight air transport [MJ].</p> <code>energy_consumption_electrofuel_without_operations</code> <p>Energy consumption in the form of electrofuels without considering operation improvements from all commercial air transport [MJ].</p> <code>energy_consumption_short_range_kerosene_without_operations</code> <p>Energy consumption in the form of kerosene without considering operation improvements from passenger short-range market air transport [MJ].</p> <code>energy_consumption_medium_range_kerosene_without_operations</code> <p>Energy consumption in the form of kerosene without considering operation improvements from passenger medium-range market air transport [MJ].</p> <code>energy_consumption_long_range_kerosene_without_operations</code> <p>Energy consumption in the form of kerosene without considering operation improvements from passenger long-range market air transport [MJ].</p> <code>energy_consumption_passenger_kerosene_without_operations</code> <p>Energy consumption in the form of kerosene without considering operation improvements from total passenger air transport [MJ].</p> <code>energy_consumption_freight_kerosene_without_operations</code> <p>Energy consumption in the form of kerosene without considering operation improvements from freight air transport [MJ].</p> <code>energy_consumption_kerosene_without_operations</code> <p>Energy consumption in the form of kerosene without considering operation improvements from all commercial air transport [MJ].</p> <code>energy_consumption_short_range_biofuel</code> <p>Energy consumption in the form of biofuels from passenger short-range market air transport [MJ].</p> <code>energy_consumption_medium_range_biofuel</code> <p>Energy consumption in the form of biofuels from passenger medium-range market air transport [MJ].</p> <code>energy_consumption_long_range_biofuel</code> <p>Energy consumption in the form of biofuels from passenger long-range market air transport [MJ].</p> <code>energy_consumption_passenger_biofuel</code> <p>Energy consumption in the form of biofuels from total passenger air transport [MJ].</p> <code>energy_consumption_freight_biofuel</code> <p>Energy consumption in the form of biofuels from freight air transport [MJ].</p> <code>energy_consumption_biofuel</code> <p>Energy consumption in the form of biofuels from all commercial air transport [MJ].</p> <code>energy_consumption_short_range_electrofuel</code> <p>Energy consumption in the form of electrofuels from passenger short-range market air transport [MJ].</p> <code>energy_consumption_medium_range_electrofuel</code> <p>Energy consumption in the form of electrofuels from passenger medium-range market air transport [MJ].</p> <code>energy_consumption_long_range_electrofuel</code> <p>Energy consumption in the form of electrofuels from passenger long-range market air transport [MJ].</p> <code>energy_consumption_passenger_electrofuel</code> <p>Energy consumption in the form of electrofuels from total passenger air transport [MJ].</p> <code>energy_consumption_freight_electrofuel</code> <p>Energy consumption in the form of electrofuels from freight air transport [MJ].</p> <code>energy_consumption_electrofuel</code> <p>Energy consumption in the form of electrofuels from all commercial air transport [MJ].</p> <code>energy_consumption_short_range_kerosene</code> <p>Energy consumption in the form of kerosene from passenger short-range market air transport [MJ].</p> <code>energy_consumption_medium_range_kerosene</code> <p>Energy consumption in the form of kerosene from passenger medium-range market air transport [MJ].</p> <code>energy_consumption_long_range_kerosene</code> <p>Energy consumption in the form of kerosene from passenger long-range market air transport [MJ].</p> <code>energy_consumption_passenger_kerosene</code> <p>Energy consumption in the form of kerosene from total passenger air transport [MJ].</p> <code>energy_consumption_freight_kerosene</code> <p>Energy consumption in the form of kerosene from freight air transport [MJ].</p> <code>energy_consumption_kerosene</code> <p>Energy consumption in the form of kerosene from all commercial air transport [MJ].</p> Source code in <code>aeromaps/models/impacts/energy_resources/energy_consumption.py</code> <pre><code>def compute(\n    self,\n    biomass_share_dropin_fuel: pd.Series,\n    electricity_share_dropin_fuel: pd.Series,\n    fossil_share_dropin_fuel: pd.Series,\n    energy_consumption_short_range_dropin_fuel_without_operations: pd.Series,\n    energy_consumption_medium_range_dropin_fuel_without_operations: pd.Series,\n    energy_consumption_long_range_dropin_fuel_without_operations: pd.Series,\n    energy_consumption_freight_dropin_fuel_without_operations: pd.Series,\n    energy_consumption_short_range_dropin_fuel: pd.Series,\n    energy_consumption_medium_range_dropin_fuel: pd.Series,\n    energy_consumption_long_range_dropin_fuel: pd.Series,\n    energy_consumption_freight_dropin_fuel: pd.Series,\n) -&gt; Tuple[\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n]:\n    # TODO further adapt to generic energy model outputs?\n    \"\"\"\n    Drop-in fuel consumption calculation.\n\n    Parameters\n    ----------\n    biomass_share_dropin_fuel\n        Share of biomass-based fuels in drop-in fuels [%].\n    electricity_share_dropin_fuel\n        Share of electricity-based fuels in drop-in fuels [%].\n    fossil_share_dropin_fuel\n        Share of fossil-based fuels in drop-in fuels [%].\n    energy_consumption_short_range_dropin_fuel_without_operations\n        Energy consumption in the form of drop-in fuels without considering operation improvements from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_dropin_fuel_without_operations\n        Energy consumption in the form of drop-in fuels without considering operation improvements from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_dropin_fuel_without_operations\n        Energy consumption in the form of drop-in fuels without considering operation improvements from passenger long-range market air transport [MJ].\n    energy_consumption_freight_dropin_fuel_without_operations\n        Energy consumption in the form of drop-in fuels without considering operation improvements from freight air transport [MJ].\n    energy_consumption_short_range_dropin_fuel\n        Energy consumption in the form of drop-in fuels from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_dropin_fuel\n        Energy consumption in the form of drop-in fuels from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_dropin_fuel\n        Energy consumption in the form of drop-in fuels from passenger long-range market air transport [MJ].\n    energy_consumption_freight_dropin_fuel\n        Energy consumption in the form of drop-in fuels from freight air transport [MJ].\n\n    Returns\n    -------\n    energy_consumption_short_range_biofuel_without_operations\n            Energy consumption in the form of biofuels without considering operation improvements from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_biofuel_without_operations\n            Energy consumption in the form of biofuels without considering operation improvements from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_biofuel_without_operations\n            Energy consumption in the form of biofuels without considering operation improvements from passenger long-range market air transport [MJ].\n    energy_consumption_passenger_biofuel_without_operations\n            Energy consumption in the form of biofuels without considering operation improvements from total passenger air transport [MJ].\n    energy_consumption_freight_biofuel_without_operations\n            Energy consumption in the form of biofuels without considering operation improvements from freight air transport [MJ].\n    energy_consumption_biofuel_without_operations\n            Energy consumption in the form of biofuels without considering operation improvements from all commercial air transport [MJ].\n    energy_consumption_short_range_electrofuel_without_operations\n            Energy consumption in the form of electrofuels without considering operation improvements from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_electrofuel_without_operations\n            Energy consumption in the form of electrofuels without considering operation improvements from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_electrofuel_without_operations\n            Energy consumption in the form of electrofuels without considering operation improvements from passenger long-range market air transport [MJ].\n    energy_consumption_passenger_electrofuel_without_operations\n            Energy consumption in the form of electrofuels without considering operation improvements from total passenger air transport [MJ].\n    energy_consumption_freight_electrofuel_without_operations\n            Energy consumption in the form of electrofuels without considering operation improvements from freight air transport [MJ].\n    energy_consumption_electrofuel_without_operations\n            Energy consumption in the form of electrofuels without considering operation improvements from all commercial air transport [MJ].\n    energy_consumption_short_range_kerosene_without_operations\n            Energy consumption in the form of kerosene without considering operation improvements from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_kerosene_without_operations\n            Energy consumption in the form of kerosene without considering operation improvements from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_kerosene_without_operations\n            Energy consumption in the form of kerosene without considering operation improvements from passenger long-range market air transport [MJ].\n    energy_consumption_passenger_kerosene_without_operations\n            Energy consumption in the form of kerosene without considering operation improvements from total passenger air transport [MJ].\n    energy_consumption_freight_kerosene_without_operations\n            Energy consumption in the form of kerosene without considering operation improvements from freight air transport [MJ].\n    energy_consumption_kerosene_without_operations\n            Energy consumption in the form of kerosene without considering operation improvements from all commercial air transport [MJ].\n    energy_consumption_short_range_biofuel\n            Energy consumption in the form of biofuels from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_biofuel\n            Energy consumption in the form of biofuels from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_biofuel\n            Energy consumption in the form of biofuels from passenger long-range market air transport [MJ].\n    energy_consumption_passenger_biofuel\n            Energy consumption in the form of biofuels from total passenger air transport [MJ].\n    energy_consumption_freight_biofuel\n            Energy consumption in the form of biofuels from freight air transport [MJ].\n    energy_consumption_biofuel\n            Energy consumption in the form of biofuels from all commercial air transport [MJ].\n    energy_consumption_short_range_electrofuel\n            Energy consumption in the form of electrofuels from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_electrofuel\n            Energy consumption in the form of electrofuels from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_electrofuel\n            Energy consumption in the form of electrofuels from passenger long-range market air transport [MJ].\n    energy_consumption_passenger_electrofuel\n            Energy consumption in the form of electrofuels from total passenger air transport [MJ].\n    energy_consumption_freight_electrofuel\n            Energy consumption in the form of electrofuels from freight air transport [MJ].\n    energy_consumption_electrofuel\n            Energy consumption in the form of electrofuels from all commercial air transport [MJ].\n    energy_consumption_short_range_kerosene\n            Energy consumption in the form of kerosene from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_kerosene\n            Energy consumption in the form of kerosene from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_kerosene\n            Energy consumption in the form of kerosene from passenger long-range market air transport [MJ].\n    energy_consumption_passenger_kerosene\n            Energy consumption in the form of kerosene from total passenger air transport [MJ].\n    energy_consumption_freight_kerosene\n            Energy consumption in the form of kerosene from freight air transport [MJ].\n    energy_consumption_kerosene\n            Energy consumption in the form of kerosene from all commercial air transport [MJ].\n    \"\"\"\n    # WITHOUT OPERATIONS\n    # Biofuel\n    energy_consumption_short_range_biofuel_without_operations = (\n        biomass_share_dropin_fuel\n        / 100\n        * energy_consumption_short_range_dropin_fuel_without_operations\n    )\n    energy_consumption_medium_range_biofuel_without_operations = (\n        biomass_share_dropin_fuel\n        / 100\n        * energy_consumption_medium_range_dropin_fuel_without_operations\n    )\n    energy_consumption_long_range_biofuel_without_operations = (\n        biomass_share_dropin_fuel\n        / 100\n        * energy_consumption_long_range_dropin_fuel_without_operations\n    )\n    energy_consumption_passenger_biofuel_without_operations = (\n        energy_consumption_short_range_biofuel_without_operations\n        + energy_consumption_medium_range_biofuel_without_operations\n        + energy_consumption_long_range_biofuel_without_operations\n    )\n    energy_consumption_freight_biofuel_without_operations = (\n        biomass_share_dropin_fuel\n        / 100\n        * energy_consumption_freight_dropin_fuel_without_operations\n    )\n    energy_consumption_biofuel_without_operations = (\n        energy_consumption_passenger_biofuel_without_operations\n        + energy_consumption_freight_biofuel_without_operations\n    )\n\n    self.df.loc[:, \"energy_consumption_short_range_biofuel_without_operations\"] = (\n        energy_consumption_short_range_biofuel_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_medium_range_biofuel_without_operations\"] = (\n        energy_consumption_medium_range_biofuel_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_long_range_biofuel_without_operations\"] = (\n        energy_consumption_long_range_biofuel_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_passenger_biofuel_without_operations\"] = (\n        energy_consumption_passenger_biofuel_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_freight_biofuel_without_operations\"] = (\n        energy_consumption_freight_biofuel_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_biofuel_without_operations\"] = (\n        energy_consumption_biofuel_without_operations\n    )\n\n    # Electrofuel\n    energy_consumption_short_range_electrofuel_without_operations = (\n        electricity_share_dropin_fuel\n        / 100\n        * energy_consumption_short_range_dropin_fuel_without_operations\n    )\n    energy_consumption_medium_range_electrofuel_without_operations = (\n        electricity_share_dropin_fuel\n        / 100\n        * energy_consumption_medium_range_dropin_fuel_without_operations\n    )\n    energy_consumption_long_range_electrofuel_without_operations = (\n        electricity_share_dropin_fuel\n        / 100\n        * energy_consumption_long_range_dropin_fuel_without_operations\n    )\n    energy_consumption_passenger_electrofuel_without_operations = (\n        energy_consumption_short_range_electrofuel_without_operations\n        + energy_consumption_medium_range_electrofuel_without_operations\n        + energy_consumption_long_range_electrofuel_without_operations\n    )\n    energy_consumption_freight_electrofuel_without_operations = (\n        electricity_share_dropin_fuel\n        / 100\n        * energy_consumption_freight_dropin_fuel_without_operations\n    )\n    energy_consumption_electrofuel_without_operations = (\n        energy_consumption_passenger_electrofuel_without_operations\n        + energy_consumption_freight_electrofuel_without_operations\n    )\n\n    self.df.loc[:, \"energy_consumption_short_range_electrofuel_without_operations\"] = (\n        energy_consumption_short_range_electrofuel_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_medium_range_electrofuel_without_operations\"] = (\n        energy_consumption_medium_range_electrofuel_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_long_range_electrofuel_without_operations\"] = (\n        energy_consumption_long_range_electrofuel_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_passenger_electrofuel_without_operations\"] = (\n        energy_consumption_passenger_electrofuel_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_freight_electrofuel_without_operations\"] = (\n        energy_consumption_freight_electrofuel_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_electrofuel_without_operations\"] = (\n        energy_consumption_electrofuel_without_operations\n    )\n\n    # Kerosene\n    energy_consumption_short_range_kerosene_without_operations = (\n        fossil_share_dropin_fuel\n        / 100\n        * energy_consumption_short_range_dropin_fuel_without_operations\n    )\n    energy_consumption_medium_range_kerosene_without_operations = (\n        fossil_share_dropin_fuel\n        / 100\n        * energy_consumption_medium_range_dropin_fuel_without_operations\n    )\n    energy_consumption_long_range_kerosene_without_operations = (\n        fossil_share_dropin_fuel\n        / 100\n        * energy_consumption_long_range_dropin_fuel_without_operations\n    )\n    energy_consumption_passenger_kerosene_without_operations = (\n        energy_consumption_short_range_kerosene_without_operations\n        + energy_consumption_medium_range_kerosene_without_operations\n        + energy_consumption_long_range_kerosene_without_operations\n    )\n    energy_consumption_freight_kerosene_without_operations = (\n        fossil_share_dropin_fuel\n        / 100\n        * energy_consumption_freight_dropin_fuel_without_operations\n    )\n    energy_consumption_kerosene_without_operations = (\n        energy_consumption_passenger_kerosene_without_operations\n        + energy_consumption_freight_kerosene_without_operations\n    )\n\n    self.df.loc[:, \"energy_consumption_short_range_kerosene_without_operations\"] = (\n        energy_consumption_short_range_kerosene_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_medium_range_kerosene_without_operations\"] = (\n        energy_consumption_medium_range_kerosene_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_long_range_kerosene_without_operations\"] = (\n        energy_consumption_long_range_kerosene_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_passenger_kerosene_without_operations\"] = (\n        energy_consumption_passenger_kerosene_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_freight_kerosene_without_operations\"] = (\n        energy_consumption_freight_kerosene_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_kerosene_without_operations\"] = (\n        energy_consumption_kerosene_without_operations\n    )\n\n    # WITH OPERATIONS\n    # Biofuel\n    energy_consumption_short_range_biofuel = (\n        biomass_share_dropin_fuel / 100 * energy_consumption_short_range_dropin_fuel\n    )\n    energy_consumption_medium_range_biofuel = (\n        biomass_share_dropin_fuel / 100 * energy_consumption_medium_range_dropin_fuel\n    )\n    energy_consumption_long_range_biofuel = (\n        biomass_share_dropin_fuel / 100 * energy_consumption_long_range_dropin_fuel\n    )\n    energy_consumption_passenger_biofuel = (\n        energy_consumption_short_range_biofuel\n        + energy_consumption_medium_range_biofuel\n        + energy_consumption_long_range_biofuel\n    )\n    energy_consumption_freight_biofuel = (\n        biomass_share_dropin_fuel / 100 * energy_consumption_freight_dropin_fuel\n    )\n    energy_consumption_biofuel = (\n        energy_consumption_passenger_biofuel + energy_consumption_freight_biofuel\n    )\n\n    self.df.loc[:, \"energy_consumption_short_range_biofuel\"] = (\n        energy_consumption_short_range_biofuel\n    )\n    self.df.loc[:, \"energy_consumption_medium_range_biofuel\"] = (\n        energy_consumption_medium_range_biofuel\n    )\n    self.df.loc[:, \"energy_consumption_long_range_biofuel\"] = (\n        energy_consumption_long_range_biofuel\n    )\n    self.df.loc[:, \"energy_consumption_passenger_biofuel\"] = (\n        energy_consumption_passenger_biofuel\n    )\n    self.df.loc[:, \"energy_consumption_freight_biofuel\"] = energy_consumption_freight_biofuel\n    self.df.loc[:, \"energy_consumption_biofuel\"] = energy_consumption_biofuel\n\n    # Electrofuel\n    energy_consumption_short_range_electrofuel = (\n        electricity_share_dropin_fuel / 100 * energy_consumption_short_range_dropin_fuel\n    )\n    energy_consumption_medium_range_electrofuel = (\n        electricity_share_dropin_fuel / 100 * energy_consumption_medium_range_dropin_fuel\n    )\n    energy_consumption_long_range_electrofuel = (\n        electricity_share_dropin_fuel / 100 * energy_consumption_long_range_dropin_fuel\n    )\n    energy_consumption_passenger_electrofuel = (\n        energy_consumption_short_range_electrofuel\n        + energy_consumption_medium_range_electrofuel\n        + energy_consumption_long_range_electrofuel\n    )\n    energy_consumption_freight_electrofuel = (\n        electricity_share_dropin_fuel / 100 * energy_consumption_freight_dropin_fuel\n    )\n    energy_consumption_electrofuel = (\n        energy_consumption_passenger_electrofuel + energy_consumption_freight_electrofuel\n    )\n\n    self.df.loc[:, \"energy_consumption_short_range_electrofuel\"] = (\n        energy_consumption_short_range_electrofuel\n    )\n    self.df.loc[:, \"energy_consumption_medium_range_electrofuel\"] = (\n        energy_consumption_medium_range_electrofuel\n    )\n    self.df.loc[:, \"energy_consumption_long_range_electrofuel\"] = (\n        energy_consumption_long_range_electrofuel\n    )\n    self.df.loc[:, \"energy_consumption_passenger_electrofuel\"] = (\n        energy_consumption_passenger_electrofuel\n    )\n    self.df.loc[:, \"energy_consumption_freight_electrofuel\"] = (\n        energy_consumption_freight_electrofuel\n    )\n    self.df.loc[:, \"energy_consumption_electrofuel\"] = energy_consumption_electrofuel\n\n    # Kerosene\n    energy_consumption_short_range_kerosene = (\n        fossil_share_dropin_fuel / 100 * energy_consumption_short_range_dropin_fuel\n    )\n    energy_consumption_medium_range_kerosene = (\n        fossil_share_dropin_fuel / 100 * energy_consumption_medium_range_dropin_fuel\n    )\n    energy_consumption_long_range_kerosene = (\n        fossil_share_dropin_fuel / 100 * energy_consumption_long_range_dropin_fuel\n    )\n    energy_consumption_passenger_kerosene = (\n        energy_consumption_short_range_kerosene\n        + energy_consumption_medium_range_kerosene\n        + energy_consumption_long_range_kerosene\n    )\n    energy_consumption_freight_kerosene = (\n        fossil_share_dropin_fuel / 100 * energy_consumption_freight_dropin_fuel\n    )\n    energy_consumption_kerosene = (\n        energy_consumption_passenger_kerosene + energy_consumption_freight_kerosene\n    )\n\n    self.df.loc[:, \"energy_consumption_short_range_kerosene\"] = (\n        energy_consumption_short_range_kerosene\n    )\n    self.df.loc[:, \"energy_consumption_medium_range_kerosene\"] = (\n        energy_consumption_medium_range_kerosene\n    )\n    self.df.loc[:, \"energy_consumption_long_range_kerosene\"] = (\n        energy_consumption_long_range_kerosene\n    )\n    self.df.loc[:, \"energy_consumption_passenger_kerosene\"] = (\n        energy_consumption_passenger_kerosene\n    )\n    self.df.loc[:, \"energy_consumption_freight_kerosene\"] = energy_consumption_freight_kerosene\n    self.df.loc[:, \"energy_consumption_kerosene\"] = energy_consumption_kerosene\n\n    return (\n        energy_consumption_short_range_biofuel_without_operations,\n        energy_consumption_medium_range_biofuel_without_operations,\n        energy_consumption_long_range_biofuel_without_operations,\n        energy_consumption_passenger_biofuel_without_operations,\n        energy_consumption_freight_biofuel_without_operations,\n        energy_consumption_biofuel_without_operations,\n        energy_consumption_short_range_electrofuel_without_operations,\n        energy_consumption_medium_range_electrofuel_without_operations,\n        energy_consumption_long_range_electrofuel_without_operations,\n        energy_consumption_passenger_electrofuel_without_operations,\n        energy_consumption_freight_electrofuel_without_operations,\n        energy_consumption_electrofuel_without_operations,\n        energy_consumption_short_range_kerosene_without_operations,\n        energy_consumption_medium_range_kerosene_without_operations,\n        energy_consumption_long_range_kerosene_without_operations,\n        energy_consumption_passenger_kerosene_without_operations,\n        energy_consumption_freight_kerosene_without_operations,\n        energy_consumption_kerosene_without_operations,\n        energy_consumption_short_range_biofuel,\n        energy_consumption_medium_range_biofuel,\n        energy_consumption_long_range_biofuel,\n        energy_consumption_passenger_biofuel,\n        energy_consumption_freight_biofuel,\n        energy_consumption_biofuel,\n        energy_consumption_short_range_electrofuel,\n        energy_consumption_medium_range_electrofuel,\n        energy_consumption_long_range_electrofuel,\n        energy_consumption_passenger_electrofuel,\n        energy_consumption_freight_electrofuel,\n        energy_consumption_electrofuel,\n        energy_consumption_short_range_kerosene,\n        energy_consumption_medium_range_kerosene,\n        energy_consumption_long_range_kerosene,\n        energy_consumption_passenger_kerosene,\n        energy_consumption_freight_kerosene,\n        energy_consumption_kerosene,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.energy_resources.energy_consumption/#aeromaps.models.impacts.energy_resources.energy_consumption.HydrogenConsumption","title":"HydrogenConsumption","text":"<pre><code>HydrogenConsumption(name='hydrogen_consumption', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to calculate hydrogen consumption for each type of market.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('hydrogen_consumption' by default).</p> <code>'hydrogen_consumption'</code> Source code in <code>aeromaps/models/impacts/energy_resources/energy_consumption.py</code> <pre><code>def __init__(self, name=\"hydrogen_consumption\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.energy_resources.energy_consumption/#aeromaps.models.impacts.energy_resources.energy_consumption.HydrogenConsumption.compute","title":"compute","text":"<pre><code>compute(ask_short_range_hydrogen, ask_medium_range_hydrogen, ask_long_range_hydrogen, rtk_hydrogen, energy_per_ask_without_operations_short_range_hydrogen, energy_per_ask_without_operations_medium_range_hydrogen, energy_per_ask_without_operations_long_range_hydrogen, energy_per_rtk_without_operations_freight_hydrogen, energy_per_ask_short_range_hydrogen, energy_per_ask_medium_range_hydrogen, energy_per_ask_long_range_hydrogen, energy_per_rtk_freight_hydrogen)\n</code></pre> <p>Hydrogen consumption calculation.</p> <p>Parameters:</p> Name Type Description Default <code>ask_short_range_hydrogen</code> <code>Series</code> <p>Number of Available Seat Kilometer (ASK) for passenger short-range market from hydrogen aircraft [ASK].</p> required <code>ask_medium_range_hydrogen</code> <code>Series</code> <p>Number of Available Seat Kilometer (ASK) for passenger medium-range market from hydrogen aircraft [ASK].</p> required <code>ask_long_range_hydrogen</code> <code>Series</code> <p>Number of Available Seat Kilometer (ASK) for passenger long-range market from hydrogen aircraft [ASK]</p> required <code>rtk_hydrogen</code> <code>Series</code> <p>Number of Revenue Tonne Kilometer (RTK) for freight air transport from hydrogen aircraft [RTK].</p> required <code>energy_per_ask_without_operations_short_range_hydrogen</code> <code>Series</code> <p>Energy consumption per ASK for passenger short-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].</p> required <code>energy_per_ask_without_operations_medium_range_hydrogen</code> <code>Series</code> <p>Energy consumption per ASK for passenger medium-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].</p> required <code>energy_per_ask_without_operations_long_range_hydrogen</code> <code>Series</code> <p>Energy consumption per ASK for passenger long-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].</p> required <code>energy_per_rtk_without_operations_freight_hydrogen</code> <code>Series</code> <p>Energy consumption per RTK for freight aircraft using hydrogen without considering operation improvements [MJ/RTK].</p> required <code>energy_per_ask_short_range_hydrogen</code> <code>Series</code> <p>Energy consumption per ASK for passenger short-range market aircraft using hydrogen [MJ/ASK].</p> required <code>energy_per_ask_medium_range_hydrogen</code> <code>Series</code> <p>Energy consumption per ASK for passenger medium-range market aircraft using hydrogen [MJ/ASK].</p> required <code>energy_per_ask_long_range_hydrogen</code> <code>Series</code> <p>Energy consumption per ASK for passenger long-range market aircraft using hydrogen [MJ/ASK].</p> required <code>energy_per_rtk_freight_hydrogen</code> <code>Series</code> <p>Energy consumption per RTK for freight aircraft using hydrogen [MJ/RTK].</p> required <p>Returns:</p> Type Description <code>energy_consumption_short_range_hydrogen_without_operations</code> <p>Energy consumption in the form of hydrogen without considering operation improvements from passenger short-range market air transport [MJ].</p> <code>energy_consumption_medium_range_hydrogen_without_operations</code> <p>Energy consumption in the form of hydrogen without considering operation improvements from passenger medium-range market air transport [MJ].</p> <code>energy_consumption_long_range_hydrogen_without_operations</code> <p>Energy consumption in the form of hydrogen without considering operation improvements from passenger long-range market air transport [MJ].</p> <code>energy_consumption_passenger_hydrogen_without_operations</code> <p>Energy consumption in the form of hydrogen without considering operation improvements from total passenger air transport [MJ].</p> <code>energy_consumption_freight_hydrogen_without_operations</code> <p>Energy consumption in the form of hydrogen without considering operation improvements from freight air transport [MJ].</p> <code>energy_consumption_hydrogen_without_operations</code> <p>Energy consumption in the form of hydrogen without considering operation improvements from all commercial air transport [MJ].</p> <code>energy_consumption_short_range_hydrogen</code> <p>Energy consumption in the form of hydrogen from passenger short-range market air transport [MJ].</p> <code>energy_consumption_medium_range_hydrogen</code> <p>Energy consumption in the form of hydrogen from passenger medium-range market air transport [MJ].</p> <code>energy_consumption_long_range_hydrogen</code> <p>Energy consumption in the form of hydrogen from passenger long-range market air transport [MJ].</p> <code>energy_consumption_passenger_hydrogen</code> <p>Energy consumption in the form of hydrogen from total passenger air transport [MJ].</p> <code>energy_consumption_freight_hydrogen</code> <p>Energy consumption in the form of hydrogen from freight air transport [MJ].</p> <code>energy_consumption_hydrogen</code> <p>Energy consumption in the form of hydrogen from all commercial air transport [MJ].</p> Source code in <code>aeromaps/models/impacts/energy_resources/energy_consumption.py</code> <pre><code>def compute(\n    self,\n    ask_short_range_hydrogen: pd.Series,\n    ask_medium_range_hydrogen: pd.Series,\n    ask_long_range_hydrogen: pd.Series,\n    rtk_hydrogen: pd.Series,\n    energy_per_ask_without_operations_short_range_hydrogen: pd.Series,\n    energy_per_ask_without_operations_medium_range_hydrogen: pd.Series,\n    energy_per_ask_without_operations_long_range_hydrogen: pd.Series,\n    energy_per_rtk_without_operations_freight_hydrogen: pd.Series,\n    energy_per_ask_short_range_hydrogen: pd.Series,\n    energy_per_ask_medium_range_hydrogen: pd.Series,\n    energy_per_ask_long_range_hydrogen: pd.Series,\n    energy_per_rtk_freight_hydrogen: pd.Series,\n) -&gt; Tuple[\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n]:\n    \"\"\"\n    Hydrogen consumption calculation.\n\n    Parameters\n    ----------\n    ask_short_range_hydrogen\n        Number of Available Seat Kilometer (ASK) for passenger short-range market from hydrogen aircraft [ASK].\n    ask_medium_range_hydrogen\n        Number of Available Seat Kilometer (ASK) for passenger medium-range market from hydrogen aircraft [ASK].\n    ask_long_range_hydrogen\n        Number of Available Seat Kilometer (ASK) for passenger long-range market from hydrogen aircraft [ASK]\n    rtk_hydrogen\n        Number of Revenue Tonne Kilometer (RTK) for freight air transport from hydrogen aircraft [RTK].\n    energy_per_ask_without_operations_short_range_hydrogen\n        Energy consumption per ASK for passenger short-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_medium_range_hydrogen\n        Energy consumption per ASK for passenger medium-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_long_range_hydrogen\n        Energy consumption per ASK for passenger long-range market aircraft using hydrogen without considering operation improvements [MJ/ASK].\n    energy_per_rtk_without_operations_freight_hydrogen\n        Energy consumption per RTK for freight aircraft using hydrogen without considering operation improvements [MJ/RTK].\n    energy_per_ask_short_range_hydrogen\n        Energy consumption per ASK for passenger short-range market aircraft using hydrogen [MJ/ASK].\n    energy_per_ask_medium_range_hydrogen\n        Energy consumption per ASK for passenger medium-range market aircraft using hydrogen [MJ/ASK].\n    energy_per_ask_long_range_hydrogen\n        Energy consumption per ASK for passenger long-range market aircraft using hydrogen [MJ/ASK].\n    energy_per_rtk_freight_hydrogen\n        Energy consumption per RTK for freight aircraft using hydrogen [MJ/RTK].\n\n    Returns\n    -------\n    energy_consumption_short_range_hydrogen_without_operations\n        Energy consumption in the form of hydrogen without considering operation improvements from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_hydrogen_without_operations\n        Energy consumption in the form of hydrogen without considering operation improvements from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_hydrogen_without_operations\n        Energy consumption in the form of hydrogen without considering operation improvements from passenger long-range market air transport [MJ].\n    energy_consumption_passenger_hydrogen_without_operations\n        Energy consumption in the form of hydrogen without considering operation improvements from total passenger air transport [MJ].\n    energy_consumption_freight_hydrogen_without_operations\n        Energy consumption in the form of hydrogen without considering operation improvements from freight air transport [MJ].\n    energy_consumption_hydrogen_without_operations\n        Energy consumption in the form of hydrogen without considering operation improvements from all commercial air transport [MJ].\n    energy_consumption_short_range_hydrogen\n        Energy consumption in the form of hydrogen from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_hydrogen\n        Energy consumption in the form of hydrogen from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_hydrogen\n        Energy consumption in the form of hydrogen from passenger long-range market air transport [MJ].\n    energy_consumption_passenger_hydrogen\n        Energy consumption in the form of hydrogen from total passenger air transport [MJ].\n    energy_consumption_freight_hydrogen\n        Energy consumption in the form of hydrogen from freight air transport [MJ].\n    energy_consumption_hydrogen\n        Energy consumption in the form of hydrogen from all commercial air transport [MJ].\n    \"\"\"\n\n    # WITHOUT OPERATIONS\n    energy_consumption_short_range_hydrogen_without_operations = (\n        energy_per_ask_without_operations_short_range_hydrogen * ask_short_range_hydrogen\n    )\n    energy_consumption_medium_range_hydrogen_without_operations = (\n        energy_per_ask_without_operations_medium_range_hydrogen * ask_medium_range_hydrogen\n    )\n    energy_consumption_long_range_hydrogen_without_operations = (\n        energy_per_ask_without_operations_long_range_hydrogen * ask_long_range_hydrogen\n    )\n    energy_consumption_passenger_hydrogen_without_operations = (\n        energy_consumption_short_range_hydrogen_without_operations\n        + energy_consumption_medium_range_hydrogen_without_operations\n        + energy_consumption_long_range_hydrogen_without_operations\n    )\n    energy_consumption_freight_hydrogen_without_operations = (\n        energy_per_rtk_without_operations_freight_hydrogen * rtk_hydrogen\n    )\n    energy_consumption_hydrogen_without_operations = (\n        energy_consumption_passenger_hydrogen_without_operations\n        + energy_consumption_freight_hydrogen_without_operations\n    )\n\n    self.df.loc[:, \"energy_consumption_short_range_hydrogen_without_operations\"] = (\n        energy_consumption_short_range_hydrogen_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_medium_range_hydrogen_without_operations\"] = (\n        energy_consumption_medium_range_hydrogen_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_long_range_hydrogen_without_operations\"] = (\n        energy_consumption_long_range_hydrogen_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_passenger_hydrogen_without_operations\"] = (\n        energy_consumption_passenger_hydrogen_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_freight_hydrogen_without_operations\"] = (\n        energy_consumption_freight_hydrogen_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_hydrogen_without_operations\"] = (\n        energy_consumption_hydrogen_without_operations\n    )\n\n    # WITH OPERATIONS\n    energy_consumption_short_range_hydrogen = (\n        energy_per_ask_short_range_hydrogen * ask_short_range_hydrogen\n    )\n    energy_consumption_medium_range_hydrogen = (\n        energy_per_ask_medium_range_hydrogen * ask_medium_range_hydrogen\n    )\n    energy_consumption_long_range_hydrogen = (\n        energy_per_ask_long_range_hydrogen * ask_long_range_hydrogen\n    )\n    energy_consumption_passenger_hydrogen = (\n        energy_consumption_short_range_hydrogen\n        + energy_consumption_medium_range_hydrogen\n        + energy_consumption_long_range_hydrogen\n    )\n    energy_consumption_freight_hydrogen = energy_per_rtk_freight_hydrogen * rtk_hydrogen\n    energy_consumption_hydrogen = (\n        energy_consumption_passenger_hydrogen + energy_consumption_freight_hydrogen\n    )\n\n    self.df.loc[:, \"energy_consumption_short_range_hydrogen\"] = (\n        energy_consumption_short_range_hydrogen\n    )\n    self.df.loc[:, \"energy_consumption_medium_range_hydrogen\"] = (\n        energy_consumption_medium_range_hydrogen\n    )\n    self.df.loc[:, \"energy_consumption_long_range_hydrogen\"] = (\n        energy_consumption_long_range_hydrogen\n    )\n    self.df.loc[:, \"energy_consumption_passenger_hydrogen\"] = (\n        energy_consumption_passenger_hydrogen\n    )\n    self.df.loc[:, \"energy_consumption_freight_hydrogen\"] = energy_consumption_freight_hydrogen\n    self.df.loc[:, \"energy_consumption_hydrogen\"] = energy_consumption_hydrogen\n\n    return (\n        energy_consumption_short_range_hydrogen_without_operations,\n        energy_consumption_medium_range_hydrogen_without_operations,\n        energy_consumption_long_range_hydrogen_without_operations,\n        energy_consumption_passenger_hydrogen_without_operations,\n        energy_consumption_freight_hydrogen_without_operations,\n        energy_consumption_hydrogen_without_operations,\n        energy_consumption_short_range_hydrogen,\n        energy_consumption_medium_range_hydrogen,\n        energy_consumption_long_range_hydrogen,\n        energy_consumption_passenger_hydrogen,\n        energy_consumption_freight_hydrogen,\n        energy_consumption_hydrogen,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.energy_resources.energy_consumption/#aeromaps.models.impacts.energy_resources.energy_consumption.ElectricConsumption","title":"ElectricConsumption","text":"<pre><code>ElectricConsumption(name='electric_consumption', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to calculate electricity consumption for each type of market.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('electric_consumption' by default).</p> <code>'electric_consumption'</code> Source code in <code>aeromaps/models/impacts/energy_resources/energy_consumption.py</code> <pre><code>def __init__(self, name=\"electric_consumption\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.energy_resources.energy_consumption/#aeromaps.models.impacts.energy_resources.energy_consumption.ElectricConsumption.compute","title":"compute","text":"<pre><code>compute(ask_short_range_electric, ask_medium_range_electric, ask_long_range_electric, rtk_electric, energy_per_ask_without_operations_short_range_electric, energy_per_ask_without_operations_medium_range_electric, energy_per_ask_without_operations_long_range_electric, energy_per_rtk_without_operations_freight_electric, energy_per_ask_short_range_electric, energy_per_ask_medium_range_electric, energy_per_ask_long_range_electric, energy_per_rtk_freight_electric)\n</code></pre> <p>Electricity consumption calculation.</p> <p>Parameters:</p> Name Type Description Default <code>ask_short_range_electric</code> <code>Series</code> <p>Number of Available Seat Kilometer (ASK) for passenger short-range market from electric aircraft [ASK].</p> required <code>ask_medium_range_electric</code> <code>Series</code> <p>Number of Available Seat Kilometer (ASK) for passenger medium-range market from electric aircraft [ASK].</p> required <code>ask_long_range_electric</code> <code>Series</code> <p>Number of Available Seat Kilometer (ASK) for passenger long-range market from electric aircraft [ASK]</p> required <code>rtk_electric</code> <code>Series</code> <p>Number of Revenue Tonne Kilometer (RTK) for freight air transport from electric aircraft [RTK].</p> required <code>energy_per_ask_without_operations_short_range_electric</code> <code>Series</code> <p>Energy consumption per ASK for passenger short-range market aircraft using electricity without considering operation improvements [MJ/ASK].</p> required <code>energy_per_ask_without_operations_medium_range_electric</code> <code>Series</code> <p>Energy consumption per ASK for passenger medium-range market aircraft using electricity without considering operation improvements [MJ/ASK].</p> required <code>energy_per_ask_without_operations_long_range_electric</code> <code>Series</code> <p>Energy consumption per ASK for passenger long-range market aircraft using electricity without considering operation improvements [MJ/ASK].</p> required <code>energy_per_rtk_without_operations_freight_electric</code> <code>Series</code> <p>Energy consumption per RTK for freight aircraft using electricity without considering operation improvements [MJ/RTK].</p> required <code>energy_per_ask_short_range_electric</code> <code>Series</code> <p>Energy consumption per ASK for passenger short-range market aircraft using electricity [MJ/ASK].</p> required <code>energy_per_ask_medium_range_electric</code> <code>Series</code> <p>Energy consumption per ASK for passenger medium-range market aircraft using electricity [MJ/ASK].</p> required <code>energy_per_ask_long_range_electric</code> <code>Series</code> <p>Energy consumption per ASK for passenger long-range market aircraft using electricity [MJ/ASK].</p> required <code>energy_per_rtk_freight_electric</code> <code>Series</code> <p>Energy consumption per RTK for freight aircraft using electricity [MJ/RTK].</p> required <p>Returns:</p> Type Description <code>energy_consumption_short_range_electric_without_operations</code> <p>Energy consumption in the form of electricity without considering operation improvements from passenger short-range market air transport [MJ].</p> <code>energy_consumption_medium_range_electric_without_operations</code> <p>Energy consumption in the form of electricity without considering operation improvements from passenger medium-range market air transport [MJ].</p> <code>energy_consumption_long_range_electric_without_operations</code> <p>Energy consumption in the form of electricity without considering operation improvements from passenger long-range market air transport [MJ].</p> <code>energy_consumption_passenger_electric_without_operations</code> <p>Energy consumption in the form of electricity without considering operation improvements from total passenger air transport [MJ].</p> <code>energy_consumption_freight_electric_without_operations</code> <p>Energy consumption in the form of electricity without considering operation improvements from freight air transport [MJ].</p> <code>energy_consumption_electric_without_operations</code> <p>Energy consumption in the form of electricity without considering operation improvements from all commercial air transport [MJ].</p> <code>energy_consumption_short_range_electric</code> <p>Energy consumption in the form of electricity from passenger short-range market air transport [MJ].</p> <code>energy_consumption_medium_range_electric</code> <p>Energy consumption in the form of electricity from passenger medium-range market air transport [MJ].</p> <code>energy_consumption_long_range_electric</code> <p>Energy consumption in the form of electricity from passenger long-range market air transport [MJ].</p> <code>energy_consumption_passenger_electric</code> <p>Energy consumption in the form of electricity from total passenger air transport [MJ].</p> <code>energy_consumption_freight_electric</code> <p>Energy consumption in the form of electricity from freight air transport [MJ].</p> <code>energy_consumption_electric</code> <p>Energy consumption in the form of electricity from all commercial air transport [MJ].</p> Source code in <code>aeromaps/models/impacts/energy_resources/energy_consumption.py</code> <pre><code>def compute(\n    self,\n    ask_short_range_electric: pd.Series,\n    ask_medium_range_electric: pd.Series,\n    ask_long_range_electric: pd.Series,\n    rtk_electric: pd.Series,\n    energy_per_ask_without_operations_short_range_electric: pd.Series,\n    energy_per_ask_without_operations_medium_range_electric: pd.Series,\n    energy_per_ask_without_operations_long_range_electric: pd.Series,\n    energy_per_rtk_without_operations_freight_electric: pd.Series,\n    energy_per_ask_short_range_electric: pd.Series,\n    energy_per_ask_medium_range_electric: pd.Series,\n    energy_per_ask_long_range_electric: pd.Series,\n    energy_per_rtk_freight_electric: pd.Series,\n) -&gt; Tuple[\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n]:\n    \"\"\"\n    Electricity consumption calculation.\n\n    Parameters\n    ----------\n    ask_short_range_electric\n        Number of Available Seat Kilometer (ASK) for passenger short-range market from electric aircraft [ASK].\n    ask_medium_range_electric\n        Number of Available Seat Kilometer (ASK) for passenger medium-range market from electric aircraft [ASK].\n    ask_long_range_electric\n        Number of Available Seat Kilometer (ASK) for passenger long-range market from electric aircraft [ASK]\n    rtk_electric\n        Number of Revenue Tonne Kilometer (RTK) for freight air transport from electric aircraft [RTK].\n    energy_per_ask_without_operations_short_range_electric\n        Energy consumption per ASK for passenger short-range market aircraft using electricity without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_medium_range_electric\n        Energy consumption per ASK for passenger medium-range market aircraft using electricity without considering operation improvements [MJ/ASK].\n    energy_per_ask_without_operations_long_range_electric\n        Energy consumption per ASK for passenger long-range market aircraft using electricity without considering operation improvements [MJ/ASK].\n    energy_per_rtk_without_operations_freight_electric\n        Energy consumption per RTK for freight aircraft using electricity without considering operation improvements [MJ/RTK].\n    energy_per_ask_short_range_electric\n        Energy consumption per ASK for passenger short-range market aircraft using electricity [MJ/ASK].\n    energy_per_ask_medium_range_electric\n        Energy consumption per ASK for passenger medium-range market aircraft using electricity [MJ/ASK].\n    energy_per_ask_long_range_electric\n        Energy consumption per ASK for passenger long-range market aircraft using electricity [MJ/ASK].\n    energy_per_rtk_freight_electric\n        Energy consumption per RTK for freight aircraft using electricity [MJ/RTK].\n\n    Returns\n    -------\n    energy_consumption_short_range_electric_without_operations\n        Energy consumption in the form of electricity without considering operation improvements from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_electric_without_operations\n        Energy consumption in the form of electricity without considering operation improvements from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_electric_without_operations\n        Energy consumption in the form of electricity without considering operation improvements from passenger long-range market air transport [MJ].\n    energy_consumption_passenger_electric_without_operations\n        Energy consumption in the form of electricity without considering operation improvements from total passenger air transport [MJ].\n    energy_consumption_freight_electric_without_operations\n        Energy consumption in the form of electricity without considering operation improvements from freight air transport [MJ].\n    energy_consumption_electric_without_operations\n        Energy consumption in the form of electricity without considering operation improvements from all commercial air transport [MJ].\n    energy_consumption_short_range_electric\n        Energy consumption in the form of electricity from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_electric\n        Energy consumption in the form of electricity from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_electric\n        Energy consumption in the form of electricity from passenger long-range market air transport [MJ].\n    energy_consumption_passenger_electric\n        Energy consumption in the form of electricity from total passenger air transport [MJ].\n    energy_consumption_freight_electric\n        Energy consumption in the form of electricity from freight air transport [MJ].\n    energy_consumption_electric\n        Energy consumption in the form of electricity from all commercial air transport [MJ].\n    \"\"\"\n\n    # WITHOUT OPERATIONS\n    energy_consumption_short_range_electric_without_operations = (\n        energy_per_ask_without_operations_short_range_electric * ask_short_range_electric\n    )\n    energy_consumption_medium_range_electric_without_operations = (\n        energy_per_ask_without_operations_medium_range_electric * ask_medium_range_electric\n    )\n    energy_consumption_long_range_electric_without_operations = (\n        energy_per_ask_without_operations_long_range_electric * ask_long_range_electric\n    )\n    energy_consumption_passenger_electric_without_operations = (\n        energy_consumption_short_range_electric_without_operations\n        + energy_consumption_medium_range_electric_without_operations\n        + energy_consumption_long_range_electric_without_operations\n    )\n    energy_consumption_freight_electric_without_operations = (\n        energy_per_rtk_without_operations_freight_electric * rtk_electric\n    )\n    energy_consumption_electric_without_operations = (\n        energy_consumption_passenger_electric_without_operations\n        + energy_consumption_freight_electric_without_operations\n    )\n\n    self.df.loc[:, \"energy_consumption_short_range_electric_without_operations\"] = (\n        energy_consumption_short_range_electric_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_medium_range_electric_without_operations\"] = (\n        energy_consumption_medium_range_electric_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_long_range_electric_without_operations\"] = (\n        energy_consumption_long_range_electric_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_passenger_electric_without_operations\"] = (\n        energy_consumption_passenger_electric_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_freight_electric_without_operations\"] = (\n        energy_consumption_freight_electric_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_electric_without_operations\"] = (\n        energy_consumption_electric_without_operations\n    )\n\n    # WITH OPERATIONS\n    energy_consumption_short_range_electric = (\n        energy_per_ask_short_range_electric * ask_short_range_electric\n    )\n    energy_consumption_medium_range_electric = (\n        energy_per_ask_medium_range_electric * ask_medium_range_electric\n    )\n    energy_consumption_long_range_electric = (\n        energy_per_ask_long_range_electric * ask_long_range_electric\n    )\n    energy_consumption_passenger_electric = (\n        energy_consumption_short_range_electric\n        + energy_consumption_medium_range_electric\n        + energy_consumption_long_range_electric\n    )\n    energy_consumption_freight_electric = energy_per_rtk_freight_electric * rtk_electric\n    energy_consumption_electric = (\n        energy_consumption_passenger_electric + energy_consumption_freight_electric\n    )\n\n    self.df.loc[:, \"energy_consumption_short_range_electric\"] = (\n        energy_consumption_short_range_electric\n    )\n    self.df.loc[:, \"energy_consumption_medium_range_electric\"] = (\n        energy_consumption_medium_range_electric\n    )\n    self.df.loc[:, \"energy_consumption_long_range_electric\"] = (\n        energy_consumption_long_range_electric\n    )\n    self.df.loc[:, \"energy_consumption_passenger_electric\"] = (\n        energy_consumption_passenger_electric\n    )\n    self.df.loc[:, \"energy_consumption_freight_electric\"] = energy_consumption_freight_electric\n    self.df.loc[:, \"energy_consumption_electric\"] = energy_consumption_electric\n\n    return (\n        energy_consumption_short_range_electric_without_operations,\n        energy_consumption_medium_range_electric_without_operations,\n        energy_consumption_long_range_electric_without_operations,\n        energy_consumption_passenger_electric_without_operations,\n        energy_consumption_freight_electric_without_operations,\n        energy_consumption_electric_without_operations,\n        energy_consumption_short_range_electric,\n        energy_consumption_medium_range_electric,\n        energy_consumption_long_range_electric,\n        energy_consumption_passenger_electric,\n        energy_consumption_freight_electric,\n        energy_consumption_electric,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.energy_resources.energy_consumption/#aeromaps.models.impacts.energy_resources.energy_consumption.EnergyConsumption","title":"EnergyConsumption","text":"<pre><code>EnergyConsumption(name='energy_consumption', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Class to calculate total energy consumption for each type of market, aggregating all energy sources.</p> Source code in <code>aeromaps/models/impacts/energy_resources/energy_consumption.py</code> <pre><code>def __init__(self, name=\"energy_consumption\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.energy_resources.energy_consumption/#aeromaps.models.impacts.energy_resources.energy_consumption.EnergyConsumption.compute","title":"compute","text":"<pre><code>compute(energy_consumption_short_range_dropin_fuel_without_operations, energy_consumption_medium_range_dropin_fuel_without_operations, energy_consumption_long_range_dropin_fuel_without_operations, energy_consumption_passenger_dropin_fuel_without_operations, energy_consumption_freight_dropin_fuel_without_operations, energy_consumption_short_range_hydrogen_without_operations, energy_consumption_medium_range_hydrogen_without_operations, energy_consumption_long_range_hydrogen_without_operations, energy_consumption_passenger_hydrogen_without_operations, energy_consumption_freight_hydrogen_without_operations, energy_consumption_short_range_electric_without_operations, energy_consumption_medium_range_electric_without_operations, energy_consumption_long_range_electric_without_operations, energy_consumption_passenger_electric_without_operations, energy_consumption_freight_electric_without_operations, energy_consumption_dropin_fuel_without_operations, energy_consumption_hydrogen_without_operations, energy_consumption_electric_without_operations, energy_consumption_short_range_dropin_fuel, energy_consumption_medium_range_dropin_fuel, energy_consumption_long_range_dropin_fuel, energy_consumption_passenger_dropin_fuel, energy_consumption_freight_dropin_fuel, energy_consumption_short_range_hydrogen, energy_consumption_medium_range_hydrogen, energy_consumption_long_range_hydrogen, energy_consumption_passenger_hydrogen, energy_consumption_freight_hydrogen, energy_consumption_short_range_electric, energy_consumption_medium_range_electric, energy_consumption_long_range_electric, energy_consumption_passenger_electric, energy_consumption_freight_electric, energy_consumption_dropin_fuel, energy_consumption_hydrogen, energy_consumption_electric)\n</code></pre> <p>Energy consumption calculation.</p> <p>Parameters:</p> Name Type Description Default <code>energy_consumption_short_range_dropin_fuel_without_operations</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels without considering operation improvements from passenger short-range market air transport [MJ].</p> required <code>energy_consumption_medium_range_dropin_fuel_without_operations</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels without considering operation improvements from passenger medium-range market air transport [MJ].</p> required <code>energy_consumption_long_range_dropin_fuel_without_operations</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels without considering operation improvements from passenger long-range market air transport [MJ].</p> required <code>energy_consumption_passenger_dropin_fuel_without_operations</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels without considering operation improvements from total passenger air transport [MJ].</p> required <code>energy_consumption_freight_dropin_fuel_without_operations</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels without considering operation improvements from freight air transport [MJ].</p> required <code>energy_consumption_short_range_hydrogen_without_operations</code> <code>Series</code> <p>Energy consumption in the form of hydrogen without considering operation improvements from passenger short-range market air transport [MJ].</p> required <code>energy_consumption_medium_range_hydrogen_without_operations</code> <code>Series</code> <p>Energy consumption in the form of hydrogen without considering operation improvements from passenger medium-range market air transport [MJ].</p> required <code>energy_consumption_long_range_hydrogen_without_operations</code> <code>Series</code> <p>Energy consumption in the form of hydrogen without considering operation improvements from passenger long-range market air transport [MJ].</p> required <code>energy_consumption_passenger_hydrogen_without_operations</code> <code>Series</code> <p>Energy consumption in the form of hydrogen without considering operation improvements from total passenger air transport [MJ].</p> required <code>energy_consumption_freight_hydrogen_without_operations</code> <code>Series</code> <p>Energy consumption in the form of hydrogen without considering operation improvements from freight air transport [MJ].</p> required <code>energy_consumption_short_range_electric_without_operations</code> <code>Series</code> <p>Energy consumption in the form of electricity without considering operation improvements from passenger short-range market air transport [MJ].</p> required <code>energy_consumption_medium_range_electric_without_operations</code> <code>Series</code> <p>Energy consumption in the form of electricity without considering operation improvements from passenger medium-range market air transport [MJ].</p> required <code>energy_consumption_long_range_electric_without_operations</code> <code>Series</code> <p>Energy consumption in the form of electricity without considering operation improvements from passenger long-range market air transport [MJ].</p> required <code>energy_consumption_passenger_electric_without_operations</code> <code>Series</code> <p>Energy consumption in the form of electricity without considering operation improvements from total passenger air transport [MJ].</p> required <code>energy_consumption_freight_electric_without_operations</code> <code>Series</code> <p>Energy consumption in the form of electricity without considering operation improvements from freight air transport [MJ].</p> required <code>energy_consumption_dropin_fuel_without_operations</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels without considering operation improvements from all commercial air transport [MJ].</p> required <code>energy_consumption_hydrogen_without_operations</code> <code>Series</code> <p>Energy consumption in the form of hydrogen without considering operation improvements from all commercial air transport [MJ].</p> required <code>energy_consumption_electric_without_operations</code> <code>Series</code> <p>Energy consumption in the form of electricity without considering operation improvements from all commercial air transport [MJ].</p> required <code>energy_consumption_short_range_dropin_fuel</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels from passenger short-range market air transport [MJ].</p> required <code>energy_consumption_medium_range_dropin_fuel</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels from passenger medium-range market air transport [MJ].</p> required <code>energy_consumption_long_range_dropin_fuel</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels from passenger long-range market air transport [MJ].</p> required <code>energy_consumption_passenger_dropin_fuel</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels from total passenger air transport [MJ].</p> required <code>energy_consumption_freight_dropin_fuel</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels from freight air transport [MJ].</p> required <code>energy_consumption_short_range_hydrogen</code> <code>Series</code> <p>Energy consumption in the form of hydrogen from passenger short-range market air transport [MJ].</p> required <code>energy_consumption_medium_range_hydrogen</code> <code>Series</code> <p>Energy consumption in the form of hydrogen from passenger medium-range market air transport [MJ].</p> required <code>energy_consumption_long_range_hydrogen</code> <code>Series</code> <p>Energy consumption in the form of hydrogen from passenger long-range market air transport [MJ].</p> required <code>energy_consumption_passenger_hydrogen</code> <code>Series</code> <p>Energy consumption in the form of hydrogen from total passenger air transport [MJ].</p> required <code>energy_consumption_freight_hydrogen</code> <code>Series</code> <p>Energy consumption in the form of hydrogen from freight air transport [MJ].</p> required <code>energy_consumption_short_range_electric</code> <code>Series</code> <p>Energy consumption in the form of electricity from passenger short-range market air transport [MJ].</p> required <code>energy_consumption_medium_range_electric</code> <code>Series</code> <p>Energy consumption in the form of electricity from passenger medium-range market air transport [MJ].</p> required <code>energy_consumption_long_range_electric</code> <code>Series</code> <p>Energy consumption in the form of electricity from passenger long-range market air transport [MJ].</p> required <code>energy_consumption_passenger_electric</code> <code>Series</code> <p>Energy consumption in the form of electricity from total passenger air transport [MJ].</p> required <code>energy_consumption_freight_electric</code> <code>Series</code> <p>Energy consumption in the form of electricity from freight air transport [MJ].</p> required <code>energy_consumption_dropin_fuel</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels from all commercial air transport [MJ].</p> required <code>energy_consumption_hydrogen</code> <code>Series</code> <p>Energy consumption in the form of hydrogen from all commercial air transport [MJ].</p> required <code>energy_consumption_electric</code> <code>Series</code> <p>Energy consumption in the form of electricity from all commercial air transport [MJ].</p> required <p>Returns:</p> Type Description <code>energy_consumption_short_range_without_operations</code> <p>Energy consumption including all fuels without considering operation improvements from passenger short-range market air transport [MJ].</p> <code>energy_consumption_medium_range_without_operations</code> <p>Energy consumption including all fuels without considering operation improvements from passenger medium-range market air transport [MJ].</p> <code>energy_consumption_long_range_without_operations</code> <p>Energy consumption including all fuels without considering operation improvements from passenger long-range market air transport [MJ</p> <code>energy_consumption_passenger_without_operations</code> <p>Energy consumption including all fuels without considering operation improvements from total passenger air transport [MJ].</p> <code>energy_consumption_freight_without_operations</code> <p>Energy consumption including all fuels without considering operation improvements from freight air transport [MJ].</p> <code>energy_consumption_without_operations</code> <p>Energy consumption including all fuels without considering operation improvements from all commercial air transport [MJ].</p> <code>energy_consumption_short_range</code> <p>Energy consumption including all fuels from passenger short-range market air transport [MJ].</p> <code>energy_consumption_medium_range</code> <p>Energy consumption including all fuels from passenger medium-range market air transport [MJ].</p> <code>energy_consumption_long_range</code> <p>Energy consumption including all fuels from passenger long-range market air transport [MJ].</p> <code>energy_consumption_passenger</code> <p>Energy consumption including all fuels from total passenger air transport [MJ].</p> <code>energy_consumption_freight</code> <p>Energy consumption including all fuels from freight air transport [MJ].</p> <code>energy_consumption</code> <p>Energy consumption including all fuels from all commercial air transport [MJ].</p> Source code in <code>aeromaps/models/impacts/energy_resources/energy_consumption.py</code> <pre><code>def compute(\n    self,\n    energy_consumption_short_range_dropin_fuel_without_operations: pd.Series,\n    energy_consumption_medium_range_dropin_fuel_without_operations: pd.Series,\n    energy_consumption_long_range_dropin_fuel_without_operations: pd.Series,\n    energy_consumption_passenger_dropin_fuel_without_operations: pd.Series,\n    energy_consumption_freight_dropin_fuel_without_operations: pd.Series,\n    energy_consumption_short_range_hydrogen_without_operations: pd.Series,\n    energy_consumption_medium_range_hydrogen_without_operations: pd.Series,\n    energy_consumption_long_range_hydrogen_without_operations: pd.Series,\n    energy_consumption_passenger_hydrogen_without_operations: pd.Series,\n    energy_consumption_freight_hydrogen_without_operations: pd.Series,\n    energy_consumption_short_range_electric_without_operations: pd.Series,\n    energy_consumption_medium_range_electric_without_operations: pd.Series,\n    energy_consumption_long_range_electric_without_operations: pd.Series,\n    energy_consumption_passenger_electric_without_operations: pd.Series,\n    energy_consumption_freight_electric_without_operations: pd.Series,\n    energy_consumption_dropin_fuel_without_operations: pd.Series,\n    energy_consumption_hydrogen_without_operations: pd.Series,\n    energy_consumption_electric_without_operations: pd.Series,\n    energy_consumption_short_range_dropin_fuel: pd.Series,\n    energy_consumption_medium_range_dropin_fuel: pd.Series,\n    energy_consumption_long_range_dropin_fuel: pd.Series,\n    energy_consumption_passenger_dropin_fuel: pd.Series,\n    energy_consumption_freight_dropin_fuel: pd.Series,\n    energy_consumption_short_range_hydrogen: pd.Series,\n    energy_consumption_medium_range_hydrogen: pd.Series,\n    energy_consumption_long_range_hydrogen: pd.Series,\n    energy_consumption_passenger_hydrogen: pd.Series,\n    energy_consumption_freight_hydrogen: pd.Series,\n    energy_consumption_short_range_electric: pd.Series,\n    energy_consumption_medium_range_electric: pd.Series,\n    energy_consumption_long_range_electric: pd.Series,\n    energy_consumption_passenger_electric: pd.Series,\n    energy_consumption_freight_electric: pd.Series,\n    energy_consumption_dropin_fuel: pd.Series,\n    energy_consumption_hydrogen: pd.Series,\n    energy_consumption_electric: pd.Series,\n) -&gt; Tuple[\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n    pd.Series,\n]:\n    \"\"\"\n    Energy consumption calculation.\n\n    Parameters\n    ----------\n    energy_consumption_short_range_dropin_fuel_without_operations\n        Energy consumption in the form of drop-in fuels without considering operation improvements from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_dropin_fuel_without_operations\n        Energy consumption in the form of drop-in fuels without considering operation improvements from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_dropin_fuel_without_operations\n        Energy consumption in the form of drop-in fuels without considering operation improvements from passenger long-range market air transport [MJ].\n    energy_consumption_passenger_dropin_fuel_without_operations\n        Energy consumption in the form of drop-in fuels without considering operation improvements from total passenger air transport [MJ].\n    energy_consumption_freight_dropin_fuel_without_operations\n        Energy consumption in the form of drop-in fuels without considering operation improvements from freight air transport [MJ].\n    energy_consumption_short_range_hydrogen_without_operations\n        Energy consumption in the form of hydrogen without considering operation improvements from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_hydrogen_without_operations\n        Energy consumption in the form of hydrogen without considering operation improvements from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_hydrogen_without_operations\n        Energy consumption in the form of hydrogen without considering operation improvements from passenger long-range market air transport [MJ].\n    energy_consumption_passenger_hydrogen_without_operations\n        Energy consumption in the form of hydrogen without considering operation improvements from total passenger air transport [MJ].\n    energy_consumption_freight_hydrogen_without_operations\n        Energy consumption in the form of hydrogen without considering operation improvements from freight air transport [MJ].\n    energy_consumption_short_range_electric_without_operations\n        Energy consumption in the form of electricity without considering operation improvements from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_electric_without_operations\n        Energy consumption in the form of electricity without considering operation improvements from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_electric_without_operations\n        Energy consumption in the form of electricity without considering operation improvements from passenger long-range market air transport [MJ].\n    energy_consumption_passenger_electric_without_operations\n        Energy consumption in the form of electricity without considering operation improvements from total passenger air transport [MJ].\n    energy_consumption_freight_electric_without_operations\n        Energy consumption in the form of electricity without considering operation improvements from freight air transport [MJ].\n    energy_consumption_dropin_fuel_without_operations\n        Energy consumption in the form of drop-in fuels without considering operation improvements from all commercial air transport [MJ].\n    energy_consumption_hydrogen_without_operations\n        Energy consumption in the form of hydrogen without considering operation improvements from all commercial air transport [MJ].\n    energy_consumption_electric_without_operations\n        Energy consumption in the form of electricity without considering operation improvements from all commercial air transport [MJ].\n    energy_consumption_short_range_dropin_fuel\n        Energy consumption in the form of drop-in fuels from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_dropin_fuel\n        Energy consumption in the form of drop-in fuels from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_dropin_fuel\n        Energy consumption in the form of drop-in fuels from passenger long-range market air transport [MJ].\n    energy_consumption_passenger_dropin_fuel\n        Energy consumption in the form of drop-in fuels from total passenger air transport [MJ].\n    energy_consumption_freight_dropin_fuel\n        Energy consumption in the form of drop-in fuels from freight air transport [MJ].\n    energy_consumption_short_range_hydrogen\n        Energy consumption in the form of hydrogen from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_hydrogen\n        Energy consumption in the form of hydrogen from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_hydrogen\n        Energy consumption in the form of hydrogen from passenger long-range market air transport [MJ].\n    energy_consumption_passenger_hydrogen\n        Energy consumption in the form of hydrogen from total passenger air transport [MJ].\n    energy_consumption_freight_hydrogen\n        Energy consumption in the form of hydrogen from freight air transport [MJ].\n    energy_consumption_short_range_electric\n        Energy consumption in the form of electricity from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_electric\n        Energy consumption in the form of electricity from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_electric\n        Energy consumption in the form of electricity from passenger long-range market air transport [MJ].\n    energy_consumption_passenger_electric\n        Energy consumption in the form of electricity from total passenger air transport [MJ].\n    energy_consumption_freight_electric\n        Energy consumption in the form of electricity from freight air transport [MJ].\n    energy_consumption_dropin_fuel\n        Energy consumption in the form of drop-in fuels from all commercial air transport [MJ].\n    energy_consumption_hydrogen\n        Energy consumption in the form of hydrogen from all commercial air transport [MJ].\n    energy_consumption_electric\n        Energy consumption in the form of electricity from all commercial air transport [MJ].\n\n    Returns\n    -------\n    energy_consumption_short_range_without_operations\n        Energy consumption including all fuels without considering operation improvements from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range_without_operations\n        Energy consumption including all fuels without considering operation improvements from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range_without_operations\n        Energy consumption including all fuels without considering operation improvements from passenger long-range market air transport [MJ\n    energy_consumption_passenger_without_operations\n        Energy consumption including all fuels without considering operation improvements from total passenger air transport [MJ].\n    energy_consumption_freight_without_operations\n        Energy consumption including all fuels without considering operation improvements from freight air transport [MJ].\n    energy_consumption_without_operations\n        Energy consumption including all fuels without considering operation improvements from all commercial air transport [MJ].\n    energy_consumption_short_range\n        Energy consumption including all fuels from passenger short-range market air transport [MJ].\n    energy_consumption_medium_range\n        Energy consumption including all fuels from passenger medium-range market air transport [MJ].\n    energy_consumption_long_range\n        Energy consumption including all fuels from passenger long-range market air transport [MJ].\n    energy_consumption_passenger\n        Energy consumption including all fuels from total passenger air transport [MJ].\n    energy_consumption_freight\n        Energy consumption including all fuels from freight air transport [MJ].\n    energy_consumption\n        Energy consumption including all fuels from all commercial air transport [MJ].\n    \"\"\"\n\n    # WITHOUT OPERATIONS\n    energy_consumption_short_range_without_operations = (\n        +energy_consumption_short_range_dropin_fuel_without_operations\n        + energy_consumption_short_range_hydrogen_without_operations\n        + energy_consumption_short_range_electric_without_operations\n    )\n    energy_consumption_medium_range_without_operations = (\n        +energy_consumption_medium_range_dropin_fuel_without_operations\n        + energy_consumption_medium_range_hydrogen_without_operations\n        + energy_consumption_medium_range_electric_without_operations\n    )\n    energy_consumption_long_range_without_operations = (\n        +energy_consumption_long_range_dropin_fuel_without_operations\n        + energy_consumption_long_range_hydrogen_without_operations\n        + energy_consumption_long_range_electric_without_operations\n    )\n    energy_consumption_passenger_without_operations = (\n        +energy_consumption_passenger_dropin_fuel_without_operations\n        + energy_consumption_passenger_hydrogen_without_operations\n        + energy_consumption_passenger_electric_without_operations\n    )\n    energy_consumption_freight_without_operations = (\n        +energy_consumption_freight_dropin_fuel_without_operations\n        + energy_consumption_freight_hydrogen_without_operations\n        + energy_consumption_freight_electric_without_operations\n    )\n    energy_consumption_without_operations = (\n        +energy_consumption_dropin_fuel_without_operations\n        + energy_consumption_hydrogen_without_operations\n        + energy_consumption_electric_without_operations\n    )\n\n    self.df.loc[:, \"energy_consumption_short_range_without_operations\"] = (\n        energy_consumption_short_range_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_medium_range_without_operations\"] = (\n        energy_consumption_medium_range_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_long_range_without_operations\"] = (\n        energy_consumption_long_range_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_passenger_without_operations\"] = (\n        energy_consumption_passenger_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_freight_without_operations\"] = (\n        energy_consumption_freight_without_operations\n    )\n    self.df.loc[:, \"energy_consumption_without_operations\"] = (\n        energy_consumption_without_operations\n    )\n\n    # WITH OPERATIONS\n    energy_consumption_short_range = (\n        +energy_consumption_short_range_dropin_fuel\n        + energy_consumption_short_range_hydrogen\n        + energy_consumption_short_range_electric\n    )\n    energy_consumption_medium_range = (\n        +energy_consumption_medium_range_dropin_fuel\n        + energy_consumption_medium_range_hydrogen\n        + energy_consumption_medium_range_electric\n    )\n    energy_consumption_long_range = (\n        +energy_consumption_long_range_dropin_fuel\n        + energy_consumption_long_range_hydrogen\n        + energy_consumption_long_range_electric\n    )\n    energy_consumption_passenger = (\n        +energy_consumption_passenger_dropin_fuel\n        + energy_consumption_passenger_hydrogen\n        + energy_consumption_passenger_electric\n    )\n    energy_consumption_freight = (\n        +energy_consumption_freight_dropin_fuel\n        + energy_consumption_freight_hydrogen\n        + energy_consumption_freight_electric\n    )\n    energy_consumption = (\n        +energy_consumption_dropin_fuel\n        + energy_consumption_hydrogen\n        + energy_consumption_electric\n    )\n\n    self.df.loc[:, \"energy_consumption_short_range\"] = energy_consumption_short_range\n    self.df.loc[:, \"energy_consumption_medium_range\"] = energy_consumption_medium_range\n    self.df.loc[:, \"energy_consumption_long_range\"] = energy_consumption_long_range\n    self.df.loc[:, \"energy_consumption_passenger\"] = energy_consumption_passenger\n    self.df.loc[:, \"energy_consumption_freight\"] = energy_consumption_freight\n    self.df.loc[:, \"energy_consumption\"] = energy_consumption\n\n    return (\n        energy_consumption_short_range_without_operations,\n        energy_consumption_medium_range_without_operations,\n        energy_consumption_long_range_without_operations,\n        energy_consumption_passenger_without_operations,\n        energy_consumption_freight_without_operations,\n        energy_consumption_without_operations,\n        energy_consumption_short_range,\n        energy_consumption_medium_range,\n        energy_consumption_long_range,\n        energy_consumption_passenger,\n        energy_consumption_freight,\n        energy_consumption,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.energy_resources.energy_resources/","title":"<code>aeromaps.models.impacts.energy_resources.energy_resources</code>","text":""},{"location":"full_doc/aeromaps.models.impacts.energy_resources.energy_resources/#aeromaps.models.impacts.energy_resources.energy_resources--energy_resources","title":"energy_resources","text":"<p>Module to model energy resources consumption.</p>"},{"location":"full_doc/aeromaps.models.impacts.energy_resources.energy_resources/#aeromaps.models.impacts.energy_resources.energy_resources.EnergyResourceConsumption","title":"EnergyResourceConsumption","text":"<pre><code>EnergyResourceConsumption(name, configuration_data, pathways_manager, *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>This class aggregates all pathways consumption for a given resource. Then, it compares it to availability and allocations. A class is instantiated for each resource defined in the resources .yaml file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('f\"{generic_resource}_consumption\"' by default).</p> required <code>configuration_data</code> <code>dict</code> <p>Configuration data dictionary for the resource from the resources .yaml file.</p> required <code>pathways_manager</code> <code>EnergyCarrierManager</code> <p>EnergyCarrierManager instance to manage generic energy pathways and their data.</p> required <p>Attributes:</p> Name Type Description <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Warnings <ul> <li>Detailed i/o documentation is not yet provided for models defined wityh generic .yaml files?</li> </ul> Source code in <code>aeromaps/models/impacts/energy_resources/energy_resources.py</code> <pre><code>def __init__(\n    self,\n    name,\n    configuration_data,\n    pathways_manager: EnergyCarrierManager,\n    *args,\n    **kwargs,\n):\n    super().__init__(\n        name=name,\n        model_type=\"custom\",\n        # inputs/outputs are defined in __init__ rather than auto generated from compute() signature\n        *args,\n        **kwargs,\n    )\n    self.pathways_manager = pathways_manager\n    # Get the name of the resource\n    self.resource_name = configuration_data[\"name\"]\n\n    self.input_names = {}\n    self.output_names = {}\n\n    if f\"{self.resource_name}_availability_global\" in configuration_data[\"specifications\"]:\n        self.input_names[f\"{self.resource_name}_availability_global\"] = configuration_data[\n            \"specifications\"\n        ][f\"{self.resource_name}_availability_global\"]\n        self.output_names.update(\n            {\n                f\"{self.resource_name}_consumed_global_share\": pd.Series([0.0]),\n                f\"{self.resource_name}_necessary_global_share_with_selectivity\": pd.Series(\n                    [0.0]\n                ),\n            }\n        )\n    if (\n        f\"{self.resource_name}_availability_aviation_allocated_share\"\n        in configuration_data[\"specifications\"]\n    ):\n        self.input_names[f\"{self.resource_name}_availability_aviation_allocated_share\"] = (\n            configuration_data[\n                \"specifications\"\n            ][f\"{self.resource_name}_availability_aviation_allocated_share\"]\n        )\n        self.output_names.update(\n            {\n                f\"{self.resource_name}_consumed_aviation_allocated_share\": pd.Series([0.0]),\n            }\n        )\n\n    for pathway in self.pathways_manager.get(\n        resources_used=self.resource_name\n    ) + self.pathways_manager.get(resources_used_processes=self.resource_name):\n        self.input_names.update(\n            {\n                f\"{pathway.name}_{self.resource_name}_total_consumption\": pd.Series([0.0]),\n                f\"{pathway.name}_{self.resource_name}_total_mobilised_with_selectivity\": pd.Series(\n                    [0.0]\n                ),\n            }\n        )\n\n    self.output_names.update(\n        {\n            f\"{self.resource_name}_total_consumption\": pd.Series([0.0]),\n            f\"{self.resource_name}_total_necessary_with_selectivity\": pd.Series([0.0]),\n        }\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.energy_resources.energy_resources/#aeromaps.models.impacts.energy_resources.energy_resources.EnergyResourceConsumption.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Executes the computation of total resource consumption and comparison to availability and allocations.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/energy_resources/energy_resources.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"\n    Executes the computation of total resource consumption and comparison to availability and allocations.\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n\n    \"\"\"\n    output_data = {}\n\n    total_resource_consumption = pd.Series(\n        0.0, index=range(self.prospection_start_year, self.end_year + 1)\n    )\n    total_resource_mobilised_with_selectivity = pd.Series(\n        0.0, index=range(self.prospection_start_year, self.end_year + 1)\n    )\n\n    for pathway in self.pathways_manager.get(\n        resources_used=self.resource_name\n    ) + self.pathways_manager.get(resources_used_processes=self.resource_name):\n        total_resource_consumption = _custom_series_addition(\n            total_resource_consumption,\n            input_data[f\"{pathway.name}_{self.resource_name}_total_consumption\"],\n        )\n        total_resource_mobilised_with_selectivity = _custom_series_addition(\n            total_resource_mobilised_with_selectivity,\n            input_data[f\"{pathway.name}_{self.resource_name}_total_mobilised_with_selectivity\"],\n        )\n\n    output_data[f\"{self.resource_name}_total_consumption\"] = total_resource_consumption\n    output_data[f\"{self.resource_name}_total_necessary_with_selectivity\"] = (\n        total_resource_mobilised_with_selectivity\n    )\n\n    if f\"{self.resource_name}_availability_global\" in input_data:\n        output_data[f\"{self.resource_name}_consumed_global_share\"] = (\n            total_resource_consumption\n            / input_data[f\"{self.resource_name}_availability_global\"]\n            * 100\n        )\n        output_data[f\"{self.resource_name}_necessary_global_share_with_selectivity\"] = (\n            total_resource_mobilised_with_selectivity\n            / input_data[f\"{self.resource_name}_availability_global\"]\n            * 100\n        )\n\n    if f\"{self.resource_name}_availability_aviation_allocated_share\" in input_data:\n        output_data[f\"{self.resource_name}_consumed_aviation_allocated_share\"] = (\n            total_resource_consumption\n            / (\n                input_data[f\"{self.resource_name}_availability_global\"]\n                * input_data[f\"{self.resource_name}_availability_aviation_allocated_share\"]\n                / 100\n            )\n            * 100\n        )\n\n    self._store_outputs(output_data)\n\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.energy_resources.energy_resources/#aeromaps.models.impacts.energy_resources.energy_resources.OverallResourcesConsumption","title":"OverallResourcesConsumption","text":"<pre><code>OverallResourcesConsumption(name, resources_data, *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Aggregates total consumption and shares for all resources according to their origin and using outputs from EnergyResourceConsumption. Only one instance of this class is created for all resources.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('overall_resources_consumption' by default).</p> required <code>resources_data</code> <code>dict</code> <p>Dictionary containing configuration data for all resources from the resources .yaml file.</p> required <p>Attributes:</p> Name Type Description <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Warning <ul> <li>Detailed i/o documentation is not yet provided for models defined wityh generic .yaml files</li> </ul> Source code in <code>aeromaps/models/impacts/energy_resources/energy_resources.py</code> <pre><code>def __init__(\n    self,\n    name,\n    resources_data,\n    *args,\n    **kwargs,\n):\n    super().__init__(\n        name=name,\n        model_type=\"custom\",\n        *args,\n        **kwargs,\n    )\n\n    # keep only resources whose availability is defined\n    self.resources_names_origins = {\n        resource: resources_data[resource].get(\"origin\", \"unknown\")\n        for resource in resources_data.keys()\n        if f\"{resource}_availability_global\" in resources_data[resource][\"specifications\"]\n    }\n\n    # getting the unique origins of the resources\n    self.resources_origins = set(self.resources_names_origins.values())\n\n    self.resources_names = list(self.resources_names_origins.keys())\n\n    # Dynamically build input/output names for all resources\n    self.input_names = {}\n    self.output_names = {}\n    for resource in self.resources_names:\n        self.input_names[f\"{resource}_total_consumption\"] = pd.Series([0.0])\n        self.input_names[f\"{resource}_total_necessary_with_selectivity\"] = pd.Series([0.0])\n        self.input_names[f\"{resource}_availability_global\"] = resources_data[resource][\n            \"specifications\"\n        ][f\"{resource}_availability_global\"]\n        # Todo make this conditional\n        self.input_names[f\"{resource}_availability_aviation_allocated_share\"] = resources_data[\n            resource\n        ][\"specifications\"][f\"{resource}_availability_aviation_allocated_share\"]\n\n    for origin in self.resources_origins:\n        self.output_names[f\"{origin}_total_consumption\"] = pd.Series([0.0])\n        self.output_names[f\"{origin}_total_necessary_with_selectivity\"] = pd.Series([0.0])\n        self.output_names[f\"{origin}_availability_global\"] = pd.Series([0.0])\n        self.output_names[f\"{origin}_availability_aviation_allocated\"] = pd.Series([0.0])\n        self.output_names[f\"{origin}_consumed_global_share\"] = pd.Series([0.0])\n        self.output_names[f\"{origin}_consumed_aviation_allocated_share\"] = pd.Series([0.0])\n        self.output_names[f\"{origin}_necessary_global_share_with_selectivity\"] = pd.Series(\n            [0.0]\n        )\n        self.output_names[f\"{origin}_overall_aviation_allocated_share\"] = pd.Series([0.0])\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.energy_resources.energy_resources/#aeromaps.models.impacts.energy_resources.energy_resources.OverallResourcesConsumption.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Executes the computation of overall resource consumption for all origins and comparison to availability and allocations.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/energy_resources/energy_resources.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"\n    Executes the computation of overall resource consumption for all origins and comparison to availability and allocations.\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n\n    \"\"\"\n    output_data = {}\n\n    index = range(self.prospection_start_year, self.end_year + 1)\n\n    # Prepare aggregation by origin\n    origin_consumption = {\n        origin: pd.Series(0.0, index=index) for origin in self.resources_origins\n    }\n    origin_necessary = {\n        origin: pd.Series(0.0, index=index) for origin in self.resources_origins\n    }\n    origin_availability = {\n        origin: pd.Series(0.0, index=index) for origin in self.resources_origins\n    }\n    origin_availability_aviation_allocated = {\n        origin: pd.Series(0.0, index=index) for origin in self.resources_origins\n    }\n\n    # Aggregate by origin\n    for resource in self.resources_names:\n        origin = self.resources_names_origins.get(resource, None)\n        if origin is None:\n            print(\n                f\"Warning: No origin found for resource:{resource}, aggregate shares not computed.\"\n            )\n            continue\n        else:\n            origin = origin\n\n        total_consumption = input_data[f\"{resource}_total_consumption\"]\n        total_necessary = input_data[f\"{resource}_total_necessary_with_selectivity\"]\n        availability = input_data[f\"{resource}_availability_global\"]\n        availability_aviation_allocated = (\n            input_data[f\"{resource}_availability_aviation_allocated_share\"] / 100 * availability\n        )\n\n        origin_consumption[origin] = _custom_series_addition(\n            origin_consumption[origin], total_consumption\n        )\n        origin_necessary[origin] = _custom_series_addition(\n            origin_necessary[origin], total_necessary\n        )\n        origin_availability[origin] += availability\n        origin_availability_aviation_allocated[origin] += availability_aviation_allocated\n\n    # Compute shares for each origin\n    for origin in self.resources_origins:\n        total_consumption = origin_consumption[origin]\n        total_necessary = origin_necessary[origin]\n        total_availability = origin_availability[origin]\n        total_availability_aviation_allocated = origin_availability_aviation_allocated[origin]\n\n        consumed_global_share = total_consumption / total_availability * 100\n        necessary_global_share_with_selectivity = total_necessary / total_availability * 100\n        # Aviation allocated share in percent\n        consumed_aviation_allocated_share = (\n            total_consumption / total_availability_aviation_allocated * 100\n        )\n        overall_aviation_allocated_share = (\n            total_availability_aviation_allocated / total_availability * 100\n        )\n\n        output_data[f\"{origin}_total_consumption\"] = total_consumption\n        output_data[f\"{origin}_total_necessary_with_selectivity\"] = total_necessary\n        output_data[f\"{origin}_consumed_global_share\"] = consumed_global_share\n        output_data[f\"{origin}_necessary_global_share_with_selectivity\"] = (\n            necessary_global_share_with_selectivity\n        )\n        output_data[f\"{origin}_overall_aviation_allocated_share\"] = (\n            overall_aviation_allocated_share\n        )\n        output_data[f\"{origin}_consumed_aviation_allocated_share\"] = (\n            consumed_aviation_allocated_share\n        )\n        output_data[f\"{origin}_availability_global\"] = total_availability\n        output_data[f\"{origin}_availability_aviation_allocated\"] = (\n            total_availability_aviation_allocated\n        )\n\n    self._store_outputs(output_data)\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.energy_resources/","title":"<code>aeromaps.models.impacts.energy_resources</code>","text":""},{"location":"full_doc/aeromaps.models.impacts.energy_resources/#aeromaps.models.impacts.energy_resources--energy_resources","title":"energy_resources","text":"<p>Package to model energy consumption from different aircraft types and energy resources consumed.</p>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.bottom_up.abatement_cost/","title":"<code>aeromaps.models.impacts.generic_energy_model.bottom_up.abatement_cost</code>","text":"<p>abatement_cost</p> <p>====================== Module to compute energy abatement costs for different pathways.</p>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.bottom_up.abatement_cost/#aeromaps.models.impacts.generic_energy_model.bottom_up.abatement_cost.EnergyAbatementCost","title":"EnergyAbatementCost","text":"<pre><code>EnergyAbatementCost(name, pathway_name, pathways_data, *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Computes specific abatement cost and generic specific abatement cost for a pathway, based on discounted costs and avoided emissions over the lifespan of each vintage.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('f\"{pathway_name}_bottom_up_abatement_cost\"' by default).</p> required <code>pathway_name</code> <code>str</code> <p>Name of the energy pathway for which the abatement cost is computed.</p> required <code>pathways_data</code> <code>dict</code> <p>Dictionary containing data for all pathways, used to complete inputs names necessary.</p> required <p>Attributes:</p> Name Type Description <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/bottom_up/abatement_cost.py</code> <pre><code>def __init__(self, name, pathway_name, pathways_data, *args, **kwargs):\n    super().__init__(\n        name=name,\n        model_type=\"custom\",\n        *args,\n        **kwargs,\n    )\n    self.pathway_name = pathway_name\n\n    # Inputs needed: discounted costs, unitary emissions, discounted emissions\n    self.input_names = {\n        f\"{self.pathway_name}_lifespan_unitary_discounted_costs\": pd.Series([0.0]),\n        f\"{self.pathway_name}_lifespan_unitary_emissions\": pd.Series([0.0]),\n        f\"{self.pathway_name}_lifespan_discounted_unitary_emissions\": pd.Series([0.0]),\n        f\"{self.pathway_name}_mean_mfsp\": pd.Series([0.0]),\n        f\"{self.pathway_name}_mean_co2_emission_factor\": pd.Series([0.0]),\n        \"cac_reference_unitary_discounted_costs\": pd.Series([0.0]),\n        \"cac_reference_unitary_discounted_emissions\": pd.Series([0.0]),\n        \"cac_reference_unitary_emissions\": pd.Series([0.0]),\n        \"cac_reference_co2_emission_factor\": pd.Series([0.0]),\n        \"cac_reference_mfsp\": pd.Series([0.0]),\n        \"social_discount_rate\": 0.0,\n        \"exogenous_carbon_price_trajectory\": pd.Series([0.0]),\n    }\n\n    if f\"{self.pathway_name}_eis_plant_lifespan\" in pathways_data:\n        self.input_names[f\"{self.pathway_name}_eis_plant_lifespan\"] = 0.0\n\n    # Outputs: specific abatement cost and generic specific abatement cost\n\n    self.output_names = {\n        f\"{self.pathway_name}_carbon_abatement_cost\": pd.Series([0.0]),\n        f\"{self.pathway_name}_specific_carbon_abatement_cost\": pd.Series([0.0]),\n        f\"{self.pathway_name}_generic_specific_carbon_abatement_cost\": pd.Series([0.0]),\n    }\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.bottom_up.abatement_cost/#aeromaps.models.impacts.generic_energy_model.bottom_up.abatement_cost.EnergyAbatementCost.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Compute the specific abatement cost and generic specific abatement cost for each vintage.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/bottom_up/abatement_cost.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"\n    Compute the specific abatement cost and generic specific abatement cost for each vintage.\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n    \"\"\"\n    unitary_discounted_costs = input_data.get(\n        f\"{self.pathway_name}_lifespan_unitary_discounted_costs\", pd.Series([0.0])\n    )\n    unitary_discounted_emissions = input_data.get(\n        f\"{self.pathway_name}_lifespan_discounted_unitary_emissions\", pd.Series([0.0])\n    )\n    unitary_emissions = input_data.get(\n        f\"{self.pathway_name}_lifespan_unitary_emissions\", pd.Series([0.0])\n    )\n    mfsp = input_data.get(f\"{self.pathway_name}_mean_mfsp\", pd.Series([0.0]))\n    co2_emission_factor = input_data.get(\n        f\"{self.pathway_name}_mean_co2_emission_factor\", pd.Series([0.0])\n    )\n    fossil_mfsp = input_data.get(\"cac_reference_mfsp\", pd.Series([0.0]))\n    fossil_ef = input_data.get(\"cac_reference_co2_emission_factor\", pd.Series([0.0]))\n\n    reference_unitary_discounted_costs = input_data.get(\n        \"cac_reference_unitary_discounted_costs\", pd.Series([0.0])\n    )\n    reference_unitary_discounted_emissions = input_data.get(\n        \"cac_reference_unitary_discounted_emissions\", pd.Series([0.0])\n    )\n    reference_unitary_emissions = input_data.get(\n        \"cac_reference_unitary_emissions\", pd.Series([0.0])\n    )\n\n    generic_specific_carbon_abatement_cost = (\n        unitary_discounted_costs - reference_unitary_discounted_costs\n    ) / (reference_unitary_discounted_emissions - unitary_discounted_emissions)\n    specific_carbon_abatement_cost = (\n        unitary_discounted_costs - reference_unitary_discounted_costs\n    ) / (reference_unitary_emissions - unitary_emissions)\n\n    carbon_abatement_cost = (mfsp - fossil_mfsp) / (fossil_ef - co2_emission_factor)\n\n    # Unit conversion = &gt; from \u20ac/gCO2 to \u20ac/tCO2\n    specific_carbon_abatement_cost *= 1000000\n    generic_specific_carbon_abatement_cost *= 1000000\n    carbon_abatement_cost *= 1000000\n\n    output_data = {\n        f\"{self.pathway_name}_specific_carbon_abatement_cost\": specific_carbon_abatement_cost,\n        f\"{self.pathway_name}_generic_specific_carbon_abatement_cost\": generic_specific_carbon_abatement_cost,\n        f\"{self.pathway_name}_carbon_abatement_cost\": carbon_abatement_cost,\n    }\n\n    self._store_outputs(output_data)\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.bottom_up.abatement_cost/#aeromaps.models.impacts.generic_energy_model.bottom_up.abatement_cost.ReferenceAbatementCost","title":"ReferenceAbatementCost","text":"<pre><code>ReferenceAbatementCost(name, pathway_name, configuration_data, *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Computes specific abatement cost and generic specific abatement cost for a reference pathway, based on discounted costs and avoided emissions over the lifespan of each vintage.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('f\"{pathway_name}_bottom_up_abatement_cost\"' by default).</p> required <code>pathway_name</code> <code>str</code> <p>Name of the energy pathway for which the abatement cost is computed.</p> required <code>pathways_data</code> <code>dict</code> <p>Dictionary containing data for all pathways, used to complete inputs names necessary.</p> required <p>Attributes:</p> Name Type Description <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/bottom_up/abatement_cost.py</code> <pre><code>def __init__(self, name, pathway_name, configuration_data, *args, **kwargs):\n    super().__init__(\n        name=name,\n        model_type=\"custom\",\n        *args,\n        **kwargs,\n    )\n    self.pathway_name = pathway_name\n\n    # Inputs needed: discounted costs, unitary emissions, discounted emissions\n    self.input_names = {\n        \"social_discount_rate\": 0.0,\n        \"exogenous_carbon_price_trajectory\": pd.Series([0.0]),\n    }\n\n    # 2 cases: either ref pathway is defined to-down, as before. Weak CAC definition, considering its average price and EF\n    # 1:\n    if (\n        configuration_data[\"cost_model\"] == \"bottom-up\"\n        and configuration_data[\"cost_model\"] == \"bottom-up\"\n    ):\n        self.input_names.update(\n            {\n                f\"{self.pathway_name}_lifespan_unitary_discounted_costs\": pd.Series([0.0]),\n                f\"{self.pathway_name}_lifespan_unitary_emissions\": pd.Series([0.0]),\n                f\"{self.pathway_name}_lifespan_discounted_unitary_emissions\": pd.Series([0.0]),\n                f\"{self.pathway_name}_mean_mfsp\": pd.Series([0.0]),\n                f\"{self.pathway_name}_mean_co2_emission_factor\": pd.Series([0.0]),\n            }\n        )\n        self.bottom_up_cac = True\n    else:\n        print(\n            f\"\u26a0\ufe0f Warning: reference pathway for CAC ({self.pathway_name} is not defined as bottom-up, \"\n            f\"using top-down values for CAC computation.\"\n        )\n        self.input_names.update(\n            {\n                f\"{self.pathway_name}_mean_mfsp\": pd.Series([0.0]),\n                f\"{self.pathway_name}_mean_co2_emission_factor\": pd.Series([0.0]),\n            }\n        )\n        self.bottom_up_cac = False\n\n    # Outputs: specific abatement cost and generic specific abatement cost\n\n    self.output_names = {\n        \"cac_reference_unitary_discounted_costs\": pd.Series([0.0]),\n        \"cac_reference_unitary_discounted_emissions\": pd.Series([0.0]),\n        \"cac_reference_unitary_emissions\": pd.Series([0.0]),\n        \"cac_reference_co2_emission_factor\": pd.Series([0.0]),\n        \"cac_reference_mfsp\": pd.Series([0.0]),\n    }\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.bottom_up.abatement_cost/#aeromaps.models.impacts.generic_energy_model.bottom_up.abatement_cost.ReferenceAbatementCost.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Compute the specific abatement cost and generic specific abatement cost for each vintage.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/bottom_up/abatement_cost.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"\n    Compute the specific abatement cost and generic specific abatement cost for each vintage.\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n    \"\"\"\n\n    ref_mfsp = input_data.get(f\"{self.pathway_name}_mean_mfsp\", pd.Series([0.0]))\n    ref_ef = input_data.get(f\"{self.pathway_name}_mean_co2_emission_factor\", pd.Series([0.0]))\n\n    if self.bottom_up_cac:\n        reference_unitary_discounted_costs = input_data.get(\n            f\"{self.pathway_name}_lifespan_unitary_discounted_costs\", pd.Series([0.0])\n        )\n        reference_unitary_discounted_emissions = input_data.get(\n            f\"{self.pathway_name}_lifespan_discounted_unitary_emissions\", pd.Series([0.0])\n        )\n        reference_unitary_emissions = input_data.get(\n            f\"{self.pathway_name}_lifespan_unitary_emissions\", pd.Series([0.0])\n        )\n\n    else:\n        reference_lifespan = input_data.get(f\"{self.pathway_name}_eis_plant_lifespan\", 25.0)\n        social_discount_rate = input_data.get(\"social_discount_rate\")\n        exogenous_carbon_price_trajectory = input_data.get(\n            \"exogenous_carbon_price_trajectory\", pd.Series([0.0])\n        )\n\n        reference_unitary_discounted_costs = self._unit_discounted_cumul_costs(\n            ref_mfsp, reference_lifespan, social_discount_rate\n        )\n        (reference_unitary_emissions, reference_unitary_discounted_emissions) = (\n            self._unitary_cumul_emissions_vintage(\n                ref_ef,\n                exogenous_carbon_price_trajectory,\n                reference_lifespan,\n                social_discount_rate,\n            )\n        )\n\n    output_data = {\n        \"cac_reference_unitary_discounted_costs\": reference_unitary_discounted_costs,\n        \"cac_reference_unitary_discounted_emissions\": reference_unitary_discounted_emissions,\n        \"cac_reference_unitary_emissions\": reference_unitary_emissions,\n        \"cac_reference_co2_emission_factor\": ref_ef,\n        \"cac_reference_mfsp\": ref_mfsp,\n    }\n\n    self._store_outputs(output_data)\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.bottom_up.abatement_effective/","title":"<code>aeromaps.models.impacts.generic_energy_model.bottom_up.abatement_effective</code>","text":"<p>Module to compute effective carbon abatement for each energy pathway.</p>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.bottom_up.abatement_effective/#aeromaps.models.impacts.generic_energy_model.bottom_up.abatement_effective.EnergyAbatementEffective","title":"EnergyAbatementEffective","text":"<pre><code>EnergyAbatementEffective(name, pathway_name, *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>This class computes the effective carbon abatement (i.e CO2 \"avoided\" by an option) for a given pathway.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('f\"{pathway_name}_abatement_effective\"' by default).</p> required <code>pathway_name</code> <code>str</code> <p>Name of the energy pathway for which to compute the effective abatement.</p> required <p>Attributes:</p> Name Type Description <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/bottom_up/abatement_effective.py</code> <pre><code>def __init__(self, name, pathway_name, *args, **kwargs):\n    super().__init__(\n        name=name,\n        model_type=\"custom\",\n        *args,\n        **kwargs,\n    )\n    self.pathway_name = pathway_name\n\n    # Inputs needed: discounted costs, unitary emissions, discounted emissions\n    self.input_names = {\n        f\"{self.pathway_name}_energy_consumption\": pd.Series([0.0]),\n        f\"{self.pathway_name}_mean_co2_emission_factor\": pd.Series([0.0]),\n        \"cac_reference_co2_emission_factor\": pd.Series([0.0]),\n    }\n\n    # Outputs: effective abatement volume (unit: tCO2)\n    self.output_names = {\n        f\"{self.pathway_name}_abatement_effective\": pd.Series([0.0]),\n    }\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.bottom_up.abatement_effective/#aeromaps.models.impacts.generic_energy_model.bottom_up.abatement_effective.EnergyAbatementEffective.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Compute the abatement effective due to the pathway.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/bottom_up/abatement_effective.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"\n    Compute the abatement effective due to the pathway.\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n    \"\"\"\n    avoided_emission_factor = (\n        input_data[\"cac_reference_co2_emission_factor\"]\n        - input_data[f\"{self.pathway_name}_mean_co2_emission_factor\"]\n    )\n    abatement_effective = (\n        input_data[f\"{self.pathway_name}_energy_consumption\"]\n        * avoided_emission_factor\n        / 1000000\n    )  # Convert to tCO2\n    output_data = {f\"{self.pathway_name}_abatement_effective\": abatement_effective}\n\n    self._store_outputs(output_data)\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.bottom_up.cost/","title":"<code>aeromaps.models.impacts.generic_energy_model.bottom_up.cost</code>","text":"<p>cost</p> <p>====== Module to compute pathway mfsp and investments using the bottom-up techno-economic model.</p>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.bottom_up.cost/#aeromaps.models.impacts.generic_energy_model.bottom_up.cost.BottomUpCost","title":"BottomUpCost","text":"<pre><code>BottomUpCost(name, configuration_data, resources_data, processes_data, *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Bottom-up techno-economic cost model for a given pathway, based on annual plant additions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('f\"{pathway_name}_bottom_up_unit_cost\"' by default).</p> required <code>configuration_data</code> <code>dict</code> <p>Configuration data for the pathway from the yaml file.</p> required <code>resources_data</code> <code>dict</code> <p>Configuration data for the resources from the yaml file.</p> required <code>processes_data</code> <code>dict</code> <p>Configuration data for the processes from the yaml file.</p> required <p>Attributes:</p> Name Type Description <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> <code>resource_keys</code> <code>list</code> <p>List of resource keys used in the pathway.</p> <code>process_keys</code> <code>list</code> <p>List of process keys used in the pathway.</p> <code>compute_all_years</code> <code>bool</code> <p>Flag indicating whether to compute costs for all years or only for years with commissioned capacity.</p> <code>compute_abatement_cost</code> <code>bool</code> <p>Flag indicating whether to compute abatement costs.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/bottom_up/cost.py</code> <pre><code>def __init__(self, name, configuration_data, resources_data, processes_data, *args, **kwargs):\n    super().__init__(\n        name=name,\n        model_type=\"custom\",\n        *args,\n        **kwargs,\n    )\n    # Get the name of the pathway\n    self.pathway_name = configuration_data[\"name\"]\n\n    # Get the inputs from the configuration file: two options\n    # 1. All inputs of a certain category in the yaml file\n    for key, val in configuration_data.get(\"inputs\").get(\"economics\", {}).items():\n        # TODO initialize with zeros instead of actual val?\n        self.input_names[key] = val\n    for key, val in configuration_data.get(\"inputs\").get(\"technical\", {}).items():\n        # TODO initialize with zeros instead of actual val? How to better get rid of unnecessary variables\n        if (\n            key == f\"{self.pathway_name}_resource_names\"\n            or key == f\"{self.pathway_name}_processes_names\"\n        ):\n            pass  # avoid having strings as variable in gemseo, not needed as variables\n        else:\n            self.input_names[key] = val\n\n    # 2. Set individual inputs, coming either from other models or from the yaml as well\n    self.input_names.update(\n        {\n            f\"{self.pathway_name}_energy_production_commissioned\": pd.Series([0.0]),\n            f\"{self.pathway_name}_energy_consumption\": pd.Series([0.0]),\n            f\"{self.pathway_name}_energy_unused\": pd.Series([0.0]),\n            f\"{self.pathway_name}_mean_co2_emission_factor\": pd.Series([0.0]),\n            \"private_discount_rate\": 0.0,\n            \"carbon_tax\": pd.Series([0.0]),\n        }\n    )\n    if configuration_data.get(\"environmental_model\") == \"bottom_up\":\n        self.input_names.update(\n            {\n                f\"{self.pathway_name}_vintage_eis_co2_emission_factor\": pd.Series([0.0]),\n            }\n        )\n\n    self.output_names = {\n        f\"{self.pathway_name}_mean_mfsp_without_resource\": pd.Series([0.0]),\n        f\"{self.pathway_name}_mean_unit_capex\": pd.Series([0.0]),\n        f\"{self.pathway_name}_mean_unit_fixed_opex\": pd.Series([0.0]),\n        f\"{self.pathway_name}_mean_unit_variable_opex\": pd.Series([0.0]),\n        f\"{self.pathway_name}_capex_cost\": pd.Series([0.0]),\n        # Ajout des sorties vintage pour les co\u00fbts principaux\n        f\"{self.pathway_name}_vintage_unit_capex\": pd.Series([0.0]),\n        f\"{self.pathway_name}_vintage_unit_fixed_opex\": pd.Series([0.0]),\n        f\"{self.pathway_name}_vintage_unit_variable_opex\": pd.Series([0.0]),\n    }\n\n    # 3. Getting resources is a bit more complex as we need to get necessary resources for the pathway\n    self.resource_keys = (\n        configuration_data.get(\"inputs\")\n        .get(\"technical\", {})\n        .get(f\"{self.pathway_name}_resource_names\", [])\n    ).copy()\n\n    for key in self.resource_keys:\n        # Outputs.\n        self.output_names[f\"{self.pathway_name}_excluding_processes_{key}_mean_unit_cost\"] = (\n            pd.Series([0.0])\n        )\n        # Ajout sortie vintage pour chaque ressource\n        self.output_names[\n            f\"{self.pathway_name}_excluding_processes_{key}_vintage_unit_cost\"\n        ] = pd.Series([0.0])\n\n    self.process_keys = (\n        configuration_data.get(\"inputs\")\n        .get(\"technical\", {})\n        .get(f\"{self.pathway_name}_processes_names\", [])\n    ).copy()\n\n    for process_key in self.process_keys:\n        for key, val in processes_data[process_key].get(\"inputs\").get(\"technical\", {}).items():\n            if key == f\"{process_key}_resource_names\":\n                resources = (\n                    processes_data[process_key]\n                    .get(\"inputs\")\n                    .get(\"technical\", {})\n                    .get(f\"{process_key}_resource_names\", [])\n                ).copy()\n                self.resource_keys.extend(resources)\n                for resource in resources:\n                    self.output_names[\n                        f\"{self.pathway_name}_{process_key}_{resource}_mean_unit_cost\"\n                    ] = pd.Series([0.0])\n                    # Ajout sortie vintage pour chaque ressource de process\n                    self.output_names[\n                        f\"{self.pathway_name}_{process_key}_{resource}_vintage_unit_cost\"\n                    ] = pd.Series([0.0])\n            else:\n                # TODO initialize with zeros instead of actual val?\n                self.input_names[key] = val\n\n        for key, val in processes_data[process_key].get(\"inputs\").get(\"economics\", {}).items():\n            # TODO initialize with zeros instead of actual val?\n            self.input_names[key] = val\n        self.output_names[\n            f\"{self.pathway_name}_{process_key}_mean_unit_cost_without_resources\"\n        ] = pd.Series([0.0])\n        self.output_names[f\"{self.pathway_name}_{process_key}_mean_unit_capex\"] = pd.Series(\n            [0.0]\n        )\n        self.output_names[f\"{self.pathway_name}_{process_key}_capex_cost\"] = pd.Series([0.0])\n        self.output_names[f\"{self.pathway_name}_{process_key}_mean_unit_fixed_opex\"] = (\n            pd.Series([0.0])\n        )\n        self.output_names[f\"{self.pathway_name}_{process_key}_mean_unit_variable_opex\"] = (\n            pd.Series([0.0])\n        )\n        self.output_names[f\"{self.pathway_name}_{process_key}_vintage_unit_capex\"] = pd.Series(\n            [0.0]\n        )\n        self.output_names[f\"{self.pathway_name}_{process_key}_vintage_unit_fixed_opex\"] = (\n            pd.Series([0.0])\n        )\n        self.output_names[f\"{self.pathway_name}_{process_key}_vintage_unit_variable_opex\"] = (\n            pd.Series([0.0])\n        )\n\n    # Getting unique resources\n    self.resource_keys = list(set(self.resource_keys))\n\n    # Adding resources-linked inputs and outputs\n    # TODO specify eco/cost as for process\n    for key in self.resource_keys:\n        if f\"{key}_cost\" in resources_data[key][\"specifications\"]:\n            self.input_names[f\"{key}_cost\"] = pd.Series([0.0])\n        if f\"{key}_load_factor\" in resources_data[key][\"specifications\"]:\n            self.input_names[f\"{key}_load_factor\"] = pd.Series([0.0])\n        # Outputs.\n\n    # Fill in the expected outputs with names from the compute method, initialized with NaN\n    self.output_names.update(\n        {\n            f\"{self.pathway_name}_net_mfsp_without_carbon_tax\": pd.Series([0.0]),\n            f\"{self.pathway_name}_net_mfsp\": pd.Series([0.0]),\n            f\"{self.pathway_name}_mean_mfsp\": pd.Series([0.0]),\n            f\"{self.pathway_name}_marginal_mfsp\": pd.Series([0.0]),\n            f\"{self.pathway_name}_mean_unit_tax\": pd.Series([0.0]),\n            f\"{self.pathway_name}_mean_unit_carbon_tax\": pd.Series([0.0]),\n            f\"{self.pathway_name}_mean_unit_subsidy\": pd.Series([0.0]),\n        }\n    )\n\n    if configuration_data.get(\"environmental_model\") == \"bottom_up\":\n        self.output_names.update(\n            {\n                f\"{self.pathway_name}_vintage_eis_carbon_tax\": pd.Series([0.0]),\n            }\n        )\n\n    if configuration_data.get(\"compute_all_years\"):\n        self.compute_all_years = True\n    else:\n        self.compute_all_years = False\n\n    if configuration_data.get(\"abatement_cost\"):\n        self.compute_abatement_cost = True\n        self.output_names[f\"{self.pathway_name}_lifespan_unitary_discounted_costs\"] = pd.Series(\n            [0.0]\n        )\n        self.input_names[\"social_discount_rate\"] = 0.0\n    else:\n        self.compute_abatement_cost = False\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.bottom_up.cost/#aeromaps.models.impacts.generic_energy_model.bottom_up.cost.BottomUpCost.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Execute the bottom-up techno-economic cost computation for the pathway. Each plant (vintage) is commissioned with the characteristics of its commissioning year, and its emissions are distributed over its lifespan, weighted by its share in annual production.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/bottom_up/cost.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"\n    Execute the bottom-up techno-economic cost computation for the pathway.\n    Each plant (vintage) is commissioned with the characteristics of its commissioning year,\n    and its emissions are distributed over its lifespan, weighted by its share in annual production.\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n    \"\"\"\n    optional_nan_series = pd.Series(\n        np.nan, index=range(self.historic_start_year, self.end_year + 1)\n    )\n\n    energy_production_commissioned = input_data[\n        f\"{self.pathway_name}_energy_production_commissioned\"\n    ]\n    energy_consumption = input_data[f\"{self.pathway_name}_energy_consumption\"]\n    energy_unused = input_data[f\"{self.pathway_name}_energy_unused\"]\n\n    # first lets initialize the output data with mean mfsp components by parsing resources and processes\n    # Prepare outputs\n    output_data = {k: optional_nan_series.copy() for k in self.output_names}\n\n    # First lets compute the core mfsp\n    for year, needed_capacity in energy_production_commissioned.items():\n        # Get the technical inputs\n        private_discount_rate = _get_value_for_year(\n            input_data.get(\"private_discount_rate\"), year, 0.0\n        )\n        lifespan = _get_value_for_year(\n            input_data.get(f\"{self.pathway_name}_eis_plant_lifespan\"), year, 25\n        )\n        construction_time = _get_value_for_year(\n            input_data.get(f\"{self.pathway_name}_eis_construction_time\"), year, 3\n        )\n        plant_load_factor = _get_value_for_year(\n            input_data.get(f\"{self.pathway_name}_eis_plant_load_factor\"), year, 1\n        )\n\n        # plant production is potentially evaluated beyond scenario end year\n        vintage_indexes = range(year, year + lifespan)\n        vintage_mfsp = pd.Series(np.nan, index=vintage_indexes)\n        if (\n            energy_consumption[year] &gt; 0\n            and needed_capacity &lt;= 0\n            and self.compute_abatement_cost\n            and not self.compute_all_years\n        ):\n            print(\n                f\"\u26a0\ufe0f Warning:  for {self.pathway_name}, no plants commissioned in {year}. Unable to compute \"\n                f\"CAC: compute_all_years = False. Set it true to avoid NaN values in the MACC for this year.\"\n            )\n        if needed_capacity &gt; 0 or self.compute_all_years:\n            if needed_capacity &lt; 0:\n                warnings.warn(\n                    f\"Negative needed capacity for {self.pathway_name} in year {year}. \"\n                    \"This is not expected despite the compute_all_years option being set to True.\"\n                )\n            # relative contibution of the vintage\n            relative_share = needed_capacity / (energy_consumption + energy_unused)\n\n            relative_share = relative_share.loc[year : year + lifespan - 1]\n\n            # I -- First lets compute the core MFSP (no resources, no processes)\n            # Get the inputs for the year\n            capex = _get_value_for_year(\n                input_data.get(f\"{self.pathway_name}_eis_capex\"), year, 0.0\n            )\n\n            # get the plant load factor for the year: minimum of plant load factor and resource load factors\n            # TODO what shall we do with processes LF? Uncoupling core and processes make sense in many cases.\n            main_process_load_factor = plant_load_factor\n            for key in input_data.get(f\"{self.pathway_name}_resource_names\", []):\n                if f\"{key}_load_factor\" in input_data:\n                    resource_load_factor = _get_value_for_year(\n                        input_data.get(f\"{key}_load_factor\"), year, 1.0\n                    )\n                    if resource_load_factor is not None:\n                        main_process_load_factor = min(\n                            main_process_load_factor, resource_load_factor\n                        )\n\n            # Compute the capital cost per unit of energy produced. Capex in \u20ac/(MJ/Year), mfsp capex in \u20ac/MJ\n            mfsp_capex = (\n                self._spread_capital(capex, private_discount_rate, lifespan, construction_time)\n                / main_process_load_factor\n            )\n\n            capex_year = capex * needed_capacity\n            output_data[f\"{self.pathway_name}_capex_cost\"].loc[\n                year - construction_time : year\n            ] = _custom_series_addition(\n                output_data[f\"{self.pathway_name}_capex_cost\"].loc[\n                    year - construction_time : year\n                ],\n                capex_year / construction_time / main_process_load_factor,\n            )\n\n            output_data[f\"{self.pathway_name}_mean_unit_capex\"].loc[\n                year : year + lifespan - 1\n            ] = _custom_series_addition(\n                output_data[f\"{self.pathway_name}_mean_unit_capex\"].loc[\n                    year : year + lifespan - 1\n                ],\n                mfsp_capex * relative_share,\n            )\n\n            # compyte the EIS unitary capex\n            output_data[f\"{self.pathway_name}_vintage_unit_capex\"].loc[year] = mfsp_capex\n\n            # As var opex is in \u20ac per MJ we can directly get it\n            variable_opex = _get_value_for_year(\n                input_data.get(f\"{self.pathway_name}_eis_variable_opex\"), year, 0.0\n            )\n            output_data[f\"{self.pathway_name}_mean_unit_variable_opex\"].loc[\n                year : year + lifespan - 1\n            ] = _custom_series_addition(\n                output_data[f\"{self.pathway_name}_mean_unit_variable_opex\"].loc[\n                    year : year + lifespan - 1\n                ],\n                variable_opex * relative_share,\n            )\n\n            # compyte the EIS variable opex --&gt; No need, directly from input eis_variable_opex\n            output_data[f\"{self.pathway_name}_vintage_unit_variable_opex\"].loc[year] = (\n                variable_opex\n            )\n\n            # As fixed opex is in \u20ac/year for a plant of 1 MJ/year, we can directly get it in \u20ac/MJ\n            fixed_opex = (\n                _get_value_for_year(\n                    input_data.get(f\"{self.pathway_name}_eis_fixed_opex\"), year, 0.0\n                )\n                / main_process_load_factor\n            )\n            output_data[f\"{self.pathway_name}_mean_unit_fixed_opex\"].loc[\n                year : year + lifespan - 1\n            ] = _custom_series_addition(\n                output_data[f\"{self.pathway_name}_mean_unit_fixed_opex\"].loc[\n                    year : year + lifespan - 1\n                ],\n                fixed_opex * relative_share,\n            )\n\n            # compyte the EIS fixed opex\n            output_data[f\"{self.pathway_name}_vintage_unit_fixed_opex\"].loc[year] = fixed_opex\n\n            vintage_mfsp = _custom_series_addition(\n                vintage_mfsp, mfsp_capex + fixed_opex + variable_opex\n            )\n\n            output_data[f\"{self.pathway_name}_mean_mfsp_without_resource\"].loc[\n                year : year + lifespan - 1\n            ] = _custom_series_addition(\n                output_data[f\"{self.pathway_name}_mean_mfsp_without_resource\"].loc[\n                    year : year + lifespan - 1\n                ],\n                vintage_mfsp * relative_share,\n            )\n\n            # II -- Now lets get the resources as in TopDownCost model\n            for key in self.resource_keys:\n                # get the specific consumption of the resource\n                specific_consumption = _get_value_for_year(\n                    input_data.get(\n                        f\"{self.pathway_name}_eis_resource_specific_consumption_{key}\"\n                    ),\n                    year,\n                    None,\n                )\n\n                if specific_consumption is not None:\n                    resource_price = input_data.get(f\"{key}_cost\", optional_nan_series.copy())\n\n                    # cast mfsp_resource to a series with the same index as\n                    # vintage_mfsp by keeping correct values (&lt;end year) extending last year value to the end of the vintage_mfsp\n                    mfsp_resource = pd.Series(\n                        [\n                            resource_price[year] * specific_consumption\n                            if year &lt;= self.end_year and year in resource_price.index\n                            else resource_price.iloc[-1] * specific_consumption\n                            for year in vintage_mfsp.index\n                        ],\n                        index=vintage_mfsp.index,\n                    )\n\n                    vintage_mfsp = _custom_series_addition(vintage_mfsp, mfsp_resource)\n\n                    # Store the resource cost in the output data\n                    output_data[\n                        f\"{self.pathway_name}_excluding_processes_{key}_mean_unit_cost\"\n                    ].loc[year : year + lifespan - 1] = _custom_series_addition(\n                        output_data[\n                            f\"{self.pathway_name}_excluding_processes_{key}_mean_unit_cost\"\n                        ].loc[year : year + lifespan - 1],\n                        mfsp_resource * relative_share,\n                    )\n\n                    # compyte the EIS resource cost (at first year energy cost)\n                    output_data[\n                        f\"{self.pathway_name}_excluding_processes_{key}_vintage_unit_cost\"\n                    ].loc[year] = mfsp_resource[year]\n\n                # get processes that use this resource\n                for process_key in self.process_keys:\n                    specific_consumption = _get_value_for_year(\n                        input_data.get(\n                            f\"{process_key}_eis_resource_specific_consumption_{key}\"\n                        ),\n                        year,\n                        None,\n                    )\n\n                    if specific_consumption is not None:\n                        process_ressource_price = input_data.get(\n                            f\"{key}_cost\", optional_nan_series.copy()\n                        )\n                        # cast mfsp_resource to a series with the same index as\n                        # vintage_mfsp by keeping correct values (&lt;end year) extending last year value to the end of the vintage_mfsp\n                        mfsp_process_ressource = pd.Series(\n                            [\n                                process_ressource_price[year] * specific_consumption\n                                if year &lt;= self.end_year\n                                and year in process_ressource_price.index\n                                else process_ressource_price.iloc[-1] * specific_consumption\n                                for year in vintage_mfsp.index\n                            ],\n                            index=vintage_mfsp.index,\n                        )\n\n                        vintage_mfsp = _custom_series_addition(\n                            vintage_mfsp, mfsp_process_ressource\n                        )\n\n                        # Store the resource cost in the output data\n                        output_data[\n                            f\"{self.pathway_name}_{process_key}_{key}_mean_unit_cost\"\n                        ].loc[year : year + lifespan - 1] = _custom_series_addition(\n                            output_data[\n                                f\"{self.pathway_name}_{process_key}_{key}_mean_unit_cost\"\n                            ].loc[year : year + lifespan - 1],\n                            mfsp_process_ressource * relative_share,\n                        )\n\n                        # compyte the EIS resource cost (at first year energy cost)\n                        output_data[\n                            f\"{self.pathway_name}_{process_key}_{key}_vintage_unit_cost\"\n                        ].loc[year] = mfsp_process_ressource[year]\n\n            # III -- Now lets get the processes\n            for process_key in self.process_keys:\n                process_capex = _get_value_for_year(\n                    input_data.get(f\"{process_key}_eis_capex\"), year, 0.0\n                )\n                process_lifespan = _get_value_for_year(\n                    input_data.get(f\"{process_key}_eis_plant_lifespan\"), year, 25\n                )\n                process_construction_time = _get_value_for_year(\n                    input_data.get(f\"{process_key}_eis_construction_time\"), year, 3.0\n                )\n                process_load_factor = _get_value_for_year(\n                    input_data.get(f\"{process_key}_eis_plant_load_factor\"), year, 1.0\n                )\n                # get the process load factor for the year: minimum of process load factor and resource load factors\n                for key in input_data.get(f\"{process_key}_resource_names\", []):\n                    if f\"{key}_load_factor\" in input_data:\n                        resource_load_factor = _get_value_for_year(\n                            input_data.get(f\"{key}_load_factor\"), year, 1.0\n                        )\n                        if resource_load_factor is not None:\n                            process_load_factor = min(process_load_factor, resource_load_factor)\n                # Compute the capital cost per unit of energy produced for the process\n                mfsp_capex_process = (\n                    self._spread_capital(\n                        process_capex,\n                        private_discount_rate,\n                        process_lifespan,\n                        process_construction_time,\n                    )\n                    / process_load_factor\n                )\n\n                output_data[f\"{self.pathway_name}_{process_key}_capex_cost\"].loc[\n                    year - process_construction_time : year\n                ] = _custom_series_addition(\n                    output_data[f\"{self.pathway_name}_{process_key}_capex_cost\"].loc[\n                        year - process_construction_time : year\n                    ],\n                    process_capex * needed_capacity / construction_time / process_load_factor,\n                )\n\n                # Get the variable and fixed opex for the process\n                variable_opex_process = _get_value_for_year(\n                    input_data.get(f\"{process_key}_eis_variable_opex\"),\n                    year,\n                    0.0,\n                )\n                fixed_opex_process = (\n                    _get_value_for_year(\n                        input_data.get(f\"{process_key}_eis_fixed_opex\"),\n                        year,\n                        0.0,\n                    )\n                    / process_load_factor\n                )\n                # Compute the MFSP for the process\n                mfsp_process = mfsp_capex_process + variable_opex_process + fixed_opex_process\n                # Add the MFSP for the process to the pathway MFSP\n                vintage_mfsp = _custom_series_addition(vintage_mfsp, mfsp_process)\n                # Store the process cost in the output data\n                output_data[\n                    f\"{self.pathway_name}_{process_key}_mean_unit_cost_without_resources\"\n                ].loc[year : year + process_lifespan] = _custom_series_addition(\n                    output_data[\n                        f\"{self.pathway_name}_{process_key}_mean_unit_cost_without_resources\"\n                    ].loc[year : year + process_lifespan],\n                    mfsp_process * relative_share,\n                )\n                output_data[f\"{self.pathway_name}_{process_key}_mean_unit_capex\"].loc[\n                    year : year + lifespan - 1\n                ] = _custom_series_addition(\n                    output_data[f\"{self.pathway_name}_{process_key}_mean_unit_capex\"].loc[\n                        year : year + lifespan - 1\n                    ],\n                    mfsp_capex_process * relative_share,\n                )\n                # compyte the EIS unitary capex\n                output_data[f\"{self.pathway_name}_{process_key}_vintage_unit_capex\"].loc[\n                    year\n                ] = mfsp_capex_process\n\n                output_data[f\"{self.pathway_name}_{process_key}_mean_unit_fixed_opex\"].loc[\n                    year : year + lifespan - 1\n                ] = _custom_series_addition(\n                    output_data[f\"{self.pathway_name}_{process_key}_mean_unit_fixed_opex\"].loc[\n                        year : year + lifespan - 1\n                    ],\n                    fixed_opex_process * relative_share,\n                )\n                # compyte the EIS fixed opex\n                output_data[f\"{self.pathway_name}_{process_key}_vintage_unit_fixed_opex\"].loc[\n                    year\n                ] = fixed_opex_process\n\n                output_data[f\"{self.pathway_name}_{process_key}_mean_unit_variable_opex\"].loc[\n                    year : year + lifespan - 1\n                ] = _custom_series_addition(\n                    output_data[\n                        f\"{self.pathway_name}_{process_key}_mean_unit_variable_opex\"\n                    ].loc[year : year + lifespan - 1],\n                    variable_opex_process * relative_share,\n                )\n\n                # compyte the EIS variable opex\n                output_data[\n                    f\"{self.pathway_name}_{process_key}_vintage_unit_variable_opex\"\n                ].loc[year] = variable_opex_process\n\n            output_data[f\"{self.pathway_name}_mean_mfsp\"].loc[year : year + lifespan - 1] = (\n                _custom_series_addition(\n                    output_data[f\"{self.pathway_name}_mean_mfsp\"].loc[\n                        year : year + lifespan - 1\n                    ],\n                    vintage_mfsp * relative_share,\n                )\n            )\n\n            # marginal mfsp: is the new vintage the marginal one at some point of the scenario?\n            # Slice the relevant part\n            target = output_data[f\"{self.pathway_name}_marginal_mfsp\"].loc[\n                year : year + lifespan - 1\n            ]\n            # Find common indices\n            common_index = target.index.intersection(vintage_mfsp.index)\n            # Align both Series\n            target_common = target.loc[common_index]\n            vintage_common = vintage_mfsp.loc[common_index]\n            # Build mask:\n            # (1) vintage &gt; target\n            # (2) or target is NaN and vintage is not NaN\n            mask = (vintage_common &gt; target_common) | (\n                target_common.isna() &amp; vintage_common.notna()\n            )\n            # Apply the update\n            output_data[f\"{self.pathway_name}_marginal_mfsp\"].loc[common_index] = (\n                target_common.where(~mask, vintage_common)\n            )\n\n            # compute discounted costs if necessary\n            if self.compute_abatement_cost:\n                if vintage_mfsp.notna().any():\n                    discounted_mfsp = self._unitary_cumulative_discounted_costs_vintage(\n                        mfsp_series=vintage_mfsp,\n                        year=year,\n                        plant_lifespan=lifespan,\n                        discount_rate=input_data[\"social_discount_rate\"],\n                    )\n                else:\n                    discounted_mfsp = np.NaN\n                output_data[f\"{self.pathway_name}_lifespan_unitary_discounted_costs\"][year] = (\n                    discounted_mfsp\n                )\n\n    ### STEP 2: add taxes and subsidies like in TopDownCost model\n    # Only pathway subsidies and taxes are considered here, not resources or processes taxes\n\n    pathway_unit_subsidy_without_resource = input_data.get(\n        f\"{self.pathway_name}_mean_unit_subsidy_without_resource\", optional_nan_series.copy()\n    )\n\n    pathway_unit_tax_without_resource = input_data.get(\n        f\"{self.pathway_name}_mean_unit_tax_without_resource\", optional_nan_series.copy()\n    )\n\n    # Avoiding adding nans if subsidies and taxes defined for a shorter period of time than the mfsp\n    pathway_net_mfsp_without_carbon_tax = _custom_series_addition(\n        _custom_series_addition(\n            output_data[f\"{self.pathway_name}_mean_mfsp\"], pathway_unit_tax_without_resource\n        ),\n        -pathway_unit_subsidy_without_resource,\n    )\n\n    # Handle possible differential carbon_tax\n    if f\"{self.pathway_name}_carbon_tax\" in input_data:\n        carbon_tax = (\n            input_data[f\"{self.pathway_name}_carbon_tax\"] / 1000\n        )  # converted to \u20ac/kgCO2\n    else:\n        carbon_tax = input_data[\"carbon_tax\"] / 1000  # converted to \u20ac/kgCO2\n\n    emission_factor = (\n        input_data[f\"{self.pathway_name}_mean_co2_emission_factor\"] / 1000\n    )  # converted to kgCO2/MJ\n    pathway_unit_carbon_tax = carbon_tax * emission_factor\n\n    if f\"{self.pathway_name}_vintage_eis_co2_emission_factor\" in input_data:\n        vintage_eis_carbon_tax = (\n            input_data[f\"{self.pathway_name}_vintage_eis_co2_emission_factor\"]\n            / 1000\n            * carbon_tax\n        )\n        output_data[f\"{self.pathway_name}_vintage_eis_carbon_tax\"] = vintage_eis_carbon_tax\n\n    pathway_net_mfsp = _custom_series_addition(\n        pathway_net_mfsp_without_carbon_tax, pathway_unit_carbon_tax\n    )\n\n    output_data.update(\n        {\n            f\"{self.pathway_name}_net_mfsp_without_carbon_tax\": pathway_net_mfsp_without_carbon_tax,\n            f\"{self.pathway_name}_net_mfsp\": pathway_net_mfsp,\n            f\"{self.pathway_name}_mean_unit_tax\": pathway_unit_tax_without_resource,\n            f\"{self.pathway_name}_mean_unit_carbon_tax\": pathway_unit_carbon_tax,\n            f\"{self.pathway_name}_mean_unit_subsidy\": pathway_unit_subsidy_without_resource,\n        }\n    )\n\n    # Store the results in the df and retun\n\n    self._store_outputs(output_data)\n\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.bottom_up.environmental/","title":"<code>aeromaps.models.impacts.generic_energy_model.bottom_up.environmental</code>","text":"<p>environmental</p> <p>====== Module to compute pathway emissions based on bottom-up plant descriptions (EIS and capacity).</p>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.bottom_up.environmental/#aeromaps.models.impacts.generic_energy_model.bottom_up.environmental.BottomUpEnvironmental","title":"BottomUpEnvironmental","text":"<pre><code>BottomUpEnvironmental(name, configuration_data, resources_data, processes_data, *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Generic environmental model for aviation energy carriers, relying on user's description of the carriers in the configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('f\"{pathway_name}_bottom_up_unit_environmental\"' by default).</p> required <code>configuration_data</code> <code>dict</code> <p>Configuration data for the energy pathway from the configuration file.</p> required <code>resources_data</code> <code>dict</code> <p>Configuration data for the resources from the configuration file.</p> required <code>processes_data</code> <code>dict</code> <p>Configuration data for the processes from the configuration file.</p> required <p>Attributes:</p> Name Type Description <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Warning <p>Description of i/o variables is very limited for models with dynamic i/o names. They are defined in .yaml configuration files.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/bottom_up/environmental.py</code> <pre><code>def __init__(\n    self,\n    name,\n    configuration_data,\n    resources_data,\n    processes_data,\n    *args,\n    **kwargs,\n):\n    super().__init__(\n        name=name,\n        model_type=\"custom\",\n        # inputs/outputs are defined in __init__ rather than auto generated from compute() signature\n        *args,\n        **kwargs,\n    )\n    # Get the name of the pathway\n    self.pathway_name = configuration_data[\"name\"]\n\n    # Get the inputs from the configuration file: two options\n    # 1. All inputs of a certain category in the yaml file\n    for key, val in configuration_data.get(\"inputs\").get(\"environmental\", {}).items():\n        # TODO initialize with zeros instead of actual val?\n        self.input_names[key] = val\n    for key, val in configuration_data.get(\"inputs\").get(\"technical\", {}).items():\n        # TODO initialize with zeros instead of actual val? How to better get rid of unnecessary variables\n        if (\n            key == f\"{self.pathway_name}_resource_names\"\n            or key == f\"{self.pathway_name}_processes_names\"\n        ):\n            pass  # avoid having strings as variable in gemseo, not needed as variables\n        else:\n            self.input_names[key] = val\n\n    # 2. Set individual inputs, coming either from other models or from the yaml as well\n    self.input_names.update(\n        {\n            f\"{self.pathway_name}_energy_production_commissioned\": pd.Series([0.0]),\n            f\"{self.pathway_name}_energy_consumption\": pd.Series([0.0]),\n            f\"{self.pathway_name}_energy_unused\": pd.Series([0.0]),\n        }\n    )\n\n    # TODO find a better way to get the resource inputs ? Now better with the list(str) argument of each pathway .yaml\n    # 3. Getting resources is a bit more complex as we need to get necessary resources for the pathway\n    self.resource_keys = (\n        configuration_data.get(\"inputs\")\n        .get(\"technical\", {})\n        .get(f\"{self.pathway_name}_resource_names\", [])\n    ).copy()\n\n    self.process_keys = (\n        configuration_data.get(\"inputs\")\n        .get(\"technical\", {})\n        .get(f\"{self.pathway_name}_processes_names\", [])\n    ).copy()\n\n    # Adding resources-linked inputs and outputs\n    for key in self.resource_keys:\n        self.output_names[\n            f\"{self.pathway_name}_excluding_processes_{key}_mean_co2_emission_factor\"\n        ] = pd.Series([0.0])\n        self.output_names[\n            f\"{self.pathway_name}_excluding_processes_{key}_total_consumption\"\n        ] = pd.Series([0.0])\n        self.output_names[\n            f\"{self.pathway_name}_excluding_processes_{key}_total_mobilised_with_selectivity\"\n        ] = pd.Series([0.0])\n\n        self.output_names[f\"{self.pathway_name}_{key}_total_consumption\"] = pd.Series([0.0])\n        self.output_names[f\"{self.pathway_name}_{key}_total_mobilised_with_selectivity\"] = (\n            pd.Series([0.0])\n        )\n\n    for process_key in self.process_keys:\n        for key, val in processes_data[process_key].get(\"inputs\").get(\"technical\", {}).items():\n            if key == f\"{process_key}_resource_names\":\n                resources = (\n                    processes_data[process_key]\n                    .get(\"inputs\")\n                    .get(\"technical\", {})\n                    .get(f\"{process_key}_resource_names\", [])\n                ).copy()\n                self.resource_keys.extend(resources)\n                for resource in resources:\n                    self.output_names[\n                        f\"{self.pathway_name}_{process_key}_{resource}_mean_co2_emission_factor\"\n                    ] = pd.Series([0.0])\n                    self.output_names[\n                        f\"{self.pathway_name}_{process_key}_{resource}_total_consumption\"\n                    ] = pd.Series([0.0])\n                    self.output_names[\n                        f\"{self.pathway_name}_{process_key}_{resource}_total_mobilised_with_selectivity\"\n                    ] = pd.Series([0.0])\n            else:\n                # TODO initialize with zeros instead of actual val?\n                self.input_names[key] = val\n\n        for key, val in processes_data[process_key].get(\"inputs\").get(\"economics\", {}).items():\n            # TODO initialize with zeros instead of actual val?\n            self.input_names[key] = val\n        self.output_names[\n            f\"{self.pathway_name}_{process_key}_without_resources_mean_co2_emission_factor\"\n        ] = pd.Series([0.0])\n\n    # Getting unique resources\n    self.resource_keys = list(set(self.resource_keys))\n\n    for key in self.resource_keys:\n        if f\"{key}_co2_emission_factor\" in resources_data[key][\"specifications\"]:\n            self.input_names[f\"{key}_co2_emission_factor\"] = pd.Series([0.0])\n\n        self.output_names[f\"{self.pathway_name}_{key}_total_consumption\"] = pd.Series([0.0])\n        self.output_names[f\"{self.pathway_name}_{key}_total_mobilised_with_selectivity\"] = (\n            pd.Series([0.0])\n        )\n\n    if configuration_data.get(\"compute_all_years\"):\n        self.compute_all_years = True\n    else:\n        self.compute_all_years = False\n    # Checking if we need to compute the CAC\n    if configuration_data.get(\"abatement_cost\"):\n        self.compute_abatement_cost = True\n        self.input_names[\"exogenous_carbon_price_trajectory\"] = pd.Series([0.0])\n        self.input_names[\"social_discount_rate\"] = 0.0\n        self.output_names[f\"{self.pathway_name}_lifespan_unitary_emissions\"] = pd.Series([0.0])\n        self.output_names[f\"{self.pathway_name}_lifespan_discounted_unitary_emissions\"] = (\n            pd.Series([0.0])\n        )\n    else:\n        self.compute_abatement_cost = False\n\n    # Fill in the other expected outputs with names from the compute method\n    self.output_names.update(\n        {\n            f\"{self.pathway_name}_mean_co2_emission_factor\": pd.Series([0.0]),\n            f\"{self.pathway_name}_vintage_eis_co2_emission_factor\": pd.Series([0.0]),\n            f\"{self.pathway_name}_total_co2_emissions\": pd.Series([0.0]),\n            f\"{self.pathway_name}_mean_co2_emission_factor_without_resource\": pd.Series([0.0]),\n        }\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.bottom_up.environmental/#aeromaps.models.impacts.generic_energy_model.bottom_up.environmental.BottomUpEnvironmental.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Compute the environmental impact of the energy carrier pathway. Each plant (vintage) is commissioned with the characteristics of its commissioning year, and its emissions are distributed over its lifespan, weighted by its share in annual production.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/bottom_up/environmental.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"\n    Compute the environmental impact of the energy carrier pathway.\n    Each plant (vintage) is commissioned with the characteristics of its commissioning year,\n    and its emissions are distributed over its lifespan, weighted by its share in annual production.\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n    \"\"\"\n\n    optional_nan_series = pd.Series(\n        np.nan, index=range(self.historic_start_year, self.end_year + 1)\n    )\n    energy_production_commissioned = input_data[\n        f\"{self.pathway_name}_energy_production_commissioned\"\n    ]\n    energy_consumption = input_data[f\"{self.pathway_name}_energy_consumption\"]\n    energy_unused = input_data[f\"{self.pathway_name}_energy_unused\"]\n\n    # Prepare outputs\n    output_data = {k: optional_nan_series.copy() for k in self.output_names}\n\n    co2_emission_factor = optional_nan_series.copy()\n\n    # For each vintage, compute its emission factor and contribution\n    for year, needed_capacity in energy_production_commissioned.items():\n        lifespan = _get_value_for_year(\n            input_data.get(f\"{self.pathway_name}_eis_plant_lifespan\"), year, 25\n        )\n        # The plant will operate from year to year+lifespan (or until end_year)\n        vintage_indexes = range(year, year + lifespan)\n        vintage_emission_factor = pd.Series(np.nan, index=vintage_indexes)\n        if (\n            energy_consumption[year] &gt; 0\n            and needed_capacity &lt;= 0\n            and self.compute_abatement_cost\n            and not self.compute_all_years\n        ):\n            print(\n                f\"\u26a0\ufe0f Warning:  for {self.pathway_name}, no plants commissioned in {year}. Unable to compute \"\n                f\"CAC: compute_all_years = False. Set it true to avoid NaN values in the MACC for this year.\"\n            )\n        if needed_capacity &gt; 0 or self.compute_all_years:\n            if needed_capacity &lt; 0:\n                warnings.warn(\n                    f\"Negative needed capacity for {self.pathway_name} in year {year}. \"\n                    \"This is not expected despite the compute_all_years option being set to True.\"\n                )\n            # relative contibution of the vintage\n            relative_share = needed_capacity / (energy_consumption + energy_unused)\n            relative_share = relative_share.loc[year : year + lifespan - 1]\n\n            # I -- First lets compute the core MFSP (no resources, no processes)\n            # Get the inputs for the year\n            core_emission_factor = _get_value_for_year(\n                input_data.get(f\"{self.pathway_name}_eis_co2_emission_factor_without_resource\"),\n                year,\n                0.0,\n            )\n            kerosene_selectivity = _get_value_for_year(\n                input_data.get(f\"{self.pathway_name}_eis_kerosene_selectivity\"), year, 1.0\n            )\n\n            vintage_emission_factor = _custom_series_addition(\n                vintage_emission_factor, core_emission_factor\n            )\n            output_data[f\"{self.pathway_name}_mean_co2_emission_factor_without_resource\"].loc[\n                year : year + lifespan - 1\n            ] = _custom_series_addition(\n                output_data[\n                    f\"{self.pathway_name}_mean_co2_emission_factor_without_resource\"\n                ].loc[year : year + lifespan - 1],\n                core_emission_factor * relative_share,\n            )\n\n            # II) Now let's compute the emissions from resources that are linked to the pathway itself\n            for key in self.resource_keys:\n                specific_consumption = _get_value_for_year(\n                    input_data.get(\n                        f\"{self.pathway_name}_eis_resource_specific_consumption_{key}\"\n                    ),\n                    year,\n                    None,\n                )\n\n                total_ressource_consumption = optional_nan_series.copy()\n                total_ressource_mobilised_with_selectivity = optional_nan_series.copy()\n\n                if specific_consumption is not None:\n                    resources_consumption = (\n                        energy_production_commissioned[year] * specific_consumption\n                    )\n                    resources_consumption_with_selectivity = (\n                        resources_consumption * kerosene_selectivity\n                    )\n\n                    total_ressource_consumption.loc[year : year + lifespan - 1] = (\n                        resources_consumption\n                    )\n                    total_ressource_mobilised_with_selectivity.loc[\n                        year : year + lifespan - 1\n                    ] = resources_consumption_with_selectivity\n\n                    output_data[\n                        f\"{self.pathway_name}_excluding_processes_{key}_total_consumption\"\n                    ].loc[year : year + lifespan - 1] += resources_consumption\n                    output_data[\n                        f\"{self.pathway_name}_excluding_processes_{key}_total_mobilised_with_selectivity\"\n                    ].loc[year : year + lifespan - 1] += resources_consumption_with_selectivity\n\n                    # Get the CO2 emission factor for the resource\n                    unit_emissions = input_data.get(\n                        f\"{key}_co2_emission_factor\", optional_nan_series\n                    )\n                    # beyond sceanrio end year, we stick to last known value\n                    unit_emissions = unit_emissions.reindex(\n                        range(year, year + lifespan), method=\"ffill\"\n                    )\n\n                    # get resource emission per unit of energy\n                    co2_emission_factor_ressource = specific_consumption * unit_emissions\n                    vintage_emission_factor = _custom_series_addition(\n                        vintage_emission_factor, co2_emission_factor_ressource\n                    )\n                    output_data[\n                        f\"{self.pathway_name}_excluding_processes_{key}_mean_co2_emission_factor\"\n                    ].loc[year : year + lifespan - 1] = _custom_series_addition(\n                        output_data[\n                            f\"{self.pathway_name}_excluding_processes_{key}_mean_co2_emission_factor\"\n                        ].loc[year : year + lifespan - 1],\n                        co2_emission_factor_ressource * relative_share,\n                    )\n                # III) Now let's compute the emissions from processes that gets a ressource\n                for process_key in self.process_keys:\n                    specific_consumption = _get_value_for_year(\n                        input_data.get(\n                            f\"{process_key}_eis_resource_specific_consumption_{key}\"\n                        ),\n                        year,\n                        None,\n                    )\n                    if specific_consumption is not None:\n                        resources_consumption = (\n                            energy_production_commissioned[year] * specific_consumption\n                        )\n                        resources_consumption_with_selectivity = (\n                            resources_consumption * kerosene_selectivity\n                        )\n\n                        total_ressource_consumption.loc[year : year + lifespan - 1] = (\n                            resources_consumption\n                        )\n                        total_ressource_mobilised_with_selectivity.loc[\n                            year : year + lifespan - 1\n                        ] = resources_consumption_with_selectivity\n\n                        output_data[\n                            f\"{self.pathway_name}_{process_key}_{key}_total_consumption\"\n                        ].loc[year : year + lifespan - 1] += resources_consumption\n                        output_data[\n                            f\"{self.pathway_name}_{process_key}_{key}_total_mobilised_with_selectivity\"\n                        ].loc[\n                            year : year + lifespan - 1\n                        ] += resources_consumption_with_selectivity\n\n                        # Get the CO2 emission factor for the resource\n                        unit_emissions = input_data.get(\n                            f\"{key}_co2_emission_factor\", optional_nan_series\n                        )\n                        # beyond sceanrio end year, we stick to last known value\n                        unit_emissions = unit_emissions.reindex(\n                            range(year, year + lifespan), method=\"ffill\"\n                        )\n                        # get resource emission per unit of energy\n                        co2_emission_factor_ressource = specific_consumption * unit_emissions\n                        vintage_emission_factor = _custom_series_addition(\n                            vintage_emission_factor, co2_emission_factor_ressource\n                        )\n                        output_data[\n                            f\"{self.pathway_name}_{process_key}_{key}_mean_co2_emission_factor\"\n                        ].loc[year : year + lifespan - 1] = _custom_series_addition(\n                            output_data[\n                                f\"{self.pathway_name}_{process_key}_{key}_mean_co2_emission_factor\"\n                            ].loc[year : year + lifespan - 1],\n                            co2_emission_factor_ressource * relative_share,\n                        )\n                # store the total consumption of the resource\n                output_data[f\"{self.pathway_name}_{key}_total_consumption\"].loc[\n                    year : year + lifespan - 1\n                ] = _custom_series_addition(\n                    output_data[f\"{self.pathway_name}_{key}_total_consumption\"].loc[\n                        year : year + lifespan - 1\n                    ],\n                    total_ressource_consumption.loc[year : year + lifespan - 1],\n                )\n                output_data[f\"{self.pathway_name}_{key}_total_mobilised_with_selectivity\"].loc[\n                    year : year + lifespan - 1\n                ] = _custom_series_addition(\n                    output_data[\n                        f\"{self.pathway_name}_{key}_total_mobilised_with_selectivity\"\n                    ].loc[year : year + lifespan - 1],\n                    total_ressource_mobilised_with_selectivity.loc[year : year + lifespan - 1],\n                )\n\n            # IV) Now let's compute the emissions from processes themselves\n            for process_key in self.process_keys:\n                # Get the inputs for the year\n                process_emission_factor = _get_value_for_year(\n                    input_data.get(f\"{process_key}_eis_co2_emission_factor_without_resources\"),\n                    year,\n                    0.0,\n                )\n                vintage_emission_factor = _custom_series_addition(\n                    vintage_emission_factor, process_emission_factor\n                )\n                output_data[\n                    f\"{self.pathway_name}_{process_key}_without_resources_mean_co2_emission_factor\"\n                ].loc[year : year + lifespan - 1] = _custom_series_addition(\n                    output_data[\n                        f\"{self.pathway_name}_{process_key}_without_resources_mean_co2_emission_factor\"\n                    ].loc[year : year + lifespan - 1],\n                    process_emission_factor * relative_share,\n                )\n\n            # Compute the average emission factor from the vintage\n            co2_emission_factor.loc[year : year + lifespan - 1] = _custom_series_addition(\n                co2_emission_factor.loc[year : year + lifespan - 1],\n                vintage_emission_factor * relative_share,\n            )\n\n            # Store the emission factor for the vintage\n            output_data[f\"{self.pathway_name}_vintage_eis_co2_emission_factor\"].loc[year] = (\n                vintage_emission_factor.loc[year]\n            )\n\n            # compute the cumulative and discounted emissions for the vintage\n            if self.compute_abatement_cost:\n                if vintage_emission_factor.notna().any():\n                    # Get the exogenous carbon price trajectory and social discount rate\n                    exogenous_carbon_price_trajectory = input_data.get(\n                        \"exogenous_carbon_price_trajectory\", optional_nan_series\n                    )\n                    social_discount_rate = input_data.get(\"social_discount_rate\", 0.0)\n\n                    # Compute cumulative and discounted emissions for the vintage\n                    cumul_em, generic_discounted_cumul_em = (\n                        self._unitary_cumul_emissions_vintage(\n                            vintage_emission_factor,\n                            exogenous_carbon_price_trajectory,\n                            social_discount_rate,\n                        )\n                    )\n                else:\n                    cumul_em = np.NaN\n                    generic_discounted_cumul_em = np.NaN\n\n                # Store the cumulative emissions for the vintage\n                output_data[f\"{self.pathway_name}_lifespan_unitary_emissions\"].loc[year] = (\n                    cumul_em\n                )\n                output_data[f\"{self.pathway_name}_lifespan_discounted_unitary_emissions\"].loc[\n                    year\n                ] = generic_discounted_cumul_em\n\n    # Store the emission factor\n    output_data[f\"{self.pathway_name}_mean_co2_emission_factor\"] = co2_emission_factor\n    # Compute the total emissions from the vintage\n    total_co2_emissions = energy_consumption * co2_emission_factor\n    output_data[f\"{self.pathway_name}_total_co2_emissions\"] = total_co2_emissions\n\n    self._store_outputs(output_data)\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.bottom_up/","title":"<code>aeromaps.models.impacts.generic_energy_model.bottom_up</code>","text":"bottom_up <p>This package contains bottom-up energy models for estimating pathways' consumption, emissions and costs based on detailed process-level data.</p>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.bottom_up.production_capacity/","title":"<code>aeromaps.models.impacts.generic_energy_model.bottom_up.production_capacity</code>","text":"<p>production_capacity</p> <p>======================= Computes annual capacity additions required to follow an energy consumption trajectory.</p>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.bottom_up.production_capacity/#aeromaps.models.impacts.generic_energy_model.bottom_up.production_capacity.BottomUpCapacity","title":"BottomUpCapacity","text":"<pre><code>BottomUpCapacity(name, configuration_data, processes_data, *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Computes annual capacity additions required to follow an energy consumption trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('f\"{pathway_name}_production_capacity\"' by default).</p> required <code>configuration_data</code> <code>dict</code> <p>Configuration data for the energy pathway from the config file.</p> required <code>processes_data</code> <code>dict</code> <p>Configuration data for all processes from the config file.</p> required <p>Attributes:</p> Name Type Description <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/bottom_up/production_capacity.py</code> <pre><code>def __init__(self, name, configuration_data, processes_data, *args, **kwargs):\n    super().__init__(\n        name=name,\n        model_type=\"custom\",\n        *args,\n        **kwargs,\n    )\n    self.pathway_name = configuration_data[\"name\"]\n    # Inputs\n    self.input_names = {\n        f\"{self.pathway_name}_energy_consumption\": pd.Series([0.0]),\n    }\n\n    for key, val in configuration_data.get(\"inputs\").get(\"technical\", {}).items():\n        # TODO initialize with zeros instead of actual val? How to better get rid of unnecessary variables\n        if (\n            key == f\"{self.pathway_name}_resource_names\"\n            or key == f\"{self.pathway_name}_processes_names\"\n        ):\n            pass  # avoid having strings as variable in gemseo, not needed as variables\n        else:\n            self.input_names[key] = val\n\n    # Outputs\n    self.output_names = {\n        f\"{self.pathway_name}_plant_building_scenario\": pd.Series([0.0]),\n        f\"{self.pathway_name}_energy_production_commissioned\": pd.Series([0.0]),\n        f\"{self.pathway_name}_plant_operating_capacity\": pd.Series([0.0]),\n        f\"{self.pathway_name}_energy_unused\": pd.Series([0.0]),\n    }\n\n    self.resource_keys = (\n        configuration_data.get(\"inputs\")\n        .get(\"technical\", {})\n        .get(f\"{self.pathway_name}_resource_names\", [])\n    ).copy()\n    self.process_keys = (\n        configuration_data.get(\"inputs\")\n        .get(\"technical\", {})\n        .get(f\"{self.pathway_name}_processes_names\", [])\n    ).copy()\n\n    self.process_resource_keys = {}\n    for process_key in self.process_keys:\n        for key, val in processes_data[process_key].get(\"inputs\").get(\"technical\", {}).items():\n            if key == f\"{process_key}_resource_names\":\n                resources = (\n                    processes_data[process_key]\n                    .get(\"inputs\")\n                    .get(\"technical\", {})\n                    .get(f\"{process_key}_resource_names\", [])\n                ).copy()\n                self.process_resource_keys[process_key] = resources\n            elif key == f\"{process_key}_load_factor\":\n                self.input_names[key] = val\n        self.output_names[f\"{self.pathway_name}_{process_key}_plant_building_scenario\"] = (\n            pd.Series([0.0])\n        )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.bottom_up.production_capacity/#aeromaps.models.impacts.generic_energy_model.bottom_up.production_capacity.BottomUpCapacity.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Compute the annual capacity additions required to follow the energy consumption trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/bottom_up/production_capacity.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"\n    Compute the annual capacity additions required to follow the energy consumption trajectory.\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n    \"\"\"\n    output_data = {}\n\n    # Get the energy consumption trajectory and capacity factor\n    energy_required = input_data.get(f\"{self.pathway_name}_energy_consumption\")\n\n    technology_introduction = input_data.get(\n        f\"{self.pathway_name}_technology_introduction_year\"\n    )\n    technology_introduction_volume = input_data.get(\n        f\"{self.pathway_name}_technology_introduction_volume\"\n    )\n\n    # The hard part in this model is to be able to reconstruct the commissioning history of plants\n    # however, we do not have access to the energy consumption before the scenarios,\n    # which influences the availability of plants, and thus the need to build new ones.\n    # The idea of the code is therefore to construct a virtual energy demand since the technology introduction year,\n    # if needed, and to concatenate it with the real energy demand from the historic start year.\n    # NB: that is transparent for alternative pathways that start after the historic start year.\n    if energy_required.loc[self.historic_start_year] &gt; 1e-9:\n        if not technology_introduction or not technology_introduction_volume:\n            raise ValueError(\n                f\"Technology introduction year and volume for {self.pathway_name} must be specified if there is energy consumption before the historic start year.\"\n            )\n        else:\n            first_plant_year = technology_introduction\n            first_plant_volume = technology_introduction_volume\n            virtual_cagr = (\n                energy_required.loc[self.historic_start_year] / first_plant_volume\n            ) ** (1 / (self.historic_start_year - first_plant_year)) - 1\n            # populate the energy_required Series with virtual years\n            for virtual_year in range(first_plant_year, self.historic_start_year):\n                virtual_demand = first_plant_volume * (1 + virtual_cagr) ** (\n                    virtual_year - first_plant_year\n                )\n                energy_required.loc[virtual_year] = virtual_demand\n            energy_required.sort_index(inplace=True)\n\n    years = energy_required.index\n\n    plant_building_scenario = pd.Series(np.zeros(len(years)), years)\n    plant_available_scenario = pd.Series(np.zeros(len(years)), years)\n    energy_produced = pd.Series(np.zeros(len(years)), years)\n    energy_production_commissioned = pd.Series(np.zeros(len(years)), years)\n    energy_unused = pd.Series(np.zeros(len(years)), years)\n\n    for year in years:\n        # getting entry into service (eis) plant charcteristics\n        plant_load_factor = _get_value_for_year(\n            input_data.get(f\"{self.pathway_name}_eis_plant_load_factor\"), year, 1\n        )\n        plant_lifespan = _get_value_for_year(\n            input_data.get(f\"{self.pathway_name}_eis_plant_lifespan\"), year, 25\n        )\n\n        missing_production = energy_required.fillna(0)[year] - energy_produced.fillna(0)[year]\n        if missing_production &lt;= 0.0:\n            energy_unused[year] = missing_production\n        else:\n            # Calculate the required capacity to meet the energy demand\n            for key in self.resource_keys:\n                if f\"{key}_load_factor\" in input_data:\n                    resource_load_factor = _get_value_for_year(\n                        input_data.get(f\"{key}_load_factor\"), year\n                    )\n                    if resource_load_factor is not None:\n                        plant_load_factor = min(plant_load_factor, resource_load_factor)\n\n            energy_production_commissioned[year] = missing_production\n\n            required_capacity = (\n                missing_production / plant_load_factor\n            )  # Absolute output in MJ per year\n            plant_building_scenario[year] += required_capacity\n            # Update the available capacity and production for plant lifespan\n            plant_available_scenario.loc[year : year + plant_lifespan - 1] += required_capacity\n            energy_produced.loc[year : year + plant_lifespan - 1] += missing_production\n\n    # Warning for years where there is an excess of energy production\n    if (energy_unused &lt; 0).any():\n        years_excess = energy_unused.index[energy_unused &lt; 0].tolist()\n        print(\n            f\"\u26a0\ufe0f Warning: excess {self.pathway_name} production in years: {years_excess}. Scaling down.\"\n        )\n\n    # computing additions for processes\n    for process_key in self.process_keys:\n        process_building_scenario = pd.Series(np.zeros(len(years)), years)\n        for year in years:\n            process_load_factor = _get_value_for_year(\n                input_data.get(f\"{process_key}_load_factor\", 1), year\n            )\n            for resource in self.process_resource_keys[process_key]:\n                if f\"{resource}_load_factor\" in input_data:\n                    resource_load_factor = _get_value_for_year(\n                        input_data.get(f\"{resource}_load_factor\"), year\n                    )\n                    if resource_load_factor is not None:\n                        process_load_factor = min(process_load_factor, resource_load_factor)\n            process_building_scenario[year] = (\n                energy_production_commissioned[year] / process_load_factor\n            )\n        process_building_scenario = process_building_scenario.loc[\n            self.prospection_start_year : self.end_year\n        ]\n        output_data.update(\n            {\n                f\"{self.pathway_name}_{process_key}_plant_building_scenario\": process_building_scenario\n            }\n        )\n\n    # restrict the outputs to prospective years\n    plant_building_scenario = plant_building_scenario.loc[\n        self.prospection_start_year : self.end_year\n    ]\n    plant_available_scenario = plant_available_scenario.loc[\n        self.prospection_start_year : self.end_year\n    ]\n    energy_unused = energy_unused.loc[self.prospection_start_year : self.end_year]\n    energy_production_commissioned = energy_production_commissioned.loc[\n        self.prospection_start_year : self.end_year\n    ]\n\n    output_data.update(\n        {\n            f\"{self.pathway_name}_plant_building_scenario\": plant_building_scenario,\n            f\"{self.pathway_name}_energy_production_commissioned\": energy_production_commissioned,\n            f\"{self.pathway_name}_plant_operating_capacity\": plant_available_scenario,\n            f\"{self.pathway_name}_energy_unused\": -energy_unused,\n        }\n    )\n\n    self._store_outputs(output_data)\n\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_factory/","title":"<code>aeromaps.models.impacts.generic_energy_model.common.energy_carriers_factory</code>","text":"<p>Factory to create energy carriers models based on yaml configuration files.</p>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_factory/#aeromaps.models.impacts.generic_energy_model.common.energy_carriers_factory.AviationEnergyCarriersFactory","title":"AviationEnergyCarriersFactory","text":"<p>Factory to create energy carriers models based on yaml configuration files.</p>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_factory/#aeromaps.models.impacts.generic_energy_model.common.energy_carriers_factory.AviationEnergyCarriersFactory.create_carrier","title":"create_carrier  <code>staticmethod</code>","text":"<pre><code>create_carrier(pathway_name, energy_carriers_data, resources_data, process_data)\n</code></pre> <p>Create energy carrier models based on the configuration data.</p> <p>Parameters:</p> Name Type Description Default <code>pathway_name</code> <code>str</code> <p>Name of the energy pathway to create models for.</p> required <code>energy_carriers_data</code> <code>dict</code> <p>Configuration data for energy carriers.</p> required <code>resources_data</code> <code>dict</code> <p>Configuration data for energy resources.</p> required <code>process_data</code> <code>dict</code> <p>Configuration data for processes.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of instantiated energy carrier models.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/common/energy_carriers_factory.py</code> <pre><code>@staticmethod\ndef create_carrier(pathway_name, energy_carriers_data, resources_data, process_data):\n    \"\"\"\n    Create energy carrier models based on the configuration data.\n\n    Parameters\n    ----------\n    pathway_name : str\n        Name of the energy pathway to create models for.\n    energy_carriers_data : dict\n        Configuration data for energy carriers.\n    resources_data : dict\n        Configuration data for energy resources.\n    process_data : dict\n        Configuration data for processes.\n\n    Returns\n    -------\n    dict\n        Dictionary of instantiated energy carrier models.\n    \"\"\"\n    pathway_data = energy_carriers_data[pathway_name]\n    environmental_model_type = pathway_data[\"environmental_model\"]\n    cost_model_type = pathway_data[\"cost_model\"]\n    # case distinction between energy model types\n    # TODO split the config file into two separate files here instead in the inits ?\n    models = {}\n    if environmental_model_type == \"top-down\":\n        models.update(\n            {\n                f\"{pathway_name}_top_down_unit_environmental\": TopDownEnvironmental(\n                    f\"{pathway_name}_top_down_unit_environmental\",\n                    pathway_data,\n                    resources_data,\n                    process_data,\n                )\n            }\n        )\n    elif environmental_model_type == \"bottom-up\":\n        models.update(\n            {\n                f\"{pathway_name}_bottom_up_unit_environmental\": BottomUpEnvironmental(\n                    f\"{pathway_name}_bottom_up_unit_environmental\",\n                    pathway_data,\n                    resources_data,\n                    process_data,\n                )\n            }\n        )\n    else:\n        raise ValueError(f\"Unsupported environmental model type: {environmental_model_type}\")\n    if cost_model_type == \"top-down\":\n        models.update(\n            {\n                f\"{pathway_name}_top_down_unit_cost\": TopDownCost(\n                    f\"{pathway_name}_top_down_unit_cost\",\n                    pathway_data,\n                    resources_data,\n                    process_data,\n                )\n            }\n        )\n    elif cost_model_type == \"bottom-up\":\n        models.update(\n            {\n                f\"{pathway_name}_bottom_up_unit_cost\": BottomUpCost(\n                    f\"{pathway_name}_bottom_up_unit_cost\",\n                    pathway_data,\n                    resources_data,\n                    process_data,\n                )\n            }\n        )\n    else:\n        raise ValueError(f\"Unsupported cost model type: {cost_model_type}\")\n    # add capacity model\n    if environmental_model_type == \"bottom-up\" or cost_model_type == \"bottom-up\":\n        models.update(\n            {\n                f\"{pathway_name}_bottom_up_capacity\": BottomUpCapacity(\n                    f\"{pathway_name}_bottom_up_capacity\", pathway_data, process_data\n                )\n            }\n        )\n    if pathway_data.get(\"abatement_cost\"):\n        if cost_model_type != \"bottom-up\":\n            raise ValueError(\n                \"Abatement cost model can only be used with bottom-up cost models.\"\n            )\n        if environmental_model_type != \"bottom-up\":\n            print(\n                \"\u26a0\ufe0f Warning: Using Top-Down environmental model for abatement cost. Not recommended.\"\n            )\n        # add abatement cost and effective models\n        models.update(\n            {\n                f\"{pathway_name}_bottom_up_abatement_cost\": EnergyAbatementCost(\n                    f\"{pathway_name}_bottom_up_abatement_cost\",\n                    pathway_name,\n                    pathway_data,\n                ),\n                f\"{pathway_name}_abatement_effective\": EnergyAbatementEffective(\n                    f\"{pathway_name}_abatement_effective\",\n                    pathway_name,\n                ),\n            }\n        )\n    if pathway_data.get(\"abatement_cost_reference\"):\n        models.update(\n            {\n                f\"{pathway_name}_abatement_cost_reference\": ReferenceAbatementCost(\n                    f\"{pathway_name}_abatement_cost_reference\",\n                    pathway_name,\n                    pathway_data,\n                )\n            }\n        )\n    return models\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_factory/#aeromaps.models.impacts.generic_energy_model.common.energy_carriers_factory.AviationEnergyCarriersFactory.instantiate_energy_carriers_models","title":"instantiate_energy_carriers_models  <code>staticmethod</code>","text":"<pre><code>instantiate_energy_carriers_models(energy_carriers_data, pathways_manager)\n</code></pre> <p>Instantiates energy carriers related models. Energy use choice, means, mean LHV, ...</p> <p>Parameters:</p> Name Type Description Default <code>energy_carriers_data</code> <code>dict</code> <p>Configuration data for energy carriers.</p> required <code>pathways_manager</code> <code>PathwaysManager</code> <p>Manager for handling energy pathways.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of instantiated energy carriers models.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/common/energy_carriers_factory.py</code> <pre><code>@staticmethod\ndef instantiate_energy_carriers_models(energy_carriers_data, pathways_manager):\n    \"\"\"\n    Instantiates energy carriers related models. Energy use choice, means, mean LHV, ...\n\n    Parameters\n    ----------\n    energy_carriers_data : dict\n        Configuration data for energy carriers.\n    pathways_manager : PathwaysManager\n        Manager for handling energy pathways.\n\n    Returns\n    -------\n    dict\n        Dictionary of instantiated energy carriers models.\n    \"\"\"\n    return {\n        \"energy_use_choice\": EnergyUseChoice(\n            \"energy_use_choice\", energy_carriers_data, pathways_manager\n        ),\n        \"energy_carriers_means\": EnergyCarriersMeans(\n            \"energy_carriers_means\", energy_carriers_data, pathways_manager\n        ),\n        \"energy_carriers_mean_lhv\": EnergyCarriersMeanLHV(\"energy_carriers_mean_lhv\"),\n    }\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_factory/#aeromaps.models.impacts.generic_energy_model.common.energy_carriers_factory.AviationEnergyCarriersFactory.instantiate_resource_consumption_models","title":"instantiate_resource_consumption_models  <code>staticmethod</code>","text":"<pre><code>instantiate_resource_consumption_models(resources_data, pathways_manager)\n</code></pre> <p>Instantiates energy resource consumption models.</p> <p>Parameters:</p> Name Type Description Default <code>resources_data</code> <code>dict</code> <p>Configuration data for energy resources.</p> required <code>pathways_manager</code> <code>PathwaysManager</code> <p>Manager for handling energy pathways.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of instantiated energy resource consumption models.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/common/energy_carriers_factory.py</code> <pre><code>@staticmethod\ndef instantiate_resource_consumption_models(resources_data, pathways_manager):\n    \"\"\"\n    Instantiates energy resource consumption models.\n\n    Parameters\n    ----------\n    resources_data : dict\n        Configuration data for energy resources.\n    pathways_manager : PathwaysManager\n        Manager for handling energy pathways.\n\n    Returns\n    -------\n    dict\n        Dictionary of instantiated energy resource consumption models.\n    \"\"\"\n    models = {}\n    for resource in resources_data.keys():\n        models.update(\n            {\n                f\"{resource}_consumption\": EnergyResourceConsumption(\n                    f\"{resource}_consumption\", resources_data[resource], pathways_manager\n                )\n            }\n        )\n    models.update(\n        {\n            \"overall_resources_consumption\": OverallResourcesConsumption(\n                \"overall_resources_consumption\",\n                resources_data,\n            ),\n        }\n    )\n    return models\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_manager/","title":"<code>aeromaps.models.impacts.generic_energy_model.common.energy_carriers_manager</code>","text":""},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_manager/#aeromaps.models.impacts.generic_energy_model.common.energy_carriers_manager.EnergyCarrierMetadata","title":"EnergyCarrierMetadata  <code>dataclass</code>","text":"<pre><code>EnergyCarrierMetadata(name=None, aircraft_type=None, default=False, mandate_type=None, energy_origin=None, resources_used=None, resources_used_processes=None, cost_model=None, environmental_model=None)\n</code></pre> <p>Dataclass to hold metadata for an energy carrier.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the energy carrier.</p> <code>aircraft_type</code> <code>str</code> <p>Type of aircraft the energy carrier is associated with.</p> <code>default</code> <code>bool</code> <p>Indicates if this is the default energy carrier for the aircraft type.</p> <code>mandate_type</code> <code>str</code> <p>Type of mandate the energy carrier obeys to (share, volume)</p> <code>energy_origin</code> <code>str</code> <p>Origin of the energy (e.g., renewable, fossil).</p> <code>resources_used</code> <code>List[str]</code> <p>List of resources used by the energy carrier.</p> <code>resources_used_processes</code> <code>dict</code> <p>Dictionary mapping resources used by associated processes.</p> <code>cost_model</code> <code>str</code> <p>Type of cost model used (e.g., top-down, bottom-up).</p> <code>environmental_model</code> <code>str</code> <p>Type of environmental model used (e.g., top-down, bottom-up).</p>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_manager/#aeromaps.models.impacts.generic_energy_model.common.energy_carriers_manager.EnergyCarrierManager","title":"EnergyCarrierManager","text":"<pre><code>EnergyCarrierManager(carriers=None)\n</code></pre> <p>Manager class to handle a collection of energy carriers and provide methods to add and retrieve them based on various criteria.</p> <p>Attributes:</p> Name Type Description <code>carriers</code> <code>List[EnergyCarrierMetadata]</code> <p>List of energy carrier metadata instances.</p> <p>Initialize the EnergyCarrierManager with an optional list of energy carriers.</p> <p>Parameters:</p> Name Type Description Default <code>carriers</code> <code>List[EnergyCarrierMetadata]</code> <p>Initial list of energy carrier metadata instances.</p> <code>None</code> Source code in <code>aeromaps/models/impacts/generic_energy_model/common/energy_carriers_manager.py</code> <pre><code>def __init__(self, carriers: List[EnergyCarrierMetadata] = None):\n    \"\"\"\n    Initialize the EnergyCarrierManager with an optional list of energy carriers.\n\n    Parameters\n    ----------\n    carriers : List[EnergyCarrierMetadata], optional\n        Initial list of energy carrier metadata instances.\n    \"\"\"\n    self.carriers = carriers if carriers is not None else []\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_manager/#aeromaps.models.impacts.generic_energy_model.common.energy_carriers_manager.EnergyCarrierManager.add","title":"add","text":"<pre><code>add(carrier)\n</code></pre> <p>Add a new energy carrier to the manager.</p> <p>Parameters:</p> Name Type Description Default <code>carrier</code> <code>EnergyCarrierMetadata</code> <p>Energy carrier metadata instance to add.</p> required Source code in <code>aeromaps/models/impacts/generic_energy_model/common/energy_carriers_manager.py</code> <pre><code>def add(self, carrier: EnergyCarrierMetadata):\n    \"\"\"\n    Add a new energy carrier to the manager.\n\n    Parameters\n    ----------\n    carrier\n        Energy carrier metadata instance to add.\n    \"\"\"\n    self.carriers.append(carrier)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_manager/#aeromaps.models.impacts.generic_energy_model.common.energy_carriers_manager.EnergyCarrierManager.get","title":"get","text":"<pre><code>get(**criteria)\n</code></pre> <p>Retrieve energy carriers that match all specified criteria.</p> <p>Parameters:</p> Name Type Description Default <code>criteria</code> <p>Keyword arguments used to match attributes of energy carriers; only carriers matching all provided criteria are returned.</p> <code>{}</code> <p>Returns:</p> Type Description <code>matches</code> <p>Energy carrier metadata instances that match the given criteria.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/common/energy_carriers_manager.py</code> <pre><code>def get(self, **criteria) -&gt; List[EnergyCarrierMetadata]:\n    \"\"\"\n    Retrieve energy carriers that match all specified criteria.\n\n    Parameters\n    ----------\n    criteria\n        Keyword arguments used to match attributes of energy carriers; only carriers matching all provided criteria are returned.\n\n    Returns\n    -------\n    matches\n        Energy carrier metadata instances that match the given criteria.\n    \"\"\"\n    return [\n        c\n        for c in self.carriers\n        if all(\n            val in getattr(c, attr, {}).values()\n            if isinstance(getattr(c, attr, None), dict)\n            else val in getattr(c, attr, [])\n            if isinstance(getattr(c, attr, None), list)\n            else getattr(c, attr, None) == val\n            for attr, val in criteria.items()\n        )\n    ]\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_manager/#aeromaps.models.impacts.generic_energy_model.common.energy_carriers_manager.EnergyCarrierManager.get_all","title":"get_all","text":"<pre><code>get_all()\n</code></pre> <p>Return all energy carriers managed by this object.</p> <p>Returns:</p> Type Description <code>carriers</code> <p>All energy carrier metadata instances stored in the manager.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/common/energy_carriers_manager.py</code> <pre><code>def get_all(self):\n    \"\"\"\n    Return all energy carriers managed by this object.\n\n    Returns\n    -------\n    carriers\n        All energy carrier metadata instances stored in the manager.\n    \"\"\"\n    return self.carriers\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_manager/#aeromaps.models.impacts.generic_energy_model.common.energy_carriers_manager.EnergyCarrierManager.get_all_types","title":"get_all_types","text":"<pre><code>get_all_types(parameter)\n</code></pre> <p>Retrieve unique values of a specified attribute across all energy carriers.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>str</code> <p>Name of the attribute to aggregate unique values for.</p> required <p>Returns:</p> Type Description <code>values</code> <p>Unique values of the specified parameter across all energy carriers.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/common/energy_carriers_manager.py</code> <pre><code>def get_all_types(self, parameter: str) -&gt; List:\n    \"\"\"\n    Retrieve unique values of a specified attribute across all energy carriers.\n\n    Parameters\n    ----------\n    parameter\n        Name of the attribute to aggregate unique values for.\n\n    Returns\n    -------\n    values\n        Unique values of the specified parameter across all energy carriers.\n    \"\"\"\n    return list(\n        {\n            getattr(carrier, parameter, None)\n            for carrier in self.carriers\n            if getattr(carrier, parameter, None) is not None\n        }\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_means/","title":"<code>aeromaps.models.impacts.generic_energy_model.common.energy_carriers_means</code>","text":"<p>energy_carriers_means</p> <p>======================= This module contains models to compute mean emissions and costs</p>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_means/#aeromaps.models.impacts.generic_energy_model.common.energy_carriers_means.EnergyCarriersMeans","title":"EnergyCarriersMeans","text":"<pre><code>EnergyCarriersMeans(name, configuration_data, pathways_manager, *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>This model loops through the pathways and computes mean emissions</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('energy_carriers_means' by default).</p> required <code>configuration_data</code> <code>dict</code> <p>Dictionary containing generic pathways configuration data.</p> required <code>pathways_manager</code> <code>PathwaysManager</code> <p>Instance of the PathwaysManager containing all defined energy pathways.</p> required <p>Attributes:</p> Name Type Description <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/common/energy_carriers_means.py</code> <pre><code>def __init__(\n    self,\n    name,\n    configuration_data,\n    pathways_manager,\n    *args,\n    **kwargs,\n):\n    super().__init__(\n        name=name,\n        model_type=\"custom\",\n        *args,\n        **kwargs,\n    )\n\n    self.pathways_manager = pathways_manager\n\n    self.input_names = {}\n    self.output_names = {}\n\n    aircraft_types = [\"dropin_fuel\", \"hydrogen\", \"electric\"]\n\n    for aircraft_type in aircraft_types:\n        self.output_names.update(\n            {\n                f\"{aircraft_type}_mean_co2_emission_factor\": pd.Series([0.0]),\n                f\"{aircraft_type}_mean_mfsp\": pd.Series([0.0]),\n                f\"{aircraft_type}_mean_net_mfsp\": pd.Series([0.0]),\n                f\"{aircraft_type}_mean_net_mfsp_without_carbon_tax\": pd.Series([0.0]),\n                f\"{aircraft_type}_mean_carbon_tax_supplement\": pd.Series([0.0]),\n                f\"{aircraft_type}_marginal_net_mfsp\": pd.Series([0.0]),\n                f\"{aircraft_type}_mean_unit_subsidy\": pd.Series([0.0]),\n                f\"{aircraft_type}_mean_unit_tax\": pd.Series([0.0]),\n                f\"{aircraft_type}_mean_unit_carbon_tax\": pd.Series([0.0]),\n            }\n        )\n        for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n            # check if the energy origin is used for this pathway type\n            if self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            ):\n                self.output_names.update(\n                    {\n                        f\"{aircraft_type}_{energy_origin}_mean_co2_emission_factor\": pd.Series(\n                            [0.0]\n                        ),\n                        f\"{aircraft_type}_{energy_origin}_mean_mfsp\": pd.Series([0.0]),\n                        f\"{aircraft_type}_{energy_origin}_mean_net_mfsp\": pd.Series([0.0]),\n                        f\"{aircraft_type}_{energy_origin}_mean_net_mfsp_without_carbon_tax\": pd.Series(\n                            [0.0]\n                        ),\n                        f\"{aircraft_type}_{energy_origin}_mean_carbon_tax_supplement\": pd.Series(\n                            [0.0]\n                        ),\n                        f\"{aircraft_type}_{energy_origin}_marginal_net_mfsp\": pd.Series([0.0]),\n                        f\"{aircraft_type}_{energy_origin}_mean_unit_subsidy\": pd.Series([0.0]),\n                        f\"{aircraft_type}_{energy_origin}_mean_unit_tax\": pd.Series([0.0]),\n                        f\"{aircraft_type}_{energy_origin}_mean_unit_carbon_tax\": pd.Series(\n                            [0.0]\n                        ),\n                    }\n                )\n\n        for pathway in self.pathways_manager.get(aircraft_type=aircraft_type):\n            self.input_names.update(\n                {\n                    f\"{pathway.name}_share_{aircraft_type}\": pd.Series([0.0]),\n                    f\"{pathway.name}_mean_co2_emission_factor\": pd.Series([0.0]),\n                    f\"{pathway.name}_net_mfsp\": pd.Series([0.0]),\n                    f\"{pathway.name}_net_mfsp_without_carbon_tax\": pd.Series([0.0]),\n                    f\"{pathway.name}_mean_mfsp\": pd.Series([0.0]),\n                    f\"{pathway.name}_share_{aircraft_type}_{pathway.energy_origin}\": pd.Series(\n                        [0.0]\n                    ),\n                    f\"{pathway.name}_mean_unit_subsidy\": pd.Series([0.0]),\n                    f\"{pathway.name}_mean_unit_tax\": pd.Series([0.0]),\n                    f\"{pathway.name}_mean_unit_carbon_tax\": pd.Series([0.0]),\n                }\n            )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_means/#aeromaps.models.impacts.generic_energy_model.common.energy_carriers_means.EnergyCarriersMeans.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>This function loops through different energy types and computes the mean emissions and costs TODO: SPLIT COST AND EMISSIONS</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/common/energy_carriers_means.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"\n    This function loops through different energy types and computes the mean emissions and costs\n    TODO: SPLIT COST AND EMISSIONS\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n    \"\"\"\n\n    output_data = {}\n\n    aircraft_types = [\"dropin_fuel\", \"hydrogen\", \"electric\"]\n\n    for aircraft_type in aircraft_types:\n        # intialize the mean values for the aircraft type\n\n        mean_emission_factor = get_default_series(self.historic_start_year, self.end_year)\n        mean_mfsp = get_default_series(self.historic_start_year, self.end_year)\n        mean_net_mfsp = get_default_series(self.historic_start_year, self.end_year)\n        mean_net_mfsp_without_carbon_tax = get_default_series(\n            self.historic_start_year, self.end_year\n        )\n        mean_carbon_tax_supplement = get_default_series(self.historic_start_year, self.end_year)\n        marginal_net_mfsp = get_default_series(self.historic_start_year, self.end_year)\n        cumulative_share = get_default_series(self.historic_start_year, self.end_year)\n        mean_unit_subsidy = get_default_series(self.historic_start_year, self.end_year)\n        mean_unit_tax = get_default_series(self.historic_start_year, self.end_year)\n        mean_unit_carbon_tax = get_default_series(self.historic_start_year, self.end_year)\n\n        for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n            # Get the pathways for this aircraft type and energy origin\n            pathways = self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            )\n            if pathways:\n                origin_mean_emission_factor = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                origin_mean_mfsp = get_default_series(self.historic_start_year, self.end_year)\n                origin_mean_net_mfsp = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                origin_mean_net_mfsp_without_carbon_tax = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                origin_mean_carbon_tax_supplement = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                origin_marginal_net_mfsp = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                origin_cumulative_share = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                origin_mean_unit_subsidy = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                origin_mean_unit_tax = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                origin_mean_unit_carbon_tax = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n\n                for pathway in pathways:\n                    share = input_data[f\"{pathway.name}_share_{aircraft_type}\"]\n                    origin_share = input_data[\n                        f\"{pathway.name}_share_{aircraft_type}_{energy_origin}\"\n                    ]\n                    cumulative_share = cumulative_share + share.fillna(0) / 100\n                    origin_cumulative_share = (\n                        origin_cumulative_share + origin_share.fillna(0) / 100\n                    )\n\n                    # Emission factors\n\n                    pathway_emission_factor = input_data[\n                        f\"{pathway.name}_mean_co2_emission_factor\"\n                    ]\n                    mean_emission_factor += (pathway_emission_factor * share).fillna(0) / 100\n                    origin_mean_emission_factor += (\n                        pathway_emission_factor * origin_share\n                    ).fillna(0) / 100\n\n                    # MFSP and costs\n                    pathway_mfsp = input_data[f\"{pathway.name}_mean_mfsp\"]\n                    mean_mfsp += (pathway_mfsp * share).fillna(0) / 100\n                    origin_mean_mfsp += (pathway_mfsp * origin_share).fillna(0) / 100\n\n                    pathway_net_mfsp = input_data[f\"{pathway.name}_net_mfsp\"]\n                    mean_net_mfsp += (pathway_net_mfsp * share).fillna(0) / 100\n                    origin_mean_net_mfsp += (pathway_net_mfsp * origin_share).fillna(0) / 100\n\n                    pathway_net_mfsp_without_carbon_tax = input_data[\n                        f\"{pathway.name}_net_mfsp_without_carbon_tax\"\n                    ]\n                    mean_net_mfsp_without_carbon_tax += (\n                        pathway_net_mfsp_without_carbon_tax * share\n                    ).fillna(0) / 100\n                    origin_mean_net_mfsp_without_carbon_tax += (\n                        pathway_net_mfsp_without_carbon_tax * origin_share\n                    ).fillna(0) / 100\n\n                    mean_carbon_tax_supplement += (\n                        (pathway_net_mfsp - pathway_net_mfsp_without_carbon_tax) * share\n                    ).fillna(0) / 100\n                    origin_mean_carbon_tax_supplement += (\n                        (pathway_net_mfsp - pathway_net_mfsp_without_carbon_tax) * origin_share\n                    ).fillna(0) / 100\n\n                    pathway_unit_subsidy = input_data[f\"{pathway.name}_mean_unit_subsidy\"]\n                    mean_unit_subsidy += (pathway_unit_subsidy * share).fillna(0) / 100\n                    origin_mean_unit_subsidy += (pathway_unit_subsidy * origin_share).fillna(\n                        0\n                    ) / 100\n\n                    pathway_unit_tax = input_data[f\"{pathway.name}_mean_unit_tax\"]\n                    mean_unit_tax += (pathway_unit_tax * share).fillna(0) / 100\n                    origin_mean_unit_tax += (pathway_unit_tax * origin_share).fillna(0) / 100\n\n                    pathway_unit_carbon_tax = input_data[f\"{pathway.name}_mean_unit_carbon_tax\"]\n                    mean_unit_carbon_tax += (pathway_unit_carbon_tax * share).fillna(0) / 100\n                    origin_mean_unit_carbon_tax += (\n                        pathway_unit_carbon_tax * origin_share\n                    ).fillna(0) / 100\n\n                    # compute the marginal net MFSP for each aircraft type: the most expensive pathways each year\n                    marginal_net_mfsp = marginal_net_mfsp.where(\n                        marginal_net_mfsp\n                        &gt; pathway_net_mfsp.reindex(marginal_net_mfsp.index).fillna(0),\n                        pathway_net_mfsp.reindex(marginal_net_mfsp.index).fillna(0),\n                    )\n                    origin_marginal_net_mfsp = origin_marginal_net_mfsp.where(\n                        origin_marginal_net_mfsp\n                        &gt; pathway_net_mfsp.reindex(origin_marginal_net_mfsp.index).fillna(0),\n                        pathway_net_mfsp.reindex(origin_marginal_net_mfsp.index).fillna(0),\n                    )\n\n                origin_valid_years = origin_cumulative_share.replace(0, np.nan)\n\n                output_data[f\"{aircraft_type}_{energy_origin}_mean_co2_emission_factor\"] = (\n                    origin_mean_emission_factor * origin_valid_years\n                )\n                output_data[f\"{aircraft_type}_{energy_origin}_mean_mfsp\"] = (\n                    origin_mean_mfsp * origin_valid_years\n                )\n                output_data[f\"{aircraft_type}_{energy_origin}_mean_net_mfsp\"] = (\n                    origin_mean_net_mfsp * origin_valid_years\n                )\n                output_data[\n                    f\"{aircraft_type}_{energy_origin}_mean_net_mfsp_without_carbon_tax\"\n                ] = origin_mean_net_mfsp_without_carbon_tax * origin_valid_years\n                output_data[f\"{aircraft_type}_{energy_origin}_mean_carbon_tax_supplement\"] = (\n                    origin_mean_carbon_tax_supplement * origin_valid_years\n                )\n                output_data[f\"{aircraft_type}_{energy_origin}_marginal_net_mfsp\"] = (\n                    origin_marginal_net_mfsp * origin_valid_years\n                )\n                # Store mean unit subsidy, tax, carbon tax\n                output_data[f\"{aircraft_type}_{energy_origin}_mean_unit_subsidy\"] = (\n                    origin_mean_unit_subsidy * origin_valid_years\n                )\n                output_data[f\"{aircraft_type}_{energy_origin}_mean_unit_tax\"] = (\n                    origin_mean_unit_tax * origin_valid_years\n                )\n                output_data[f\"{aircraft_type}_{energy_origin}_mean_unit_carbon_tax\"] = (\n                    origin_mean_unit_carbon_tax * origin_valid_years\n                )\n\n        # if no energy consumption for any year, replace by nan. if all pathways not equal to 100%, triggers warning\n        valid_years = cumulative_share.replace(0, np.nan)\n        # check that there are only ones in the cumulative share\n\n        faulty_years = valid_years[valid_years.notna() &amp; (valid_years.round(3) != 1.000)].index\n        if not faulty_years.empty:\n            warnings.warn(\n                f\"AeroMAPS internal error: sum of pathway shares for {aircraft_type} is not equal to 100% in the following years: {faulty_years.tolist()}\"\n            )\n\n        # store means in the inputs data, and multiply by cumulative share to set nans when there s no energy consumption\n        output_data[f\"{aircraft_type}_mean_co2_emission_factor\"] = (\n            mean_emission_factor * valid_years\n        )\n        output_data[f\"{aircraft_type}_mean_mfsp\"] = mean_mfsp * valid_years\n        output_data[f\"{aircraft_type}_mean_net_mfsp\"] = mean_net_mfsp * valid_years\n        output_data[f\"{aircraft_type}_mean_net_mfsp_without_carbon_tax\"] = (\n            mean_net_mfsp_without_carbon_tax * valid_years\n        )\n        output_data[f\"{aircraft_type}_mean_carbon_tax_supplement\"] = (\n            mean_carbon_tax_supplement * valid_years\n        )\n        output_data[f\"{aircraft_type}_marginal_net_mfsp\"] = marginal_net_mfsp * valid_years\n        # Store mean unit subsidy, tax, carbon tax\n        output_data[f\"{aircraft_type}_mean_unit_subsidy\"] = mean_unit_subsidy * valid_years\n        output_data[f\"{aircraft_type}_mean_unit_tax\"] = mean_unit_tax * valid_years\n        output_data[f\"{aircraft_type}_mean_unit_carbon_tax\"] = (\n            mean_unit_carbon_tax * valid_years\n        )\n\n    # get output data in the means\n    self._store_outputs(output_data)\n\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_means/#aeromaps.models.impacts.generic_energy_model.common.energy_carriers_means.EnergyCarriersMassicShares","title":"EnergyCarriersMassicShares","text":"<pre><code>EnergyCarriersMassicShares(name='energy_carriers_massic_shares', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>This model computes the massic shares of each pathway using its lhv and its energy consumption</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('energy_carriers_massic_shares' by default).</p> <code>'energy_carriers_massic_shares'</code> <p>Attributes:</p> Name Type Description <code>pathways_manager</code> <code>EnergyCarrierManager</code> <p>Instance of the EnergyCarrierManager containing all defined energy pathways.</p> <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/common/energy_carriers_means.py</code> <pre><code>def __init__(self, name=\"energy_carriers_massic_shares\", *args, **kwargs):\n    super().__init__(name=name, model_type=\"custom\", *args, **kwargs)\n    self.pathways_manager = None\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_means/#aeromaps.models.impacts.generic_energy_model.common.energy_carriers_means.EnergyCarriersMassicShares.custom_setup","title":"custom_setup","text":"<pre><code>custom_setup()\n</code></pre> <p>Sets up input and output names for the model based on the pathways in the pathways_manager.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>aeromaps/models/impacts/generic_energy_model/common/energy_carriers_means.py</code> <pre><code>def custom_setup(self):\n    \"\"\"\n    Sets up input and output names for the model based on the pathways in the pathways_manager.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    self.input_names = {}\n    self.output_names = {}\n\n    for aircraft_type in self.pathways_manager.get_all_types(\"aircraft_type\"):\n        for pathway in self.pathways_manager.get(aircraft_type=aircraft_type):\n            self.input_names.update(\n                {\n                    f\"{pathway.name}_energy_consumption\": pd.Series([0.0]),\n                    f\"{pathway.name}_lhv\": 0.0,\n                }\n            )\n            self.output_names.update(\n                {\n                    f\"{pathway.name}_mass_consumption\": pd.Series([0.0]),\n                    f\"{pathway.name}_massic_share_{aircraft_type}\": pd.Series([0.0]),\n                    f\"{pathway.name}_massic_share_{aircraft_type}_{pathway.energy_origin}\": pd.Series(\n                        [0.0]\n                    ),\n                }\n            )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_means/#aeromaps.models.impacts.generic_energy_model.common.energy_carriers_means.EnergyCarriersMassicShares.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>This function computes the massic shares of each pathway using its lhv and its energy consumption Shares are given per aircraft type and aircraft type + energy origin</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/common/energy_carriers_means.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"\n    This function computes the massic shares of each pathway using its lhv and its energy consumption\n    Shares are given per aircraft type and aircraft type + energy origin\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n    \"\"\"\n    output_data = {}\n\n    for aircraft_type in self.pathways_manager.get_all_types(\"aircraft_type\"):\n        mass_consumption = sum(\n            input_data[f\"{pathway.name}_energy_consumption\"].fillna(0)\n            / input_data[f\"{pathway.name}_lhv\"]\n            for pathway in self.pathways_manager.get(aircraft_type=aircraft_type)\n        )\n        # initialise the mean values for the aircraft type\n        for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n            # Get the pathways for this aircraft type and energy origin\n            pathways = self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            )\n            if pathways:\n                origin_mass_consumption = sum(\n                    input_data[f\"{pathway.name}_energy_consumption\"].fillna(0)\n                    / input_data[f\"{pathway.name}_lhv\"]\n                    for pathway in pathways\n                )\n\n                for pathway in pathways:\n                    pathway_energy_consumption = input_data[\n                        f\"{pathway.name}_energy_consumption\"\n                    ]\n                    pathway_lhv = input_data[f\"{pathway.name}_lhv\"]\n                    pathway_mass_consumption = (\n                        pathway_energy_consumption / pathway_lhv\n                    ).fillna(0)\n\n                    # compute the massic share for each pathway\n                    origin_massic_share = (\n                        pathway_mass_consumption / origin_mass_consumption\n                    ).fillna(0) * 100\n                    massic_share = (pathway_mass_consumption / mass_consumption).fillna(0) * 100\n\n                    output_data[f\"{pathway.name}_mass_consumption\"] = pathway_mass_consumption\n                    output_data[\n                        f\"{pathway.name}_massic_share_{aircraft_type}_{energy_origin}\"\n                    ] = origin_massic_share\n                    output_data[f\"{pathway.name}_massic_share_{aircraft_type}\"] = massic_share\n\n    self._store_outputs(output_data)\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_means/#aeromaps.models.impacts.generic_energy_model.common.energy_carriers_means.EnergyCarriersMeanLHV","title":"EnergyCarriersMeanLHV","text":"<pre><code>EnergyCarriersMeanLHV(name='energy_carriers_mean_lhv', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>This model computes the mean energy LHV for each aircraft type and energy origin</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('energy_carriers_mean_lhv' by default).</p> <code>'energy_carriers_mean_lhv'</code> <p>Attributes:</p> Name Type Description <code>pathways_manager</code> <code>EnergyCarrierManager</code> <p>Instance of the EnergyCarrierManager containing all defined energy pathways.</p> <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/common/energy_carriers_means.py</code> <pre><code>def __init__(self, name=\"energy_carriers_mean_lhv\", *args, **kwargs):\n    super().__init__(name=name, model_type=\"custom\", *args, **kwargs)\n    self.pathways_manager = None\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_means/#aeromaps.models.impacts.generic_energy_model.common.energy_carriers_means.EnergyCarriersMeanLHV.custom_setup","title":"custom_setup","text":"<pre><code>custom_setup()\n</code></pre> <p>Sets up input and output names for the model based on the pathways in the pathways_manager.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>aeromaps/models/impacts/generic_energy_model/common/energy_carriers_means.py</code> <pre><code>def custom_setup(self):\n    \"\"\"\n    Sets up input and output names for the model based on the pathways in the pathways_manager.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.input_names = {}\n    self.output_names = {}\n\n    for aircraft_type in self.pathways_manager.get_all_types(\"aircraft_type\"):\n        self.output_names.update(\n            {\n                f\"{aircraft_type}_mean_lhv\": pd.Series([0.0]),\n            }\n        )\n        for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n            if self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            ):\n                self.output_names.update(\n                    {\n                        f\"{aircraft_type}_{energy_origin}_mean_lhv\": pd.Series([0.0]),\n                    }\n                )\n\n        for pathway in self.pathways_manager.get(aircraft_type=aircraft_type):\n            self.input_names.update(\n                {\n                    f\"{pathway.name}_lhv\": 0.0,\n                    f\"{pathway.name}_massic_share_{aircraft_type}_{pathway.energy_origin}\": pd.Series(\n                        [0.0]\n                    ),\n                    f\"{pathway.name}_massic_share_{aircraft_type}\": pd.Series([0.0]),\n                }\n            )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_carriers_means/#aeromaps.models.impacts.generic_energy_model.common.energy_carriers_means.EnergyCarriersMeanLHV.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Average H20 emission index calculation. This function computes the mean LHV for each aircraft type and energy origin using the massic shares of each pathway.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/common/energy_carriers_means.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"\n    Average H20 emission index calculation.\n    This function computes the mean LHV for each aircraft type and energy origin using the massic shares of each pathway.\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n\n    \"\"\"\n\n    output_data = {}\n\n    for aircraft_type in self.pathways_manager.get_all_types(\"aircraft_type\"):\n        mean_lhv = get_default_series(self.historic_start_year, self.end_year)\n        cumulative_share = get_default_series(self.historic_start_year, self.end_year)\n        # initialise the mean values for the aircraft type\n        for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n            # Get the pathways for this aircraft type and energy origin\n            pathways = self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            )\n            if pathways:\n                origin_mean_lhv = get_default_series(self.historic_start_year, self.end_year)\n                origin_cumulative_share = get_default_series(\n                    self.historic_start_year, self.end_year\n                )\n                for pathway in pathways:\n                    origin_share = input_data[\n                        f\"{pathway.name}_massic_share_{aircraft_type}_{energy_origin}\"\n                    ]\n                    share = input_data[f\"{pathway.name}_massic_share_{aircraft_type}\"]\n                    origin_cumulative_share = (\n                        origin_cumulative_share + origin_share.fillna(0) / 100\n                    )\n\n                    cumulative_share = cumulative_share + share.fillna(0) / 100\n\n                    pathway_lhv = input_data[f\"{pathway.name}_lhv\"]\n\n                    origin_mean_lhv += (pathway_lhv * origin_share).fillna(0) / 100\n                    mean_lhv += (pathway_lhv * share).fillna(0) / 100\n\n                origin_valid_years = origin_cumulative_share.replace(0, np.nan)\n                valid_years = cumulative_share.replace(0, np.nan)\n\n                output_data[f\"{aircraft_type}_{energy_origin}_mean_lhv\"] = (\n                    origin_mean_lhv * origin_valid_years\n                )\n                output_data[f\"{aircraft_type}_mean_lhv\"] = mean_lhv * valid_years\n\n    self._store_outputs(output_data)\n\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_use_choice/","title":"<code>aeromaps.models.impacts.generic_energy_model.common.energy_use_choice</code>","text":"<p>energy_use_choice</p> <p>===================== Central module with a model to handle pathways interaction.</p>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_use_choice/#aeromaps.models.impacts.generic_energy_model.common.energy_use_choice.EnergyUseChoice","title":"EnergyUseChoice","text":"<pre><code>EnergyUseChoice(name, configuration_data, pathways_manager, *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Central model to define volume consumed of each energy carrier considered depending on the mandate specified and priorities.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('energy_use_choice' by default).</p> required <code>configuration_data</code> <code>dict</code> <p>Configuration data for the energy use choice model.</p> required <code>pathways_manager</code> <code>EnergyCarrierManager</code> <p>Manager containing all energy pathways metadata.</p> required <p>Attributes:</p> Name Type Description <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/common/energy_use_choice.py</code> <pre><code>def __init__(\n    self,\n    name,\n    configuration_data,\n    pathways_manager,\n    *args,\n    **kwargs,\n):\n    super().__init__(\n        name=name,\n        model_type=\"custom\",\n        *args,\n        **kwargs,\n    )\n\n    # get pathways manager to easily access pathways metadata (=NO VARIABLES)\n    # (Caution: use only non coupling attributes as pathways metadata is not a coupling variable)\n    # Coupling variables should go in inputs_names\n    self.pathways_manager = pathways_manager\n\n    # Actual model variables goes in inputs_names\n    self.input_names = {}\n\n    for pathway in self.pathways_manager.get_all():\n        name = pathway.name\n        if pathway.default:\n            # default pathway does not use any mandate even if defined\n            pass\n        if pathway.mandate_type == \"quantity\":\n            self.input_names.update(\n                {\n                    f\"{name}_mandate_quantity\": pd.Series([0.0]),\n                }\n            )\n        elif pathway.mandate_type == \"share\":\n            self.input_names.update(\n                {\n                    f\"{name}_mandate_share\": pd.Series([0.0]),\n                }\n            )\n\n    # Fill and initialize inputs not defined in the yaml file (either user inputs or other models outputs)\n    self.input_names.update(\n        {\n            \"energy_consumption_dropin_fuel\": pd.Series([0.0]),\n            \"energy_consumption_hydrogen\": pd.Series([0.0]),\n            \"energy_consumption_electric\": pd.Series([0.0]),\n            \"energy_consumption\": pd.Series([0.0]),\n            # not handling other energy carriers for now\n        }\n    )\n\n    # Fill in the expected outputs with names from the compute method, initialized with NaN\n    self.output_names = {}\n    for pathway in self.pathways_manager.get_all():\n        self.output_names[f\"{pathway.name}_energy_consumption\"] = pd.Series([0.0])\n        self.output_names[f\"{pathway.name}_share_total_energy\"] = pd.Series([0.0])\n\n    # Fill in expected outputs for different aircraft types\n    for aircraft_type in self.pathways_manager.get_all_types(\"aircraft_type\"):\n        for pathway in self.pathways_manager.get(aircraft_type=aircraft_type):\n            self.output_names[f\"{pathway.name}_share_{aircraft_type}\"] = pd.Series([0.0])\n\n    for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n        self.output_names[f\"{energy_origin}_share_total_energy\"] = pd.Series([0.0])\n        for pathway in self.pathways_manager.get(energy_origin=energy_origin):\n            self.output_names[f\"{pathway.name}_share_{energy_origin}\"] = pd.Series([0.0])\n        for aircraft_type in self.pathways_manager.get_all_types(\"aircraft_type\"):\n            if self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            ):\n                self.output_names[f\"{energy_origin}_share_{aircraft_type}\"] = pd.Series([0.0])\n                self.output_names[f\"{aircraft_type}_share_{energy_origin}\"] = pd.Series([0.0])\n                self.output_names[f\"{aircraft_type}_{energy_origin}_energy_consumption\"] = (\n                    pd.Series([0.0])\n                )\n                for pathway in self.pathways_manager.get(\n                    energy_origin=energy_origin, aircraft_type=aircraft_type\n                ):\n                    self.output_names[\n                        f\"{pathway.name}_share_{aircraft_type}_{energy_origin}\"\n                    ] = pd.Series([0.0])\n\n    # mandatory outputs for aeromaps models to work even if no pathway is defined for a given type\n    self.output_names.update(\n        {\n            \"biomass_share_dropin_fuel\": pd.Series([0.0]),\n            \"electricity_share_dropin_fuel\": pd.Series([0.0]),\n            \"fossil_share_dropin_fuel\": pd.Series([0.0]),\n        }\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common.energy_use_choice/#aeromaps.models.impacts.generic_energy_model.common.energy_use_choice.EnergyUseChoice.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Compute the energy consumption of each energy carrier based on the defined pathways and mandates and priority rules.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/common/energy_use_choice.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"\n    Compute the energy consumption of each energy carrier based on the defined pathways and mandates and priority rules.\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from\n        yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n    \"\"\"\n    # Get inputs from the configuration file\n    output_data = {}\n    # For each energy type, compute an energy quantity to be produced based on priority order.\n\n    for aircraft_type in self.pathways_manager.get_all_types(\"aircraft_type\"):\n        # Get the energy consumption for the given aircraft type\n        try:\n            energy_consumption = input_data[f\"energy_consumption_{aircraft_type}\"]\n        except KeyError:\n            raise KeyError(\n                f\"Aircraft type &lt;{aircraft_type}&gt; specified in energy_carriers_data.yaml not supported by AeroMAPS aircraft models.\"\n            )\n        remaining_energy_consumption = energy_consumption.copy()\n\n        # No need to define pathways if there is no fuel consumption\n        if energy_consumption.notna().any() and energy_consumption.sum() != 0:\n            # Default pathway should be defined\n            type_default_pathway = self.pathways_manager.get(\n                aircraft_type=aircraft_type, default=True\n            )\n            if not type_default_pathway:\n                raise ValueError(\n                    f\"It is mandatory to define a default {aircraft_type} fuel pathway defined in the energy_carriers_data.yaml\"\n                )\n            elif len(type_default_pathway) &gt; 1:\n                raise ValueError(\n                    f\"There should be only one default {aircraft_type} fuel pathway defined in the energy_carriers_data.yaml\"\n                )\n            else:\n                # First case: quantity-defined pathways\n                type_quantity_pathways = self.pathways_manager.get(\n                    aircraft_type=aircraft_type, mandate_type=\"quantity\"\n                )\n                if type_quantity_pathways:\n                    total_quantity = (\n                        sum(\n                            input_data[f\"{pathway.name}_mandate_quantity\"]\n                            for pathway in type_quantity_pathways\n                        )\n                        .reindex(energy_consumption.index)\n                        .fillna(0)\n                    )\n                    if (total_quantity &lt;= energy_consumption.fillna(0)).all():\n                        # If the sum of quantities is less than or equal to the total, keep the quantities as output\n                        for pathway in type_quantity_pathways:\n                            pathway_consumption = input_data[f\"{pathway.name}_mandate_quantity\"]\n                            output_data[f\"{pathway.name}_energy_consumption\"] = (\n                                pathway_consumption\n                            )\n                            remaining_energy_consumption -= pathway_consumption.reindex(\n                                energy_consumption.index\n                            ).fillna(0)\n                    else:\n                        # If the sum exceeds the total, decrease them homogeneously\n                        scaling_factor = pd.Series(\n                            np.where(\n                                total_quantity &gt; remaining_energy_consumption,\n                                remaining_energy_consumption / total_quantity,\n                                1,\n                            ),\n                            index=total_quantity.index,\n                        )\n                        for pathway in type_quantity_pathways:\n                            original = input_data[f\"{pathway.name}_mandate_quantity\"].fillna(0)\n                            pathway_consumption = (original * scaling_factor).fillna(0)\n                            output_data[f\"{pathway.name}_energy_consumption\"] = (\n                                pathway_consumption\n                            )\n                            remaining_energy_consumption -= pathway_consumption.reindex(\n                                energy_consumption.index\n                            ).fillna(0)\n\n                            modified_years = pathway_consumption[\n                                pathway_consumption != original\n                            ]\n\n                            if not modified_years.empty:\n                                msg = (\n                                    f\"\\nThe sum of the quantity-defined {aircraft_type} fuel pathways exceeds the total {aircraft_type} energy consumption.\\n\"\n                                    f\"\u2192 Pathway '{pathway.name}' energy consumption was adjusted in the following years:\\n\"\n                                )\n                                for year in modified_years.index:\n                                    msg += f\"   - {year}: {pathway_consumption[year]:.2e} MJ instead of {original[year]:.2e} MJ\\n\"\n\n                                warnings.warn(msg)\n\n                # Second case : blending mandate pathways\n                type_share_pathways = self.pathways_manager.get(\n                    aircraft_type=aircraft_type, mandate_type=\"share\"\n                )\n                if type_share_pathways:\n                    total_share_quantity = (\n                        sum(\n                            input_data[f\"{pathway.name}_mandate_share\"]\n                            / 100\n                            * energy_consumption\n                            for pathway in type_share_pathways\n                        )\n                        .reindex(energy_consumption.index)\n                        .fillna(0)\n                    )\n                    if (\n                        total_share_quantity.fillna(0) &lt;= remaining_energy_consumption.fillna(0)\n                    ).all():\n                        # If the sum of quantities is less than or equal to the total, keep the quantities as output\n                        for pathway in type_share_pathways:\n                            pathway_consumption = (\n                                input_data[f\"{pathway.name}_mandate_share\"]\n                                / 100\n                                * energy_consumption\n                            )\n                            output_data[f\"{pathway.name}_energy_consumption\"] = (\n                                pathway_consumption\n                            )\n                            remaining_energy_consumption -= pathway_consumption.reindex(\n                                energy_consumption.index\n                            ).fillna(0)\n                    else:\n                        # If the sum exceeds the total, decrease them homogeneously\n                        scaling_factor = pd.Series(\n                            np.where(\n                                total_share_quantity &gt; remaining_energy_consumption,\n                                remaining_energy_consumption / total_share_quantity,\n                                1,\n                            ),\n                            index=total_share_quantity.index,\n                        )\n                        for pathway in type_share_pathways:\n                            original_share = input_data[f\"{pathway.name}_mandate_share\"].fillna(\n                                0\n                            )\n                            pathway_consumption = (\n                                original_share / 100 * energy_consumption * scaling_factor\n                            ).fillna(0)\n                            output_data[f\"{pathway.name}_energy_consumption\"] = (\n                                pathway_consumption\n                            )\n                            remaining_energy_consumption -= pathway_consumption.reindex(\n                                energy_consumption.index\n                            ).fillna(0)\n\n                            modified_years = pathway_consumption.loc[original_share.index][\n                                pathway_consumption.loc[original_share.index]\n                                != (\n                                    original_share\n                                    / 100\n                                    * energy_consumption.loc[original_share.index]\n                                )\n                            ]\n\n                            if not modified_years.empty:\n                                msg = (\n                                    f\"\\nThe sum of the share-defined {aircraft_type} fuel pathways exceeds the total {aircraft_type} energy consumption (minus quantity-based pathways).\\n\"\n                                    f\"\u2192 Pathway '{pathway.name}' share was adjusted in the following years:\\n\"\n                                )\n                                for year in modified_years.index:\n                                    msg += f\"   - {year}: {(pathway_consumption[year] * 100 / energy_consumption[year]):.1f} % instead of {(original_share[year]):.1f} %\\n\"\n\n                                warnings.warn(msg)\n\n                # Third case: default pathway completes to fill the remaining energy consumption\n                pathway = type_default_pathway[0]\n                output_data[f\"{pathway.name}_energy_consumption\"] = (\n                    remaining_energy_consumption.copy()\n                )\n                remaining_energy_consumption -= remaining_energy_consumption\n\n        else:\n            # If there is no energy consumption, set all energy consumption to 0\n            for pathway in self.pathways_manager.get(aircraft_type=aircraft_type):\n                output_data[f\"{pathway.name}_energy_consumption\"] = pd.Series(\n                    [0.0] * (self.end_year - self.historic_start_year + 1),\n                    index=pd.RangeIndex(start=self.historic_start_year, stop=self.end_year + 1),\n                )\n\n    # compute metrics derived from each patwhay consumption\n    total_energy_consumption = input_data[\"energy_consumption\"]\n\n    # Compute share of each pathway in the total energy consumption\n    for pathway in self.pathways_manager.get_all():\n        output_data[f\"{pathway.name}_share_total_energy\"] = (\n            output_data[f\"{pathway.name}_energy_consumption\"] / total_energy_consumption * 100\n        )\n\n    # Compute share of each pathway in a given aircraft type energy consumption\n    for aircraft_type in self.pathways_manager.get_all_types(\"aircraft_type\"):\n        type_energy_consumption = input_data[f\"energy_consumption_{aircraft_type}\"].fillna(0)\n        for pathway in self.pathways_manager.get(aircraft_type=aircraft_type):\n            output_data[f\"{pathway.name}_share_{aircraft_type}\"] = (\n                output_data[f\"{pathway.name}_energy_consumption\"]\n                / type_energy_consumption.replace(0, np.nan)\n                * 100\n            )\n\n    for energy_origin in self.pathways_manager.get_all_types(\"energy_origin\"):\n        # Get the total energy consumption for each energy origin\n        origin_energy_consumption = sum(\n            output_data[f\"{pathway.name}_energy_consumption\"].fillna(0)\n            for pathway in self.pathways_manager.get(energy_origin=energy_origin)\n        )\n        for pathway in self.pathways_manager.get(energy_origin=energy_origin):\n            output_data[f\"{pathway.name}_share_{energy_origin}\"] = (\n                output_data[f\"{pathway.name}_energy_consumption\"]\n                / origin_energy_consumption.replace(0, np.nan)\n                * 100\n            )\n        output_data[f\"{energy_origin}_share_total_energy\"] = (\n            origin_energy_consumption / total_energy_consumption * 100\n        )\n\n        # get detail for each aircraft type\n        for aircraft_type in self.pathways_manager.get_all_types(\"aircraft_type\"):\n            if self.pathways_manager.get(\n                aircraft_type=aircraft_type, energy_origin=energy_origin\n            ):\n                type_energy_consumption = input_data[f\"energy_consumption_{aircraft_type}\"]\n\n                origin_type_energy_consumption = sum(\n                    output_data[f\"{pathway.name}_energy_consumption\"].fillna(0)\n                    for pathway in self.pathways_manager.get(\n                        energy_origin=energy_origin, aircraft_type=aircraft_type\n                    )\n                )\n\n                output_data[f\"{aircraft_type}_{energy_origin}_energy_consumption\"] = (\n                    origin_type_energy_consumption\n                )\n\n                output_data[f\"{energy_origin}_share_{aircraft_type}\"] = (\n                    origin_type_energy_consumption\n                    / type_energy_consumption.replace(0, np.nan)\n                    * 100\n                )\n\n                output_data[f\"{aircraft_type}_share_{energy_origin}\"] = (\n                    origin_type_energy_consumption\n                    / origin_energy_consumption.replace(0, np.nan)\n                    * 100\n                )\n                for pathway in self.pathways_manager.get(\n                    energy_origin=energy_origin, aircraft_type=aircraft_type\n                ):\n                    output_data[f\"{pathway.name}_share_{aircraft_type}_{energy_origin}\"] = (\n                        output_data[f\"{pathway.name}_energy_consumption\"]\n                        / origin_type_energy_consumption.replace(0, np.nan)\n                        * 100\n                    )\n    # Fill with mandatory inputs for aeromaps models (non_co2) to work even if no pathway is defined for a given type\n    mandatory_outputs = [\n        \"biomass_share_dropin_fuel\",\n        \"electricity_share_dropin_fuel\",\n        \"fossil_share_dropin_fuel\",\n    ]\n    for output in mandatory_outputs:\n        if output not in output_data:\n            output_data[output] = pd.Series(\n                0.0, index=range(self.historic_start_year, self.end_year + 1)\n            )\n    # Add all output data in self.df and self.float_outputs\n    self._store_outputs(output_data)\n\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.common/","title":"<code>aeromaps.models.impacts.generic_energy_model.common</code>","text":"<p>common</p> <p>======== Common package for generic energy model implementation, host the factory to instantiate energy carriers based on user-defined configurations and computes energy carriers priorities.</p>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model/","title":"<code>aeromaps.models.impacts.generic_energy_model</code>","text":"generic_energy_model <p>This package contains AeroMAPS' generic energy model for handling user-defined pathways, processes, and energy resources defined in config files.</p>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.top_down.cost/","title":"<code>aeromaps.models.impacts.generic_energy_model.top_down.cost</code>","text":"<p>cost</p> <p>===== Module to compute pathway MFSP and investments using the top-down techno-economic model.</p>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.top_down.cost/#aeromaps.models.impacts.generic_energy_model.top_down.cost.TopDownCost","title":"TopDownCost","text":"<pre><code>TopDownCost(name, configuration_data, resources_data, processes_data, *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Top down unit cost model for energy carriers. It subtracts subsidies from user provided mfsp and adds taxes to it.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('f\"{pathway_name}_top_down_unit_cost\"' by default).</p> required <code>configuration_data</code> <code>dict</code> <p>Configuration data for the energy pathway from the config file.</p> required <code>resources_data</code> <code>dict</code> <p>Configuration data for the energy resources from the config file.</p> required <code>processes_data</code> <code>dict</code> <p>Configuration data for the energy processes from the config file.</p> required <p>Attributes:</p> Name Type Description <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/top_down/cost.py</code> <pre><code>def __init__(\n    self,\n    name,\n    configuration_data,\n    resources_data,\n    processes_data,\n    *args,\n    **kwargs,\n):\n    super().__init__(\n        name=name,\n        model_type=\"custom\",\n        # inputs/outputs are defined in __init__ rather than auto generated from compute() signature\n        *args,\n        **kwargs,\n    )\n    # Get the name of the pathway\n    self.pathway_name = configuration_data[\"name\"]\n\n    # Get the inputs from the configuration file: two options\n    # 1. All inputs of a certain category in the yaml file\n    for key, val in configuration_data.get(\"inputs\").get(\"economics\", {}).items():\n        # TODO initialize with zeros instead of actual val?\n        self.input_names[key] = val\n    for key, val in configuration_data.get(\"inputs\").get(\"technical\", {}).items():\n        # TODO initialize with zeros instead of actual val? How to better get rid of unnecessary variables\n        if (\n            key == f\"{self.pathway_name}_resource_names\"\n            or key == f\"{self.pathway_name}_processes_names\"\n        ):\n            pass  # avoid having strings as variable in gemseo, not needed as variables\n        else:\n            self.input_names[key] = val\n\n    # 2. Set individual inputs, coming either from other models or from the yaml as well\n    self.input_names.update(\n        {\n            \"carbon_tax\": pd.Series([0.0]),\n            f\"{self.pathway_name}_mean_co2_emission_factor\": pd.Series([0.0]),\n        }\n    )\n\n    # 3. Getting resources is a bit more complex as we need to get necessary resources for the pathway\n    self.resource_keys = (\n        configuration_data.get(\"inputs\")\n        .get(\"technical\", {})\n        .get(f\"{self.pathway_name}_resource_names\", [])\n    ).copy()\n\n    for key in self.resource_keys:\n        # Outputs.\n        self.output_names[f\"{self.pathway_name}_excluding_processes_{key}_mean_unit_cost\"] = (\n            pd.Series([0.0])\n        )\n        self.output_names[f\"{self.pathway_name}_excluding_processes_{key}_mean_unit_tax\"] = (\n            pd.Series([0.0])\n        )\n        self.output_names[\n            f\"{self.pathway_name}_excluding_processes_{key}_mean_unit_subsidy\"\n        ] = pd.Series([0.0])\n\n    self.process_keys = (\n        configuration_data.get(\"inputs\")\n        .get(\"technical\", {})\n        .get(f\"{self.pathway_name}_processes_names\", [])\n    ).copy()\n\n    for process_key in self.process_keys:\n        for key, val in processes_data[process_key].get(\"inputs\").get(\"technical\", {}).items():\n            if key == f\"{process_key}_resource_names\":\n                resources = (\n                    processes_data[process_key]\n                    .get(\"inputs\")\n                    .get(\"technical\", {})\n                    .get(f\"{process_key}_resource_names\", [])\n                )\n                self.resource_keys.extend(resources)\n                for resource in resources:\n                    self.output_names[\n                        f\"{self.pathway_name}_{process_key}_{resource}_mean_unit_cost\"\n                    ] = pd.Series([0.0])\n                    self.output_names[\n                        f\"{self.pathway_name}_{process_key}_{resource}_mean_unit_tax\"\n                    ] = pd.Series([0.0])\n                    self.output_names[\n                        f\"{self.pathway_name}_{process_key}_{resource}_mean_unit_subsidy\"\n                    ] = pd.Series([0.0])\n            else:\n                # TODO initialize with zeros instead of actual val?\n                self.input_names[key] = val\n\n        for key, val in processes_data[process_key].get(\"inputs\").get(\"economics\", {}).items():\n            # TODO initialize with zeros instead of actual val?\n            self.input_names[key] = val\n        self.output_names[\n            f\"{self.pathway_name}_{process_key}_mean_unit_cost_without_resources\"\n        ] = pd.Series([0.0])\n        self.output_names[\n            f\"{self.pathway_name}_{process_key}_mean_unit_tax_without_resources\"\n        ] = pd.Series([0.0])\n        self.output_names[\n            f\"{self.pathway_name}_{process_key}_mean_unit_subsidy_without_resources\"\n        ] = pd.Series([0.0])\n\n    # Getting unique resources\n    self.resource_keys = list(set(self.resource_keys))\n\n    # Adding resources-linked inputs and outputs\n    # TODO specify eco/cost as for process\n    for key in self.resource_keys:\n        if f\"{key}_cost\" in resources_data[key][\"specifications\"]:\n            self.input_names[f\"{key}_cost\"] = pd.Series([0.0])\n        if f\"{key}_subsidy\" in resources_data[key][\"specifications\"]:\n            self.input_names[f\"{key}_subsidy\"] = pd.Series([0.0])\n        if f\"{key}_tax\" in resources_data[key][\"specifications\"]:\n            self.input_names[f\"{key}_tax\"] = pd.Series([0.0])\n        # Outputs.\n\n    # Fill in the expected outputs with names from the compute method, initialized with NaN\n    self.output_names.update(\n        {\n            f\"{self.pathway_name}_net_mfsp_without_carbon_tax\": pd.Series([0.0]),\n            f\"{self.pathway_name}_net_mfsp\": pd.Series([0.0]),\n            f\"{self.pathway_name}_mean_mfsp\": pd.Series([0.0]),\n            f\"{self.pathway_name}_mean_unit_tax\": pd.Series([0.0]),\n            f\"{self.pathway_name}_mean_unit_carbon_tax\": pd.Series([0.0]),\n            f\"{self.pathway_name}_mean_unit_subsidy\": pd.Series([0.0]),\n        }\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.top_down.cost/#aeromaps.models.impacts.generic_energy_model.top_down.cost.TopDownCost.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Compute the top-down cost for the energy pathway.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/top_down/cost.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"\n    Compute the top-down cost for the energy pathway.\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n    \"\"\"\n    # Get inputs from the configuration file\n    # Mandatory inputs\n    output_data = {}\n\n    optional_null_series = pd.Series(\n        0.0, index=range(self.historic_start_year, self.end_year + 1)\n    )\n\n    # Usage of get/ brackets -&gt; get usefull to set null values to optional inputs\n    pathway_mfsp_without_resource = input_data.get(\n        f\"{self.pathway_name}_mean_mfsp_without_resource\", optional_null_series.copy()\n    )\n    pathway_mfsp = pathway_mfsp_without_resource.copy()\n\n    pathway_unit_subsidy_without_resource = input_data.get(\n        f\"{self.pathway_name}_mean_unit_subsidy_without_resource\", optional_null_series.copy()\n    )\n    pathway_unit_subsidy = pathway_unit_subsidy_without_resource.copy()\n\n    pathway_unit_tax_without_resource = input_data.get(\n        f\"{self.pathway_name}_mean_unit_tax_without_resource\", optional_null_series.copy()\n    )\n    pathway_unit_tax = pathway_unit_tax_without_resource.copy()\n\n    for key in self.resource_keys:\n        # 1 ) --&gt; pathway gets directly a resource\n        specific_consumption = input_data.get(\n            f\"{self.pathway_name}_resource_specific_consumption_{key}\", None\n        )\n        if specific_consumption is not None:\n            mfsp_ressource = (\n                input_data.get(f\"{key}_cost\", optional_null_series.copy())\n                * specific_consumption\n            )\n            # usage of add to avoid getting a nan if one of the series is not defined intentionally\n            pathway_mfsp = pathway_mfsp.add(mfsp_ressource, fill_value=0)\n\n            output_data[f\"{self.pathway_name}_excluding_processes_{key}_mean_unit_cost\"] = (\n                mfsp_ressource\n            )\n\n            subsidy_ressource = (\n                input_data.get(f\"{key}_subsidy\", optional_null_series.copy())\n                * specific_consumption\n            )\n            pathway_unit_subsidy = pathway_unit_subsidy.add(subsidy_ressource, fill_value=0)\n            output_data[f\"{self.pathway_name}_excluding_processes_{key}_mean_unit_subsidy\"] = (\n                subsidy_ressource\n            )\n\n            tax_ressource = (\n                input_data.get(f\"{key}_tax\", optional_null_series.copy()) * specific_consumption\n            )\n            pathway_unit_tax = pathway_unit_tax.add(tax_ressource, fill_value=0)\n            output_data[f\"{self.pathway_name}_excluding_processes_{key}_mean_unit_tax\"] = (\n                tax_ressource\n            )\n\n        # 2 ) --&gt; pathway gets a process that uses a resource\n        for process_key in self.process_keys:\n            specific_consumption = input_data.get(\n                f\"{process_key}_resource_specific_consumption_{key}\"\n            )\n            if specific_consumption is not None:\n                mfsp_ressource = (\n                    input_data.get(f\"{key}_cost\", optional_null_series.copy())\n                    * specific_consumption\n                )\n                # usage of add to avoid getting a nan if one of the series is not defined intentionally\n                pathway_mfsp = pathway_mfsp.add(mfsp_ressource, fill_value=0)\n\n                output_data[f\"{self.pathway_name}_{process_key}_{key}_mean_unit_cost\"] = (\n                    mfsp_ressource\n                )\n\n                subsidy_ressource = (\n                    input_data.get(f\"{key}_subsidy\", optional_null_series.copy())\n                    * specific_consumption\n                )\n                pathway_unit_subsidy = pathway_unit_subsidy.add(subsidy_ressource, fill_value=0)\n                output_data[f\"{self.pathway_name}_{process_key}_{key}_mean_unit_subsidy\"] = (\n                    subsidy_ressource\n                )\n\n                tax_ressource = (\n                    input_data.get(f\"{key}_tax\", optional_null_series.copy())\n                    * specific_consumption\n                )\n                pathway_unit_tax = pathway_unit_tax.add(tax_ressource, fill_value=0)\n                output_data[f\"{self.pathway_name}_{process_key}_{key}_mean_unit_tax\"] = (\n                    tax_ressource\n                )\n\n    # 3 ) --&gt; pathway needs process cost without resources\n    for process_key in self.process_keys:\n        mfsp_process = input_data.get(\n            f\"{process_key}_mean_mfsp_without_resource\", optional_null_series.copy()\n        )\n        pathway_mfsp = pathway_mfsp.add(mfsp_process, fill_value=0)\n        output_data[f\"{self.pathway_name}_{process_key}_mean_unit_cost_without_resources\"] = (\n            mfsp_process\n        )\n\n        subsidy_process = input_data.get(\n            f\"{process_key}_mean_unit_subsidy_without_resources\", optional_null_series.copy()\n        )\n        pathway_unit_subsidy = pathway_unit_subsidy.add(subsidy_process, fill_value=0)\n        output_data[\n            f\"{self.pathway_name}_{process_key}_mean_unit_subsidy_without_resources\"\n        ] = subsidy_process\n\n        tax_process = input_data.get(\n            f\"{process_key}_mean_unit_tax_without_resources\", optional_null_series.copy()\n        )\n        pathway_unit_tax = pathway_unit_tax.add(tax_process, fill_value=0)\n        output_data[f\"{self.pathway_name}_{process_key}_mean_unit_tax_without_resources\"] = (\n            tax_process\n        )\n\n    # Avoiding adding nans if subsidies and taxes defined for a shorter period of time than the mfsp\n    pathway_net_mfsp_without_carbon_tax = pathway_mfsp.add(\n        -pathway_unit_subsidy, fill_value=0\n    ).add(pathway_unit_tax, fill_value=0)\n\n    # Handle possible differential carbon_tax\n    if f\"{self.pathway_name}_carbon_tax\" in input_data:\n        carbon_tax = (\n            input_data[f\"{self.pathway_name}_carbon_tax\"] / 1000\n        )  # converted to \u20ac/kgCO2\n    else:\n        carbon_tax = input_data[\"carbon_tax\"] / 1000  # converted to \u20ac/kgCO2\n\n    emission_factor = (\n        input_data[f\"{self.pathway_name}_mean_co2_emission_factor\"] / 1000\n    )  # converted to kgCO2/MJ\n    pathway_unit_carbon_tax = carbon_tax * emission_factor\n\n    pathway_net_mfsp = pathway_net_mfsp_without_carbon_tax.add(\n        pathway_unit_carbon_tax, fill_value=0\n    )\n\n    output_data.update(\n        {\n            f\"{self.pathway_name}_net_mfsp_without_carbon_tax\": pathway_net_mfsp_without_carbon_tax,\n            f\"{self.pathway_name}_net_mfsp\": pathway_net_mfsp,\n            f\"{self.pathway_name}_mean_mfsp\": pathway_mfsp,\n            f\"{self.pathway_name}_mean_unit_tax\": pathway_unit_tax,\n            f\"{self.pathway_name}_mean_unit_carbon_tax\": pathway_unit_carbon_tax,\n            f\"{self.pathway_name}_mean_unit_subsidy\": pathway_unit_subsidy,\n        }\n    )\n\n    # Store the results in the df\n    self._store_outputs(output_data)\n\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.top_down.environmental/","title":"<code>aeromaps.models.impacts.generic_energy_model.top_down.environmental</code>","text":"<p>environmental</p> <p>================ Module to compute pathway environmental parameters using the top-down techno-economic model.</p>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.top_down.environmental/#aeromaps.models.impacts.generic_energy_model.top_down.environmental.TopDownEnvironmental","title":"TopDownEnvironmental","text":"<pre><code>TopDownEnvironmental(name, configuration_data, resources_data, processes_data, *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Generic model for aviation energy carriers, relying on user's description of the carriers in the configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('f\"{pathway_name}_top_down_unit_environmental\"' by default).</p> required <code>configuration_data</code> <code>dict</code> <p>Configuration data for the energy pathway from the config file.</p> required <code>resources_data</code> <code>dict</code> <p>Configuration data for the energy resources from the config file.</p> required <code>processes_data</code> <code>dict</code> <p>Configuration data for the energy processes from the config file.</p> required Source code in <code>aeromaps/models/impacts/generic_energy_model/top_down/environmental.py</code> <pre><code>def __init__(\n    self,\n    name,\n    configuration_data,\n    resources_data,\n    processes_data,\n    *args,\n    **kwargs,\n):\n    super().__init__(\n        name=name,\n        model_type=\"custom\",\n        # inputs/outputs are defined in __init__ rather than auto generated from compute() signature\n        *args,\n        **kwargs,\n    )\n    # Get the name of the pathway\n    self.pathway_name = configuration_data[\"name\"]\n\n    # Get the inputs from the configuration file: two options\n    # 1. All inputs of a certain category in the yaml file\n    for key, val in configuration_data.get(\"inputs\").get(\"environmental\", {}).items():\n        # TODO initialize with zeros instead of actual val?\n        self.input_names[key] = val\n    for key, val in configuration_data.get(\"inputs\").get(\"technical\", {}).items():\n        # TODO initialize with zeros instead of actual val? How to better get rid of unnecessary variables\n        if (\n            key == f\"{self.pathway_name}_resource_names\"\n            or key == f\"{self.pathway_name}_processes_names\"\n        ):\n            pass  # avoid having strings as variable in gemseo, not needed as variables\n        else:\n            self.input_names[key] = val\n\n    # 2. Set individual inputs, coming either from other models or from the yaml as well\n    # Individual inputs defined in the yaml file\n    # -- None\n    # Individual inputs defined by EnergyUseChoice\n    self.input_names[f\"{self.pathway_name}_energy_consumption\"] = pd.Series([0.0])\n\n    # TODO find a better way to get the resource inputs ? Now better with the list(str) argument of each pathway .yaml\n    # 3. Getting resources is a bit more complex as we need to get necessary resources for the pathway\n    self.resource_keys = (\n        configuration_data.get(\"inputs\")\n        .get(\"technical\", {})\n        .get(f\"{self.pathway_name}_resource_names\", [])\n    ).copy()\n\n    self.process_keys = (\n        configuration_data.get(\"inputs\")\n        .get(\"technical\", {})\n        .get(f\"{self.pathway_name}_processes_names\", [])\n    ).copy()\n\n    # Adding resources-linked inputs and outputs\n    for key in self.resource_keys:\n        self.output_names[\n            f\"{self.pathway_name}_excluding_processes_{key}_mean_co2_emission_factor\"\n        ] = pd.Series([0.0])\n        self.output_names[\n            f\"{self.pathway_name}_excluding_processes_{key}_total_consumption\"\n        ] = pd.Series([0.0])\n        self.output_names[\n            f\"{self.pathway_name}_excluding_processes_{key}_total_mobilised_with_selectivity\"\n        ] = pd.Series([0.0])\n\n        self.output_names[f\"{self.pathway_name}_{key}_total_consumption\"] = pd.Series([0.0])\n        self.output_names[f\"{self.pathway_name}_{key}_total_mobilised_with_selectivity\"] = (\n            pd.Series([0.0])\n        )\n\n    for process_key in self.process_keys:\n        for key, val in processes_data[process_key].get(\"inputs\").get(\"technical\", {}).items():\n            if key == f\"{process_key}_resource_names\":\n                resources = (\n                    processes_data[process_key]\n                    .get(\"inputs\")\n                    .get(\"technical\", {})\n                    .get(f\"{process_key}_resource_names\", [])\n                )\n                self.resource_keys.extend(resources)\n                for resource in resources:\n                    self.output_names[\n                        f\"{self.pathway_name}_{process_key}_{resource}_mean_co2_emission_factor\"\n                    ] = pd.Series([0.0])\n                    self.output_names[\n                        f\"{self.pathway_name}_{process_key}_{resource}_total_consumption\"\n                    ] = pd.Series([0.0])\n                    self.output_names[\n                        f\"{self.pathway_name}_{process_key}_{resource}_total_mobilised_with_selectivity\"\n                    ] = pd.Series([0.0])\n            else:\n                # TODO initialize with zeros instead of actual val?\n                self.input_names[key] = val\n\n        for key, val in processes_data[process_key].get(\"inputs\").get(\"economics\", {}).items():\n            # TODO initialize with zeros instead of actual val?\n            self.input_names[key] = val\n        self.output_names[\n            f\"{self.pathway_name}_{process_key}_without_resources_mean_co2_emission_factor\"\n        ] = pd.Series([0.0])\n\n    # Getting unique resources\n    self.resource_keys = list(set(self.resource_keys))\n\n    for key in self.resource_keys:\n        if f\"{key}_co2_emission_factor\" in resources_data[key][\"specifications\"]:\n            self.input_names[f\"{key}_co2_emission_factor\"] = pd.Series([0.0])\n\n        self.output_names[f\"{self.pathway_name}_{key}_total_consumption\"] = pd.Series([0.0])\n        self.output_names[f\"{self.pathway_name}_{key}_total_mobilised_with_selectivity\"] = (\n            pd.Series([0.0])\n        )\n\n    # COMPUTE ABATEMENT COST NOT RECOMMENDED WITH TOP-DOWN MODELS\n    if configuration_data.get(\"abatement_cost\"):\n        self.compute_abatement_cost = True\n        self.input_names[\"exogenous_carbon_price_trajectory\"] = pd.Series([0.0])\n        self.input_names[\"social_discount_rate\"] = 0.0\n        self.output_names[f\"{self.pathway_name}_lifespan_unitary_emissions\"] = pd.Series([0.0])\n        self.output_names[f\"{self.pathway_name}_lifespan_discounted_unitary_emissions\"] = (\n            pd.Series([0.0])\n        )\n    else:\n        self.compute_abatement_cost = False\n\n    # Fill in the other expected outputs with names from the compute method\n    self.output_names.update(\n        {\n            f\"{self.pathway_name}_mean_co2_emission_factor\": pd.Series([0.0]),\n            f\"{self.pathway_name}_total_co2_emissions\": pd.Series([0.0]),\n        }\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.top_down.environmental/#aeromaps.models.impacts.generic_energy_model.top_down.environmental.TopDownEnvironmental.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Execute the top-down environmental computations for the energy pathway.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/impacts/generic_energy_model/top_down/environmental.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"\n    Execute the top-down environmental computations for the energy pathway.\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n    \"\"\"\n    output_data = {}\n    optional_null_series = pd.Series(\n        0.0, index=range(self.historic_start_year, self.end_year + 1)\n    )\n\n    co2_emission_factor = input_data.get(\n        f\"{self.pathway_name}_mean_co2_emission_factor_without_resource\", optional_null_series\n    )\n\n    # Get the total energy consumption of the pathway\n    energy_consumption = input_data[f\"{self.pathway_name}_energy_consumption\"]\n\n    # Pathway selectivity\n    pathway_kerosene_selectivity = input_data.get(\n        f\"{self.pathway_name}_kerosene_selectivity\", 1.0\n    )\n\n    for key in self.resource_keys:\n        # 1 ) --&gt; pathway gets directly a resource\n        specific_consumption = input_data.get(\n            f\"{self.pathway_name}_resource_specific_consumption_{key}\", None\n        )\n        total_ressource_consumption = optional_null_series.copy()\n        total_ressource_mobilised_with_selectivity = optional_null_series.copy()\n\n        if specific_consumption is not None:\n            ressource_consumption = energy_consumption * specific_consumption\n            ressource_required_with_selectivity = (\n                ressource_consumption / pathway_kerosene_selectivity\n            )\n            total_ressource_consumption = total_ressource_consumption.add(\n                ressource_consumption, fill_value=0\n            )\n            total_ressource_mobilised_with_selectivity = (\n                total_ressource_mobilised_with_selectivity.add(\n                    ressource_required_with_selectivity, fill_value=0\n                )\n            )\n\n            output_data[f\"{self.pathway_name}_excluding_processes_{key}_total_consumption\"] = (\n                ressource_consumption\n            )\n            output_data[\n                f\"{self.pathway_name}_excluding_processes_{key}_total_mobilised_with_selectivity\"\n            ] = ressource_required_with_selectivity\n\n            unit_emissions = input_data.get(f\"{key}_co2_emission_factor\", optional_null_series)\n            # get resource emission per unit of energy\n            co2_emission_factor_ressource = specific_consumption * unit_emissions\n\n            output_data[\n                f\"{self.pathway_name}_excluding_processes_{key}_mean_co2_emission_factor\"\n            ] = co2_emission_factor_ressource\n            co2_emission_factor = co2_emission_factor.add(\n                co2_emission_factor_ressource, fill_value=0\n            )\n        # 2 ) --&gt; pathway gets a process that uses a resource\n        for process_key in self.process_keys:\n            specific_consumption = input_data.get(\n                f\"{process_key}_resource_specific_consumption_{key}\"\n            )\n            if specific_consumption is not None:\n                ressource_consumption = energy_consumption * specific_consumption\n                ressource_required_with_selectivity = (\n                    ressource_consumption / pathway_kerosene_selectivity\n                )\n\n                total_ressource_consumption = total_ressource_consumption.add(\n                    ressource_consumption, fill_value=0\n                )\n                total_ressource_mobilised_with_selectivity = (\n                    total_ressource_mobilised_with_selectivity.add(\n                        ressource_required_with_selectivity, fill_value=0\n                    )\n                )\n\n                output_data[f\"{self.pathway_name}_{process_key}_{key}_total_consumption\"] = (\n                    ressource_consumption\n                )\n                output_data[\n                    f\"{self.pathway_name}_{process_key}_{key}_total_mobilised_with_selectivity\"\n                ] = ressource_required_with_selectivity\n\n                unit_emissions = input_data.get(\n                    f\"{key}_co2_emission_factor\", optional_null_series\n                )\n                # get resource emission per unit of energy\n                co2_emission_factor_ressource = specific_consumption * unit_emissions\n\n                output_data[\n                    f\"{self.pathway_name}_{process_key}_{key}_mean_co2_emission_factor\"\n                ] = co2_emission_factor_ressource\n                co2_emission_factor = co2_emission_factor.add(\n                    co2_emission_factor_ressource, fill_value=0\n                )\n        # Store the total resource consumption\n        output_data[f\"{self.pathway_name}_{key}_total_consumption\"] = (\n            total_ressource_consumption\n        )\n\n        output_data[f\"{self.pathway_name}_{key}_total_mobilised_with_selectivity\"] = (\n            total_ressource_mobilised_with_selectivity\n        )\n\n    # 3 ) --&gt; pathway gets a process that makes own emissions (besides resources)\n    for process_key in self.process_keys:\n        co2_emission_factor_process = input_data.get(\n            f\"{process_key}_co2_emission_factor_without_resource\", optional_null_series\n        )\n        output_data[\n            f\"{self.pathway_name}_{process_key}_without_resources_mean_co2_emission_factor\"\n        ] = co2_emission_factor_process\n\n        co2_emission_factor = co2_emission_factor.add(co2_emission_factor_process)\n\n    # Store the total CO2 emission factor in the dataframe\n    output_data[f\"{self.pathway_name}_mean_co2_emission_factor\"] = co2_emission_factor\n\n    # compute the cumulative and discounted emissions for the vintage NOT RECOMMENDED WITH TOP-DOWN MODELS\n    if self.compute_abatement_cost:\n        # Get the exogenous carbon price trajectory and social discount rate\n        exogenous_carbon_price_trajectory = input_data.get(\n            \"exogenous_carbon_price_trajectory\", optional_null_series\n        )\n        social_discount_rate = input_data.get(\"social_discount_rate\", 0.0)\n\n        # Initialize the output series for cumulative emissions\n        output_data[f\"{self.pathway_name}_lifespan_unitary_emissions\"] = pd.Series(\n            np.NaN, index=range(self.historic_start_year, self.end_year + 1)\n        )\n        output_data[f\"{self.pathway_name}_lifespan_discounted_unitary_emissions\"] = pd.Series(\n            np.NaN, index=range(self.historic_start_year, self.end_year + 1)\n        )\n\n        for year in range(self.historic_start_year, self.end_year + 1):\n            if year in co2_emission_factor.index:\n                # Compute cumulative and discounted emissions for the vintage\n                cumul_em, generic_discounted_cumul_em = self._unitary_cumul_emissions(\n                    co2_emission_factor.loc[year],\n                    exogenous_carbon_price_trajectory,\n                    social_discount_rate,\n                    year,  # Assuming a default lifespan of 25 years for the vintage\n                )\n            else:\n                cumul_em = np.NaN\n                generic_discounted_cumul_em = np.NaN\n\n            # Store the cumulative emissions for the vintage\n            output_data[f\"{self.pathway_name}_lifespan_unitary_emissions\"].loc[year] = cumul_em\n            output_data[f\"{self.pathway_name}_lifespan_discounted_unitary_emissions\"].loc[\n                year\n            ] = generic_discounted_cumul_em\n\n    # Calculate the total CO2 emissions\n    total_co2_emissions = energy_consumption * co2_emission_factor\n    output_data[f\"{self.pathway_name}_total_co2_emissions\"] = total_co2_emissions\n\n    self._store_outputs(output_data)\n\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.generic_energy_model.top_down/","title":"<code>aeromaps.models.impacts.generic_energy_model.top_down</code>","text":"<p>top_down</p> <p>========== Package with simple top-down energy models to compute costs and emissions based on interpolation values.</p>"},{"location":"full_doc/aeromaps.models.impacts.life_cycle_assessment.life_cycle_assessment/","title":"<code>aeromaps.models.impacts.life_cycle_assessment.life_cycle_assessment</code>","text":"<p>Model for Life Cycle Assessment (LCA) of air transportation systems</p>"},{"location":"full_doc/aeromaps.models.impacts.life_cycle_assessment.life_cycle_assessment/#aeromaps.models.impacts.life_cycle_assessment.life_cycle_assessment.LifeCycleAssessment","title":"LifeCycleAssessment","text":"<pre><code>LifeCycleAssessment(name='life_cycle_assessment', configuration_file=None, split_by=None, *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Life Cycle Assessment (LCA) model to compute multiple environmental impacts beyond climate change.</p> <p>This model requires a valid ecoinvent license stored in a private '.env' file (that you will not share /commit) in the notebooks or project root folder, containing the following variables:     ECOINVENT_LOGIN=     ECOINVENT_PASSWORD= <p>This model uses the lca_modeller library to build a parametric LCA model from a user-provided configuration file, and the lca_algebraic library (a layer on top of brightway) to compute LCA results efficiently for multiple years. The life cycle inventory relies on the ecoinvent database, projected to future years using the premise library.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance.</p> <code>'life_cycle_assessment'</code> <code>configuration_file</code> <code>str</code> <p>Path to the LCA configuration file defining the model and LCIA methods.</p> <code>None</code> <code>split_by</code> <code>str</code> <p>Axis to split impacts by (typically, \"phase\"). Should match an axis defined in the configuration file through the \"attribute\" field.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>Activity</code> <p>The parametric LCA model representative of air transport, generated from the configuration file.</p> <code>methods</code> <code>list</code> <p>List of LCIA methods to compute.</p> <code>axis</code> <code>str</code> <p>Optional axis to get contributors to impacts (typically, \"phase\").</p> <code>params_names</code> <code>list</code> <p>List of LCA parameter names used in the model, generated automatically from the LCA model definition.</p> <code>xarray_lca</code> <code>DataArray</code> <p>The full LCA results stored as an xarray DataArray after computation.</p> <code>lambdas</code> <code>list</code> <p>List of symbolic expressions for LCIA impacts, precomputed for efficiency.</p> Source code in <code>aeromaps/models/impacts/life_cycle_assessment/life_cycle_assessment.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"life_cycle_assessment\",\n    configuration_file: str = None,\n    split_by: str = None,\n    *args,\n    **kwargs,\n):\n    super().__init__(\n        name=name,\n        model_type=\"custom\",\n        *args,\n        **kwargs,\n    )\n\n    # Get LCA model and LCIA methods\n    if configuration_file is None:\n        raise ValueError(\"Configuration file is missing.\")\n    _, model, methods = LCAProblemConfigurator(configuration_file).generate()\n    self.model = model\n    self.methods = methods\n    self.axis = split_by\n    self.params_names = agb.all_params().keys()\n    self.xarray_lca = xr.DataArray()\n\n    # --- Add LCA parameters as inputs of this AeroMAPSModel ---\n    self._skip_data_type_validation = True  # see aeromaps/core/gemseo.py\n    self.input_names = []\n    self.output_names = []\n\n    for x in self.params_names:\n        # Years of simulation are directly taken from AeroMAPS timeline and not as an input parameter\n        if x == KEY_YEAR:\n            continue\n\n        self.input_names.append(x)\n        self.input_names.append(x + \"_reference_years\")\n        self.input_names.append(x + \"_reference_years_values\")\n\n        self.default_input_data[x] = np.nan\n        self.default_input_data[x + \"_reference_years\"] = np.nan\n        self.default_input_data[x + \"_reference_years_values\"] = np.nan\n\n    # Dry run with lca_algebraic to build symbolic expressions of LCIA impacts\n    print(\"Parametrizing LCIA impacts...\", end=\" \")\n    self.lambdas = agb.lca._preMultiLCAAlgebric(self.model, self.methods, axis=self.axis)\n    print(\"Done.\")\n\n    # --- Add LCA impact categories the outputs to the AeroMAPSModel ---\n    if getattr(self.lambdas[0], \"axis_keys\", None):\n        for method in self.methods:\n            for phase in self.lambdas[0].axis_keys:\n                method_with_axis = method + (phase,)\n                self.output_names.append(tuple_to_varname(method_with_axis))\n    else:\n        for method in self.methods:\n            self.output_names.append(tuple_to_varname(method))\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.life_cycle_assessment.life_cycle_assessment/#aeromaps.models.impacts.life_cycle_assessment.life_cycle_assessment.LifeCycleAssessment.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Compute LCA impacts for the given input parameters.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>dict</code> <p>Dictionary containing values for LCA parameters.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing computed LCA impacts as pd.Series (one per impact category).</p> Source code in <code>aeromaps/models/impacts/life_cycle_assessment/life_cycle_assessment.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"\n    Compute LCA impacts for the given input parameters.\n\n    Parameters\n    ----------\n    input_data : dict\n        Dictionary containing values for LCA parameters.\n\n    Returns\n    -------\n    dict\n        Dictionary containing computed LCA impacts as pd.Series (one per impact category).\n    \"\"\"\n    # --- Assign values to parameters ---\n    params_dict = self._get_param_values(input_data)\n\n    # --- Calculate impacts for all parameters at once ---\n    res = self._multi_lca_algebraic_raw(**params_dict)\n\n    # --- Store xarray to enable user to access data after process calculation ---\n    res[\"params\"] = params_dict[KEY_YEAR]  # replace param index by actual years\n    res = res.rename({\"params\": KEY_YEAR})  # rename 'params' dimension to 'year'\n    self.xarray_lca = res\n\n    # --- Convert xarray to pd.Series to enable connection with other models ---\n    output_data = self._convert_xarray_to_series(res)\n    self._store_outputs(output_data)\n\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.life_cycle_assessment.life_cycle_assessment/#aeromaps.models.impacts.life_cycle_assessment.life_cycle_assessment.tuple_to_varname","title":"tuple_to_varname","text":"<pre><code>tuple_to_varname(items)\n</code></pre> <p>Convert a tuple or list of strings into a clean, Python-friendly variable name.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>tuple or list</code> <p>The tuple or list of strings to convert.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A cleaned variable name string.</p> Source code in <code>aeromaps/models/impacts/life_cycle_assessment/life_cycle_assessment.py</code> <pre><code>def tuple_to_varname(items):\n    \"\"\"\n    Convert a tuple or list of strings into a clean, Python-friendly variable name.\n\n    Parameters\n    ----------\n    items : tuple or list\n        The tuple or list of strings to convert.\n\n    Returns\n    -------\n    str\n        A cleaned variable name string.\n    \"\"\"\n    if isinstance(items, (list, tuple)):\n        text = \"__\".join(items)  # join parts with double underscores\n    else:\n        text = str(items)\n\n    # Lowercase everything\n    text = text.lower()\n\n    # Replace anything that\u2019s not alphanumeric or underscore with underscore\n    text = re.sub(r\"[^0-9a-zA-Z_]+\", \"_\", text)\n\n    # Remove leading/trailing underscores and collapse multiple underscores\n    text = re.sub(r\"_+\", \"_\", text).strip(\"_\")\n\n    # Add lca to variable\n    text = \"lca_\" + text\n\n    return text\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.life_cycle_assessment.life_cycle_assessment/#aeromaps.models.impacts.life_cycle_assessment.life_cycle_assessment.is_not_nan","title":"is_not_nan","text":"<pre><code>is_not_nan(x)\n</code></pre> <p>Return True if x is not NaN or None. Handles single values and arrays/lists.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>any</code> <p>The input to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if x is not NaN or None, False otherwise.</p> Source code in <code>aeromaps/models/impacts/life_cycle_assessment/life_cycle_assessment.py</code> <pre><code>def is_not_nan(x):\n    \"\"\"\n    Return True if x is not NaN or None. Handles single values and arrays/lists.\n\n    Parameters\n    ----------\n    x : any\n        The input to check.\n\n    Returns\n    -------\n    bool\n        True if x is not NaN or None, False otherwise.\n    \"\"\"\n    if x is None:\n        return False\n    if isinstance(x, (float, int, np.number)):\n        return not pd.isna(x)\n    if isinstance(x, (pd.Series, np.ndarray, list, tuple)):\n        return pd.notna(np.asarray(x)).any()\n    return True\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.life_cycle_assessment/","title":"<code>aeromaps.models.impacts.life_cycle_assessment</code>","text":""},{"location":"full_doc/aeromaps.models.impacts.life_cycle_assessment.plots/","title":"<code>aeromaps.models.impacts.life_cycle_assessment.plots</code>","text":"<p>Plots for life cycle assessments interpretation</p>"},{"location":"full_doc/aeromaps.models.impacts.life_cycle_assessment.plots/#aeromaps.models.impacts.life_cycle_assessment.plots.process_tree","title":"process_tree","text":"<pre><code>process_tree(model, foreground_only=True, outfile=default_process_tree_filename, colormap='Pastel2')\n</code></pre> <p>Plots an interactive tree to visualize the activities and exchanges declared in the LCA module. :param model: The model containing activities and exchanges. :param foreground_only: Boolean flag to include only foreground activities. :param outfile: Output filename for the generated tree. :param colormap: Colormap to use for node coloring.</p> Source code in <code>aeromaps/models/impacts/life_cycle_assessment/plots.py</code> <pre><code>def process_tree(\n    model: Activity,\n    foreground_only: bool = True,\n    outfile: str = default_process_tree_filename,\n    colormap: str = \"Pastel2\",\n):\n    \"\"\"\n    Plots an interactive tree to visualize the activities and exchanges declared in the LCA module.\n    :param model: The model containing activities and exchanges.\n    :param foreground_only: Boolean flag to include only foreground activities.\n    :param outfile: Output filename for the generated tree.\n    :param colormap: Colormap to use for node coloring.\n    \"\"\"\n    # Init network\n    net = Network(\n        notebook=True, directed=True, layout=True, cdn_resources=\"remote\", filter_menu=False\n    )\n\n    # Get processes hierarchy\n    df = list_processes(model, foreground_only)\n    df[\"description\"] = df[\"activity\"] + \"\\n\" + df[\"unit\"].fillna(\"\")\n\n    # Colors\n    unique_values = df[\"database\"].unique()\n    value_indices = {value: i for i, value in enumerate(unique_values)}\n    norm = matplotlib.colors.Normalize(vmin=0, vmax=len(unique_values), clip=True)\n    mapper = plt.cm.ScalarMappable(norm=norm, cmap=plt.get_cmap(colormap))\n    colors = df[\"database\"].apply(\n        lambda x: matplotlib.colors.to_hex(mapper.to_rgba(value_indices[x]))\n    )\n\n    # Populate network\n    edge_data = zip(\n        df[\"activity\"],\n        df[\"description\"],\n        df[\"parents\"],\n        df[\"amounts\"],\n        df[\"level\"],\n        df[\"database\"],\n        colors,\n    )\n\n    edges = {}\n    for activity, description, parents, amounts, level, database, color in edge_data:\n        src = activity if database == USER_DB else f\"{activity}\\n[{database}]\"\n        # desc_array = description.split(',')\n        # desc_db = description.split('(')\n        # desc = ',\\n'.join(desc_array[:2]) if len(desc_array) &gt; 1 else desc_array[0]\n        # desc += f\"\\n({desc_db[-1]}\" if len(desc_db) &gt; 1 else ''\n        desc = description\n\n        net.add_node(src, desc, title=src, level=level + 1, shape=\"box\", color=color)\n\n        for parent, amount in zip(parents, amounts):\n            if parent:\n                edge_key = (src, parent)\n                if edge_key in edges:  # Multiple edges between the same nodes\n                    edges[edge_key].append(str(amount))\n                else:  # first time edge links act and its parent: create new node for parent\n                    edges[edge_key] = [str(amount)]\n\n    # Add edges to the network with unique labels\n    for (src, dst), labels in edges.items():\n        if len(labels) == 1:\n            net.add_edge(src, dst, label=labels[0], title=f\"Exch. 1: {labels[0]}\")\n        else:\n            num_edges = len(labels)\n            roundness_step = 0.1 / num_edges  # Adjust the denominator to control spacing\n            for i, label in enumerate(labels):\n                curve_type = \"curvedCW\" if i % 2 == 0 else \"curvedCCW\"\n                roundness = roundness_step * (\n                    i + 1\n                )  # Adjust roundness to avoid excessive curvature\n                net.add_edge(\n                    src,\n                    dst,\n                    label=label,\n                    title=f\"Exch. {i + 1}: {label}\",\n                    smooth={\"enabled\": True, \"type\": curve_type, \"roundness\": roundness},\n                )\n\n    # Set options\n    net.set_edge_smooth(\"vertical\")\n    net.toggle_physics(False)\n    net.show_buttons(filter_=True)\n    net.options.layout.hierarchical.nodeSpacing = 200\n\n    # Save\n    net.save_graph(outfile)\n\n    # Display in Jupyter Notebook\n    display(IFrame(src=os.path.relpath(outfile), width=\"100%\", height=700))\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts/","title":"<code>aeromaps.models.impacts</code>","text":"<p>impacts</p> <p>======== This module contains all models to compute air transport impacts.</p> Warning <p>Due to refactoring, some models rather concern to air transport modelling (e.g energy_use_choice). The overall structure will be improved in future releases.</p>"},{"location":"full_doc/aeromaps.models.impacts.others.comparison/","title":"<code>aeromaps.models.impacts.others.comparison</code>","text":"<p>comparison</p> <p>============= Module to compute carbon budget consumed share and equivalent carbon budget consumed share.</p>"},{"location":"full_doc/aeromaps.models.impacts.others.comparison/#aeromaps.models.impacts.others.comparison.CarbonBudgetConsumedShare","title":"CarbonBudgetConsumedShare","text":"<pre><code>CarbonBudgetConsumedShare(name='carbon_budget_consumed_share', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>This class computes the consumed share of the carbon budget.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('carbon_budget_consumed_share' by default).</p> <code>'carbon_budget_consumed_share'</code> Source code in <code>aeromaps/models/impacts/others/comparison.py</code> <pre><code>def __init__(self, name=\"carbon_budget_consumed_share\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.others.comparison/#aeromaps.models.impacts.others.comparison.CarbonBudgetConsumedShare.compute","title":"compute","text":"<pre><code>compute(cumulative_co2_emissions, gross_carbon_budget_2050)\n</code></pre> <p>Carbon budget consumption share calculation.</p> <p>Parameters:</p> Name Type Description Default <code>cumulative_co2_emissions</code> <code>Series</code> <p>Cumulative CO2 emissions from all commercial air transport [GtCO2].</p> required <code>gross_carbon_budget_2050</code> <code>float</code> <p>World gross carbon budget until 2050 [GtCO2].</p> required <p>Returns:</p> Type Description <code>carbon_budget_consumed_share</code> <p>Share of carbon budget consumed by aviation over 2020-2050 [%].</p> Source code in <code>aeromaps/models/impacts/others/comparison.py</code> <pre><code>def compute(\n    self,\n    cumulative_co2_emissions: pd.Series,\n    gross_carbon_budget_2050: float,\n) -&gt; float:\n    \"\"\"\n    Carbon budget consumption share calculation.\n\n    Parameters\n    ----------\n    cumulative_co2_emissions\n        Cumulative CO2 emissions from all commercial air transport [GtCO2].\n    gross_carbon_budget_2050\n        World gross carbon budget until 2050 [GtCO2].\n\n    Returns\n    -------\n    carbon_budget_consumed_share\n        Share of carbon budget consumed by aviation over 2020-2050 [%].\n    \"\"\"\n\n    carbon_budget_consumed_share = (\n        cumulative_co2_emissions.loc[self.end_year] / gross_carbon_budget_2050 * 100\n    )\n\n    self.float_outputs[\"carbon_budget_consumed_share\"] = carbon_budget_consumed_share\n\n    return carbon_budget_consumed_share\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.others.comparison/#aeromaps.models.impacts.others.comparison.EquivalentCarbonBudgetConsumedShare","title":"EquivalentCarbonBudgetConsumedShare","text":"<pre><code>EquivalentCarbonBudgetConsumedShare(name='equivalent_carbon_budget_consumed_share', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>This class computes the consumed share of the equivalent carbon budget.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('equivalent_carbon_budget_consumed_share' by default).</p> <code>'equivalent_carbon_budget_consumed_share'</code> Source code in <code>aeromaps/models/impacts/others/comparison.py</code> <pre><code>def __init__(self, name=\"equivalent_carbon_budget_consumed_share\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.others.comparison/#aeromaps.models.impacts.others.comparison.EquivalentCarbonBudgetConsumedShare.compute","title":"compute","text":"<pre><code>compute(cumulative_total_equivalent_emissions, equivalent_gross_carbon_budget_2050)\n</code></pre> <p>Equivalent Carbon budget consumption share calculation.</p> <p>Parameters:</p> Name Type Description Default <code>cumulative_total_equivalent_emissions</code> <code>Series</code> <p>Cumulative equivalent emissions for all climate effects from all commercial air transport [GtCO2-we].</p> required <code>equivalent_gross_carbon_budget_2050</code> <code>float</code> <p>World equivalent gross carbon budget until 2050 [GtCO2-we].</p> required <p>Returns:</p> Type Description <code>equivalent_carbon_budget_consumed_share</code> <p>Share of equivalent carbon budget consumed by aviation over 2020-2050 [%].</p> Source code in <code>aeromaps/models/impacts/others/comparison.py</code> <pre><code>def compute(\n    self,\n    cumulative_total_equivalent_emissions: pd.Series,\n    equivalent_gross_carbon_budget_2050: float,\n) -&gt; float:\n    \"\"\"\n    Equivalent Carbon budget consumption share calculation.\n\n    Parameters\n    ----------\n    cumulative_total_equivalent_emissions\n        Cumulative equivalent emissions for all climate effects from all commercial air transport [GtCO2-we].\n    equivalent_gross_carbon_budget_2050\n        World equivalent gross carbon budget until 2050 [GtCO2-we].\n\n    Returns\n    -------\n    equivalent_carbon_budget_consumed_share\n        Share of equivalent carbon budget consumed by aviation over 2020-2050 [%].\n    \"\"\"\n\n    equivalent_carbon_budget_consumed_share = (\n        cumulative_total_equivalent_emissions.loc[self.end_year]\n        / equivalent_gross_carbon_budget_2050\n        * 100\n    )\n\n    self.float_outputs[\"equivalent_carbon_budget_consumed_share\"] = (\n        equivalent_carbon_budget_consumed_share\n    )\n\n    return equivalent_carbon_budget_consumed_share\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.others/","title":"<code>aeromaps.models.impacts.others</code>","text":"<p>others</p> <p>======== This module contains models for various other environmental impacts</p>"},{"location":"full_doc/aeromaps.models.impacts.others.others/","title":"<code>aeromaps.models.impacts.others.others</code>","text":"<p>others</p> <p>======== This module contains models for various KPI computations.</p>"},{"location":"full_doc/aeromaps.models.impacts.others.others/#aeromaps.models.impacts.others.others.EmissionsPerRPK","title":"EmissionsPerRPK","text":"<pre><code>EmissionsPerRPK(name='emissions_per_rpk', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>This class computes the CO2 emissions per Revenue Passenger Kilometer (RPK).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('emissions_per_rpk' by default).</p> <code>'emissions_per_rpk'</code> Source code in <code>aeromaps/models/impacts/others/others.py</code> <pre><code>def __init__(self, name=\"emissions_per_rpk\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.others.others/#aeromaps.models.impacts.others.others.EmissionsPerRPK.compute","title":"compute","text":"<pre><code>compute(co2_emissions_passenger, rpk)\n</code></pre> <p>CO2 emissions per Revenue Passenger Kilometer calculation.</p> <p>Parameters:</p> Name Type Description Default <code>co2_emissions_passenger</code> <code>Series</code> <p>CO2 emissions from passenger air transport [MtCO2].</p> required <code>rpk</code> <code>Series</code> <p>Revenue Passenger Kilometer [RPK].</p> required <p>Returns:</p> Type Description <code>co2_emissions_per_rpk</code> <p>CO2 emissions per Revenue Passenger Kilometer [gCO2/RPK].</p> Source code in <code>aeromaps/models/impacts/others/others.py</code> <pre><code>def compute(\n    self,\n    co2_emissions_passenger: pd.Series,\n    rpk: pd.Series,\n) -&gt; pd.Series:\n    \"\"\"\n    CO2 emissions per Revenue Passenger Kilometer calculation.\n\n    Parameters\n    ----------\n    co2_emissions_passenger\n        CO2 emissions from passenger air transport [MtCO2].\n    rpk\n        Revenue Passenger Kilometer [RPK].\n\n    Returns\n    -------\n    co2_emissions_per_rpk\n        CO2 emissions per Revenue Passenger Kilometer [gCO2/RPK].\n    \"\"\"\n\n    self.df[\"co2_emissions_per_rpk\"] = co2_emissions_passenger * 1e6 * 1e6 / rpk\n    co2_emissions_per_rpk = self.df[\"co2_emissions_per_rpk\"]\n\n    return co2_emissions_per_rpk\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.others.others/#aeromaps.models.impacts.others.others.EmissionsPerRTK","title":"EmissionsPerRTK","text":"<pre><code>EmissionsPerRTK(name='emissions_per_rpk', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>This class computes the freight CO2 emissions per Revenue Tonne Kilometer (RTK).</p> Source code in <code>aeromaps/models/impacts/others/others.py</code> <pre><code>def __init__(self, name=\"emissions_per_rpk\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.others.others/#aeromaps.models.impacts.others.others.EmissionsPerRTK.compute","title":"compute","text":"<pre><code>compute(co2_emissions_freight, rtk)\n</code></pre> <p>CO2 emissions per Revenue Tonne Kilometer calculation.</p> <p>Parameters:</p> Name Type Description Default <code>co2_emissions_freight</code> <code>Series</code> <p>CO2 emissions from freight air transport [MtCO2].</p> required <code>rtk</code> <code>Series</code> <p>Revenue Tonne Kilometer [RTK].</p> required <p>Returns:</p> Type Description <code>co2_emissions_per_rtk</code> <p>CO2 emissions per Revenue Tonne Kilometer [gCO2/RTK].</p> Source code in <code>aeromaps/models/impacts/others/others.py</code> <pre><code>def compute(\n    self,\n    co2_emissions_freight: pd.Series,\n    rtk: pd.Series,\n) -&gt; pd.Series:\n    \"\"\"CO2 emissions per Revenue Tonne Kilometer calculation.\n\n    Parameters\n    ----------\n    co2_emissions_freight\n        CO2 emissions from freight air transport [MtCO2].\n    rtk\n        Revenue Tonne Kilometer [RTK].\n\n    Returns\n    -------\n    co2_emissions_per_rtk\n        CO2 emissions per Revenue Tonne Kilometer [gCO2/RTK].\n    \"\"\"\n\n    self.df[\"co2_emissions_per_rtk\"] = co2_emissions_freight * 1e6 * 1e6 / rtk\n    co2_emissions_per_rtk = self.df[\"co2_emissions_per_rtk\"]\n\n    return co2_emissions_per_rtk\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.others.others/#aeromaps.models.impacts.others.others.DropinFuelConsumptionLiterPerPax100km","title":"DropinFuelConsumptionLiterPerPax100km","text":"<pre><code>DropinFuelConsumptionLiterPerPax100km(name='dropin_fuel_consumption_liter_per_pax_100km', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>This class computes the drop-in fuel consumption in liter per passenger per 100 km.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('dropin_fuel_consumption_liter_per_pax_100km' by default).</p> <code>'dropin_fuel_consumption_liter_per_pax_100km'</code> Source code in <code>aeromaps/models/impacts/others/others.py</code> <pre><code>def __init__(self, name=\"dropin_fuel_consumption_liter_per_pax_100km\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.impacts.others.others/#aeromaps.models.impacts.others.others.DropinFuelConsumptionLiterPerPax100km.compute","title":"compute","text":"<pre><code>compute(energy_consumption_passenger_dropin_fuel, dropin_fuel_mean_lhv, rpk)\n</code></pre> <p>Drop-in fuel consumption in liter per passenger per 100 km calculation.</p> <p>Parameters:</p> Name Type Description Default <code>energy_consumption_passenger_dropin_fuel</code> <code>Series</code> <p>Energy consumption in the form of drop-in fuels from passenger air transport [MJ].</p> required <code>dropin_fuel_mean_lhv</code> <code>Series</code> <p>Mean Lower Heating Value for drop-in fuels [MJ/liter].</p> required <code>rpk</code> <code>Series</code> <p>Revenue Passenger Kilometer [RPK].</p> required <p>Returns:</p> Type Description <code>dropin_fuel_consumption_liter_per_pax_100km</code> <p>Drop-in fuel consumption in liter per passenger per 100 km [L/PAX/100km].</p> Source code in <code>aeromaps/models/impacts/others/others.py</code> <pre><code>def compute(\n    self,\n    energy_consumption_passenger_dropin_fuel: pd.Series,\n    dropin_fuel_mean_lhv: pd.Series,\n    rpk: pd.Series,\n) -&gt; pd.Series:\n    \"\"\"\n    Drop-in fuel consumption in liter per passenger per 100 km calculation.\n\n    Parameters\n    ----------\n    energy_consumption_passenger_dropin_fuel\n        Energy consumption in the form of drop-in fuels from passenger air transport [MJ].\n    dropin_fuel_mean_lhv\n        Mean Lower Heating Value for drop-in fuels [MJ/liter].\n    rpk\n        Revenue Passenger Kilometer [RPK].\n\n    Returns\n    -------\n    dropin_fuel_consumption_liter_per_pax_100km\n        Drop-in fuel consumption in liter per passenger per 100 km [L/PAX/100km].\n    \"\"\"\n\n    density = 0.8\n    self.df[\"dropin_fuel_consumption_liter_per_pax_100km\"] = (\n        energy_consumption_passenger_dropin_fuel / dropin_fuel_mean_lhv / density * 100 / rpk\n    )\n    dropin_fuel_consumption_liter_per_pax_100km = self.df[\n        \"dropin_fuel_consumption_liter_per_pax_100km\"\n    ]\n\n    return dropin_fuel_consumption_liter_per_pax_100km\n</code></pre>"},{"location":"full_doc/aeromaps.models.optimisation.constraints.carbon_budget_constraint/","title":"<code>aeromaps.models.optimisation.constraints.carbon_budget_constraint</code>","text":""},{"location":"full_doc/aeromaps.models.optimisation.constraints.carbon_budget_constraint/#aeromaps.models.optimisation.constraints.carbon_budget_constraint--carbon_budget_constraint","title":"carbon_budget_constraint","text":"<p>This module contains the CarbonBudgetConstraint model, which defines and enforces the constraint on aviation's carbon budget consumption.</p>"},{"location":"full_doc/aeromaps.models.optimisation.constraints.carbon_budget_constraint/#aeromaps.models.optimisation.constraints.carbon_budget_constraint.CarbonBudgetConstraint","title":"CarbonBudgetConstraint","text":"<pre><code>CarbonBudgetConstraint(name='carbon_budget_constraint', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>This class computes the constraint on aviation's carbon budget consumption.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('carbon_budget_constraint' by default).</p> <code>'carbon_budget_constraint'</code> Source code in <code>aeromaps/models/optimisation/constraints/carbon_budget_constraint.py</code> <pre><code>def __init__(self, name=\"carbon_budget_constraint\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.optimisation.constraints.carbon_budget_constraint/#aeromaps.models.optimisation.constraints.carbon_budget_constraint.CarbonBudgetConstraint.compute","title":"compute","text":"<pre><code>compute(gross_carbon_budget_2050, aviation_carbon_budget_objective, cumulative_co2_emissions)\n</code></pre> <p>Carbon budget consumption share calculation.</p> <p>Parameters:</p> Name Type Description Default <code>gross_carbon_budget_2050</code> <code>float</code> <p>World gross carbon budget until 2050 [GtCO2].</p> required <code>aviation_carbon_budget_objective</code> <code>float</code> <p>Constraint set as a share of gross carbon budget allocated to aviation [%].</p> required <code>cumulative_co2_emissions</code> <code>Series</code> <p>Cumulative CO2 emissions from all commercial air transport [GtCO2].</p> required <p>Returns:</p> Type Description <code>aviation_carbon_budget_constraint</code> <p>Constraint value indicating how close aviation is to its allocated carbon budget by 2050 [-].</p> Source code in <code>aeromaps/models/optimisation/constraints/carbon_budget_constraint.py</code> <pre><code>def compute(\n    self,\n    gross_carbon_budget_2050: float,\n    aviation_carbon_budget_objective: float,\n    cumulative_co2_emissions: pd.Series,\n) -&gt; float:\n    \"\"\"\n    Carbon budget consumption share calculation.\n\n    Parameters\n    ----------\n    gross_carbon_budget_2050\n        World gross carbon budget until 2050 [GtCO2].\n    aviation_carbon_budget_objective\n        Constraint set as a share of gross carbon budget allocated to aviation [%].\n    cumulative_co2_emissions\n        Cumulative CO2 emissions from all commercial air transport [GtCO2].\n\n    Returns\n    -------\n    aviation_carbon_budget_constraint\n        Constraint value indicating how close aviation is to its allocated carbon budget by 2050 [-].\n\n    \"\"\"\n    cumulative_emissions = (\n        cumulative_co2_emissions.loc[2050] - cumulative_co2_emissions.loc[2025]\n    )\n    adjusted_carbon_budget_2050 = (\n        gross_carbon_budget_2050 * aviation_carbon_budget_objective / 100\n        - cumulative_co2_emissions.loc[2025]\n    )\n\n    # avoid division by 0: if adjusted carbon budget is lower &lt;= 0, impossible to decarbonise:\n    # trigger infeasibility warning in the optimisation\n    if adjusted_carbon_budget_2050 &lt;= 0:\n        logging.warning(\n            \"Adjusted carbon budget for aviation in 2050 is &lt;= 0. \"\n            \"This indicates that the cumulative emissions up to 2025 have already exceeded \"\n            \"the allocated carbon budget for aviation. \"\n            \"The optimisation problem may be infeasible.\"\n        )\n        adjusted_carbon_budget_2050 = 1e6  # small positive number\n\n    aviation_carbon_budget_constraint = (\n        +(cumulative_emissions - adjusted_carbon_budget_2050) / adjusted_carbon_budget_2050\n    )\n\n    self.float_outputs[\"aviation_carbon_budget_constraint\"] = aviation_carbon_budget_constraint\n\n    return aviation_carbon_budget_constraint\n</code></pre>"},{"location":"full_doc/aeromaps.models.optimisation.constraints.energy_constraint/","title":"<code>aeromaps.models.optimisation.constraints.energy_constraint</code>","text":""},{"location":"full_doc/aeromaps.models.optimisation.constraints/","title":"<code>aeromaps.models.optimisation.constraints</code>","text":"<p>constraints</p> <p>=============== This package contains models related to constraints used in optimisation processes within the AeroMAPS framework.</p>"},{"location":"full_doc/aeromaps.models.optimisation/","title":"<code>aeromaps.models.optimisation</code>","text":"<p>optimisation</p> <p>=============== This package contains models related to optimisation processes within the AeroMAPS framework.</p>"},{"location":"full_doc/aeromaps.models.parameters/","title":"<code>aeromaps.models.parameters</code>","text":"<p>Utilities for loading, storing, and converting AeroMAPSProcess self.parameters.</p>"},{"location":"full_doc/aeromaps.models.parameters/#aeromaps.models.parameters.Parameters","title":"Parameters","text":"<p>Container for AeroMAPSProcess input parameters TODO: is that the most appropriate description?</p>"},{"location":"full_doc/aeromaps.models.parameters/#aeromaps.models.parameters.Parameters.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Return a dictionary representation of the parameters.</p> <p>Returns:</p> Type Description <code>data</code> <p>Dictionary mapping attribute names to their values.</p> Source code in <code>aeromaps/models/parameters.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Return a dictionary representation of the parameters.\n\n    Returns\n    -------\n    data\n        Dictionary mapping attribute names to their values.\n    \"\"\"\n    return self.__dict__\n</code></pre>"},{"location":"full_doc/aeromaps.models.parameters/#aeromaps.models.parameters.Parameters.from_dict","title":"from_dict","text":"<pre><code>from_dict(data)\n</code></pre> <p>Update attributes from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>Dictionary of parameter names and values to set on the instance.</p> required Source code in <code>aeromaps/models/parameters.py</code> <pre><code>def from_dict(self, data):\n    \"\"\"\n    Update attributes from a dictionary.\n\n    Parameters\n    ----------\n    data\n        Dictionary of parameter names and values to set on the instance.\n    \"\"\"\n    for key, value in data.items():\n        setattr(self, key, value)\n</code></pre>"},{"location":"full_doc/aeromaps.models.parameters/#aeromaps.models.parameters.Parameters.write_json","title":"write_json","text":"<pre><code>write_json(file_name='parameters.json')\n</code></pre> <p>Write parameters to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <p>Path to the output JSON file.</p> <code>'parameters.json'</code> Source code in <code>aeromaps/models/parameters.py</code> <pre><code>def write_json(self, file_name=\"parameters.json\"):\n    \"\"\"\n    Write parameters to a JSON file.\n\n    Parameters\n    ----------\n    file_name\n        Path to the output JSON file.\n    \"\"\"\n    with open(file_name, \"w\", encoding=\"utf-8\") as f:\n        dump(self.to_dict(), f, ignore_nan=True, ensure_ascii=False, indent=4)\n</code></pre>"},{"location":"full_doc/aeromaps.models.parameters/#aeromaps.models.parameters.Parameters.read_json","title":"read_json","text":"<pre><code>read_json(file_name='parameters.json')\n</code></pre> <p>Read parameters from a JSON file and update the instance.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <p>Path to the input JSON file.</p> <code>'parameters.json'</code> Source code in <code>aeromaps/models/parameters.py</code> <pre><code>def read_json(self, file_name=\"parameters.json\"):\n    \"\"\"\n    Read parameters from a JSON file and update the instance.\n\n    Parameters\n    ----------\n    file_name\n        Path to the input JSON file.\n    \"\"\"\n    data = _dict_from_json(file_name=file_name)\n\n    # Old reference data is kept\n    self.from_dict(data)\n</code></pre>"},{"location":"full_doc/aeromaps.models.parameters/#aeromaps.models.parameters.Parameters.read_json_direct","title":"read_json_direct","text":"<pre><code>read_json_direct(parameters_dict)\n</code></pre> <p>Load parameters from a dictionary-like object and update the instance.</p> <p>Parameters:</p> Name Type Description Default <code>parameters_dict</code> <p>Dictionary or object containing parameter keys and values.</p> required Source code in <code>aeromaps/models/parameters.py</code> <pre><code>def read_json_direct(self, parameters_dict):\n    \"\"\"\n    Load parameters from a dictionary-like object and update the instance.\n\n    Parameters\n    ----------\n    parameters_dict\n        Dictionary or object containing parameter keys and values.\n    \"\"\"\n    data = _dict_from_parameters_dict(parameters_dict)\n\n    # Old reference data is kept\n    self.from_dict(data)\n</code></pre>"},{"location":"full_doc/aeromaps.models.sustainability_assessment.climate.carbon_budgets/","title":"<code>aeromaps.models.sustainability_assessment.climate.carbon_budgets</code>","text":"<p>carbon_budgets</p> <p>================ This module contains models compute gross carbon budget related metrics.</p>"},{"location":"full_doc/aeromaps.models.sustainability_assessment.climate.carbon_budgets/#aeromaps.models.sustainability_assessment.climate.carbon_budgets.GrossCarbonBudget","title":"GrossCarbonBudget","text":"<pre><code>GrossCarbonBudget(name='gross_carbon_budget', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>This class computes gross carbon budget related metrics.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('gross_carbon_budget' by default).</p> <code>'gross_carbon_budget'</code> Source code in <code>aeromaps/models/sustainability_assessment/climate/carbon_budgets.py</code> <pre><code>def __init__(self, name=\"gross_carbon_budget\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.sustainability_assessment.climate.carbon_budgets/#aeromaps.models.sustainability_assessment.climate.carbon_budgets.GrossCarbonBudget.compute","title":"compute","text":"<pre><code>compute(net_carbon_budget, carbon_dioxyde_removal_2100, world_co2_emissions_2019, aviation_carbon_budget_allocated_share)\n</code></pre> <p>Gross carbon budget.</p> <p>Parameters:</p> Name Type Description Default <code>net_carbon_budget</code> <code>float</code> <p>Considered (net) carbon budget [GtCO2].</p> required <code>carbon_dioxyde_removal_2100</code> <code>float</code> <p>Cumulative Carbon Dioxide Removal (CDR) over 2020-2100 [GtCO2].</p> required <code>world_co2_emissions_2019</code> <code>float</code> <p>World CO2 emissions in 2019 [GtCO2].</p> required <code>aviation_carbon_budget_allocated_share</code> <code>float</code> <p>Share of the carbon budget allocated to aviation over 2020-2050 [%].</p> required Source code in <code>aeromaps/models/sustainability_assessment/climate/carbon_budgets.py</code> <pre><code>def compute(\n    self,\n    net_carbon_budget: float,\n    carbon_dioxyde_removal_2100: float,\n    world_co2_emissions_2019: float,\n    aviation_carbon_budget_allocated_share: float,\n) -&gt; Tuple[float, float, float]:\n    \"\"\"\n    Gross carbon budget.\n\n    Parameters\n    ----------\n    net_carbon_budget\n        Considered (net) carbon budget [GtCO2].\n    carbon_dioxyde_removal_2100\n        Cumulative Carbon Dioxide Removal (CDR) over 2020-2100 [GtCO2].\n    world_co2_emissions_2019\n        World CO2 emissions in 2019 [GtCO2].\n    aviation_carbon_budget_allocated_share\n        Share of the carbon budget allocated to aviation over 2020-2050 [%].\n    \"\"\"\n\n    gross_carbon_budget = net_carbon_budget + carbon_dioxyde_removal_2100\n\n    data = [gross_carbon_budget, world_co2_emissions_2019]\n\n    average_co2_emissions_decline_rate = float(\n        fsolve(self._compute_average_co2_emissions_decline_rate, -0.02, args=data)\n    )\n    gross_carbon_budget_2050 = (\n        world_co2_emissions_2019\n        * (\n            (1 - average_co2_emissions_decline_rate)\n            - (1 - average_co2_emissions_decline_rate) ** 32\n        )\n        / average_co2_emissions_decline_rate\n    )\n\n    aviation_carbon_budget = (\n        aviation_carbon_budget_allocated_share / 100 * gross_carbon_budget_2050\n    )\n\n    self.float_outputs[\"gross_carbon_budget\"] = gross_carbon_budget\n    self.float_outputs[\"gross_carbon_budget_2050\"] = gross_carbon_budget_2050\n    self.float_outputs[\"aviation_carbon_budget\"] = aviation_carbon_budget\n\n    return gross_carbon_budget, gross_carbon_budget_2050, aviation_carbon_budget\n</code></pre>"},{"location":"full_doc/aeromaps.models.sustainability_assessment.climate.equivalent_carbon_budgets/","title":"<code>aeromaps.models.sustainability_assessment.climate.equivalent_carbon_budgets</code>","text":"<p>equivalent_carbon_budgets</p> <p>=========================== Module to compute equivalent gross carbon budget and aviation equivalent carbon budget.</p>"},{"location":"full_doc/aeromaps.models.sustainability_assessment.climate.equivalent_carbon_budgets/#aeromaps.models.sustainability_assessment.climate.equivalent_carbon_budgets.EquivalentGrossCarbonBudget","title":"EquivalentGrossCarbonBudget","text":"<pre><code>EquivalentGrossCarbonBudget(name='equivalent_gross_carbon_budget', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>This class computes equivalent gross carbon budget and aviation equivalent carbon budget.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('equivalent_gross_carbon_budget' by default).</p> <code>'equivalent_gross_carbon_budget'</code> Source code in <code>aeromaps/models/sustainability_assessment/climate/equivalent_carbon_budgets.py</code> <pre><code>def __init__(self, name=\"equivalent_gross_carbon_budget\", *args, **kwargs):\n    super().__init__(name=name, *args, **kwargs)\n</code></pre>"},{"location":"full_doc/aeromaps.models.sustainability_assessment.climate.equivalent_carbon_budgets/#aeromaps.models.sustainability_assessment.climate.equivalent_carbon_budgets.EquivalentGrossCarbonBudget.compute","title":"compute","text":"<pre><code>compute(gross_carbon_budget, T_nonCO2, tcre_coefficient, world_ghg_emissions_2019, aviation_equivalentcarbonbudget_allocated_share)\n</code></pre> <p>Gross equivalent carbon budget.</p> <p>Parameters:</p> Name Type Description Default <code>gross_carbon_budget</code> <code>float</code> <p>World gross carbon budget [GtCO2].</p> required <code>T_nonCO2</code> <code>float</code> <p>Characteristic temperature for integrating non-CO2 effects into gross carbon budget calculation [\u00b0C].</p> required <code>tcre_coefficient</code> <code>float</code> <p>Transient Climate Response to cumulative Emissions of carbon dioxide coefficient [\u00b0C/GtCO2].</p> required <code>world_ghg_emissions_2019</code> <code>float</code> <p>World GHG emissions in 2019 [GtCO2e].</p> required <code>aviation_equivalentcarbonbudget_allocated_share</code> <code>float</code> <p>Share of the equivalent carbon budget allocated to aviation over 2020-2050 [%].</p> required <p>Returns:</p> Type Description <code>equivalent_gross_carbon_budget</code> <p>World equivalent gross carbon budget [GtCO2e].</p> <code>equivalent_gross_carbon_budget_2050</code> <p>World equivalent gross carbon budget until 2050 [GtCO2e].</p> <code>aviation_equivalent_carbon_budget</code> <p>Allocated equivalent carbon budget for aviation over 2020-2050 [GtCO2e].</p> Source code in <code>aeromaps/models/sustainability_assessment/climate/equivalent_carbon_budgets.py</code> <pre><code>def compute(\n    self,\n    gross_carbon_budget: float,\n    T_nonCO2: float,\n    tcre_coefficient: float,\n    world_ghg_emissions_2019: float,\n    aviation_equivalentcarbonbudget_allocated_share: float,\n) -&gt; Tuple[float, float, float]:\n    \"\"\"\n    Gross equivalent carbon budget.\n\n    Parameters\n    ----------\n    gross_carbon_budget\n        World gross carbon budget [GtCO2].\n    T_nonCO2\n        Characteristic temperature for integrating non-CO2 effects into gross carbon budget calculation [\u00b0C].\n    tcre_coefficient\n        Transient Climate Response to cumulative Emissions of carbon dioxide coefficient [\u00b0C/GtCO2].\n    world_ghg_emissions_2019\n        World GHG emissions in 2019 [GtCO2e].\n    aviation_equivalentcarbonbudget_allocated_share\n        Share of the equivalent carbon budget allocated to aviation over 2020-2050 [%].\n\n    Returns\n    -------\n    equivalent_gross_carbon_budget\n        World equivalent gross carbon budget [GtCO2e].\n    equivalent_gross_carbon_budget_2050\n        World equivalent gross carbon budget until 2050 [GtCO2e].\n    aviation_equivalent_carbon_budget\n        Allocated equivalent carbon budget for aviation over 2020-2050 [GtCO2e].\n    \"\"\"\n\n    equivalent_gross_carbon_budget = gross_carbon_budget + T_nonCO2 / tcre_coefficient\n\n    data = [equivalent_gross_carbon_budget, world_ghg_emissions_2019]\n\n    average_ghg_emissions_decline_rate = float(\n        fsolve(self._compute_average_ghg_emissions_decline_rate, -0.02, args=data)\n    )\n    equivalent_gross_carbon_budget_2050 = (\n        world_ghg_emissions_2019\n        * (\n            (1 - average_ghg_emissions_decline_rate)\n            - (1 - average_ghg_emissions_decline_rate) ** 32\n        )\n        / average_ghg_emissions_decline_rate\n    )\n\n    aviation_equivalent_carbon_budget = (\n        aviation_equivalentcarbonbudget_allocated_share\n        / 100\n        * equivalent_gross_carbon_budget_2050\n    )\n\n    self.float_outputs[\"equivalent_gross_carbon_budget\"] = equivalent_gross_carbon_budget\n    self.float_outputs[\"equivalent_gross_carbon_budget_2050\"] = (\n        equivalent_gross_carbon_budget_2050\n    )\n    self.float_outputs[\"aviation_equivalent_carbon_budget\"] = aviation_equivalent_carbon_budget\n\n    return (\n        equivalent_gross_carbon_budget,\n        equivalent_gross_carbon_budget_2050,\n        aviation_equivalent_carbon_budget,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.sustainability_assessment.climate/","title":"<code>aeromaps.models.sustainability_assessment.climate</code>","text":"<p>climate</p> <p>======== This package contains models related to carbon and equivalent carbon budget models.</p>"},{"location":"full_doc/aeromaps.models.sustainability_assessment/","title":"<code>aeromaps.models.sustainability_assessment</code>","text":"<p>sustainability_assessment</p> <p>============================= This package contains models related to the sustainability assessment.</p> Warning <p>Since energy availability was moved to impacts/energy_resource, it only contains carbon and equivalent carbon budget models for now.</p>"},{"location":"full_doc/aeromaps.models.templates/","title":"<code>aeromaps.models.templates</code>","text":"<p>Template classes to implement models in AeroMAPS.</p>"},{"location":"full_doc/aeromaps.models.templates/#aeromaps.models.templates.CustomTemplate","title":"CustomTemplate","text":"<pre><code>CustomTemplate(name='custom_template', configuration_file=None, *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>AeroMAPS model template to be used as a starting point for custom models. The compute() method of custom models does not need to explicitly define inputs, and outputs can be of varying size. However, inputs and outputs must be defined in the init method using input_names and output_names dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('custom_template' by default).</p> <code>'custom_template'</code> <code>configuration_file</code> <code>str</code> <p>Path to a configuration file (YAML) that contains user-defined input and output names and default values.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Source code in <code>aeromaps/models/templates.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"custom_template\",\n    configuration_file: str = None,\n    *args,\n    **kwargs,\n):\n    super().__init__(\n        name=name,\n        model_type=\"custom\",  # inputs/outputs are defined in __init__ rather than auto generated from compute() signature\n        *args,\n        **kwargs,\n    )\n\n    # Fill in explicit inputs and outputs with default values\n    self.input_names = {\"input1\": np.array([0.0]), \"input2\": np.array([0.0])}\n    self.output_names = {\"output1\": np.array([0.0]), \"output2\": np.array([0.0])}\n\n    # Read configuration file that contains user-defined data.\n    self.configuration_file = configuration_file\n    self.configuration_data = read_yaml_file(\n        configuration_file\n    )  # read and process configuration file\n\n    # Update inputs and outputs (name + default value) with user-defined data\n    if \"input_names\" in self.configuration_data:\n        for key, val in self.configuration_data[\"input_names\"].items():\n            self.input_names[key] = val\n    if \"output_names\" in self.configuration_data:\n        for key, val in self.configuration_data[\"output_names\"].items():\n            self.output_names[key] = val\n</code></pre>"},{"location":"full_doc/aeromaps.models.templates/#aeromaps.models.templates.CustomTemplate.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Compute the outputs based on the inputs.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/templates.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"\n    Compute the outputs based on the inputs.\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml files and outputs of other models.\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n\n    \"\"\"\n    # Get input data\n    input1 = input_data[\"input1\"]\n    input2 = input_data[\"input2\"]\n\n    # Initialize output data\n    output_data = {}\n\n    # perform computation on explicit inputs and add to output data\n    output_1 = input1 + input2\n    output_2 = input1 * input2\n    output_data[\"output_1\"] = output_1\n    output_data[\"output_1\"] = output_2\n\n    # perform computation on any input\n    for i, input in input_data:\n        output = input_data[input] ** 2  # any computation\n        output_data[f\"output_{i}\"] = output  # add to output data\n\n    # return output data\n    return {name: output_data[name] for name in self.output_names}\n</code></pre>"},{"location":"full_doc/aeromaps.models.templates/#aeromaps.models.templates.AutoTemplate","title":"AutoTemplate","text":"<pre><code>AutoTemplate(name='auto_template', *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>AeroMAPS model template to be used as a starting point for auto models. Auto models do not require definition of inputs and outputs in init method. Inputs and outputs are auto generated from compute() method signature. Therefore, the compute() method must explicitly define inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance ('auto_template' by default).</p> <code>'auto_template'</code> Source code in <code>aeromaps/models/templates.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"auto_template\",\n    *args,\n    **kwargs,\n):\n    super().__init__(\n        name=name,\n        model_type=\"auto\",  # inputs/outputs are auto generated from compute() signature\n        *args,\n        **kwargs,\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.models.templates/#aeromaps.models.templates.AutoTemplate.compute","title":"compute","text":"<pre><code>compute(input1, input2)\n</code></pre> <p>Compute the outputs based on the inputs.</p> <p>Parameters:</p> Name Type Description Default <code>input1</code> <p>First input variable.</p> required <code>input2</code> <p>Second input variable.</p> required <p>Returns:</p> Type Description <code>output1</code> <p>First output variable.</p> <code>output2</code> <p>Second output variable.</p> Source code in <code>aeromaps/models/templates.py</code> <pre><code>def compute(self, input1, input2) -&gt; Tuple[pd.Series, float]:\n    \"\"\"\n    Compute the outputs based on the inputs.\n\n    Parameters\n    ----------\n    input1\n        First input variable.\n    input2\n        Second input variable.\n\n    Returns\n    -------\n    output1\n        First output variable.\n    output2\n        Second output variable.\n\n    \"\"\"\n    output_1 = input1 * input2\n    output_2 = input2**2\n\n    return output_1, output_2\n</code></pre>"},{"location":"full_doc/aeromaps.models.yaml_interpolator/","title":"<code>aeromaps.models.yaml_interpolator</code>","text":""},{"location":"full_doc/aeromaps.models.yaml_interpolator/#aeromaps.models.yaml_interpolator--yaml-interpolator-model-for-aeromaps","title":"YAML Interpolator Model for AeroMAPS","text":"<p>This module defines a generic interpolation model that can be used in AeroMAPS to interpolate values based on user-defined reference years and values specified in a YAML configuration file.</p>"},{"location":"full_doc/aeromaps.models.yaml_interpolator/#aeromaps.models.yaml_interpolator.YAMLInterpolator","title":"YAMLInterpolator","text":"<pre><code>YAMLInterpolator(name, custom_data_type, *args, **kwargs)\n</code></pre> <p>               Bases: <code>AeroMAPSModel</code></p> <p>Generic interpolation model called each time an AeroMapsCustomDataType is used in the YAML configuration file of generic energy models.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the model instance.</p> required <code>custom_data_type</code> <code>AeroMapsCustomDataType</code> <p>Custom data type instance containing interpolation parameters.</p> required <p>Attributes:</p> Name Type Description <code>input_names</code> <code>dict</code> <p>Dictionary of input variable names populated at model initialisation before MDA chain creation.</p> <code>output_names</code> <code>dict</code> <p>Dictionary of output variable names populated at model initialisation before MDA chain creation.</p> Source code in <code>aeromaps/models/yaml_interpolator.py</code> <pre><code>def __init__(\n    self,\n    name,\n    custom_data_type,\n    *args,\n    **kwargs,\n):\n    super().__init__(\n        name=name,\n        model_type=\"custom\",\n        # inputs/outputs are defined in __init__ rather than auto generated from compute() signature\n        *args,\n        **kwargs,\n    )\n    # Get the name of the resource\n    self.value_name = name\n    self.custom_data_type = custom_data_type\n\n    self.input_names = {\n        f\"{self.value_name}_years\": custom_data_type.years,\n        f\"{self.value_name}_values\": custom_data_type.values,\n    }\n\n    self.output_names = {self.value_name: pd.Series([0.0])}\n</code></pre>"},{"location":"full_doc/aeromaps.models.yaml_interpolator/#aeromaps.models.yaml_interpolator.YAMLInterpolator.compute","title":"compute","text":"<pre><code>compute(input_data)\n</code></pre> <p>Execute the interpolation based on input data.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <p>Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml..</p> required <p>Returns:</p> Type Description <code>output_data</code> <p>Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.</p> Source code in <code>aeromaps/models/yaml_interpolator.py</code> <pre><code>def compute(self, input_data) -&gt; dict:\n    \"\"\"\n    Execute the interpolation based on input data.\n\n    Parameters\n    ----------\n    input_data\n        Dictionary containing all input data required for the computation, completed at model instantiation with information from yaml..\n\n    Returns\n    -------\n    output_data\n        Dictionary containing all output data resulting from the computation. Contains outputs defined during model instantiation.\n\n    \"\"\"\n    try:\n        interpolated_value = self._yaml_interpolation_function(\n            reference_years=input_data[f\"{self.value_name}_years\"],\n            reference_years_values=input_data[f\"{self.value_name}_values\"],\n            prospection_start_year=self.prospection_start_year,\n            end_year=self.end_year,\n            method=self.custom_data_type.method,\n            positive_constraint=self.custom_data_type.positive_constraint,\n            model_name=self.value_name,\n        )\n    except Exception as e:\n        raise RuntimeError(\n            f\"[YAMLInterpolator] Error while interpolating '{self.value_name}' \"\n            f\"with method '{self.custom_data_type.method}' \"\n            f\"(years and values lengths may mismatch): {e}\"\n        ) from e\n\n    output_data = {self.value_name: interpolated_value}\n    self._store_outputs(output_data)\n\n    return output_data\n</code></pre>"},{"location":"full_doc/aeromaps.utils.defaults/","title":"<code>aeromaps.utils.defaults</code>","text":""},{"location":"full_doc/aeromaps.utils.defaults/#aeromaps.utils.defaults.get_default_series","title":"get_default_series","text":"<pre><code>get_default_series(start_year, end_year, fill_value=0.0)\n</code></pre> <p>Create a pandas Series with years as index and a constant fill value.</p> <p>Parameters:</p> Name Type Description Default <code>start_year</code> <p>The starting year of the series.</p> required <code>end_year</code> <p>The ending year of the series.</p> required <code>fill_value</code> <p>The constant value to fill the series with (default is 0.0).</p> <code>0.0</code> <p>Returns:</p> Type Description <code>Series</code> <p>A pandas Series indexed by years from start_year to end_year, filled with fill_value.</p> Source code in <code>aeromaps/utils/defaults.py</code> <pre><code>def get_default_series(start_year, end_year, fill_value=0.0):\n    \"\"\"\n    Create a pandas Series with years as index and a constant fill value.\n\n    Parameters\n    ----------\n    start_year\n        The starting year of the series.\n    end_year\n        The ending year of the series.\n    fill_value\n        The constant value to fill the series with (default is 0.0).\n\n    Returns\n    -------\n    pd.Series\n        A pandas Series indexed by years from start_year to end_year, filled with fill_value.\n\n    \"\"\"\n    return pd.Series(\n        [fill_value] * len(range(start_year, end_year + 1)),\n        index=range(start_year, end_year + 1),\n    )\n</code></pre>"},{"location":"full_doc/aeromaps.utils.functions/","title":"<code>aeromaps.utils.functions</code>","text":""},{"location":"full_doc/aeromaps.utils.functions/#aeromaps.utils.functions.create_partitioning","title":"create_partitioning","text":"<pre><code>create_partitioning(file, path='')\n</code></pre> <p>Generation of a JSON input file (air transport data) and a CSV file (climate data) for running an AeroMAPS process for a partitioned scope.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <p>Path to the CSV file containing AeroSCOPE data for the partitioned scope.</p> required <code>path</code> <p>Directory path where the generated files will be saved.</p> <code>''</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>aeromaps/utils/functions.py</code> <pre><code>def create_partitioning(file, path=\"\"):\n    \"\"\"\n    Generation of a JSON input file (air transport data) and a CSV file (climate data) for running an AeroMAPS process for a partitioned scope.\n\n    Parameters\n    ----------\n    file\n        Path to the CSV file containing AeroSCOPE data for the partitioned scope.\n    path\n        Directory path where the generated files will be saved.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n\n    # World input data recovery\n    world_data_path = pth.join(data.__path__[0], \"parameters.json\")\n    with open(world_data_path, \"r\") as parameters_file:\n        world_data_dict = json.load(parameters_file)\n\n    # Assumption on freight\n    freight_energy_share_2019_partitioned = world_data_dict[\"freight_energy_share_2019\"]\n\n    # AeroSCOPE data recovery\n    partitioned_data_df = read_csv(file, delimiter=\",\")\n    partitioned_data = partitioned_data_df.values\n    total_ask_2019 = partitioned_data[0, 1]\n    short_range_ask_2019 = partitioned_data[0, 2]\n    medium_range_ask_2019 = partitioned_data[0, 3]\n    long_range_ask_2019 = partitioned_data[0, 4]\n    total_seats_2019 = partitioned_data[2, 1]\n    total_energy_consumption_per_ask_2019 = partitioned_data[4, 1]\n    short_range_energy_consumption_per_ask_2019 = partitioned_data[4, 2]\n    medium_range_energy_consumption_per_ask_2019 = partitioned_data[4, 3]\n    long_range_energy_consumption_per_ask_2019 = partitioned_data[4, 4]\n    total_energy_consumption_2019 = (\n        total_energy_consumption_per_ask_2019\n        * total_ask_2019\n        / (1 - freight_energy_share_2019_partitioned / 2 / 100)\n    )  # Dedicated freight (half of total freight) not included in AeroSCOPE\n    short_range_energy_consumption_2019 = (\n        short_range_energy_consumption_per_ask_2019 * short_range_ask_2019\n    ) * (1 - 0.075 / (1 - 0.075))\n    medium_range_energy_consumption_2019 = (\n        medium_range_energy_consumption_per_ask_2019 * medium_range_ask_2019\n    ) * (1 - 0.075 / (1 - 0.075))\n    long_range_energy_consumption_2019 = (\n        long_range_energy_consumption_per_ask_2019 * long_range_ask_2019\n    ) * (1 - 0.075 / (1 - 0.075))\n\n    # Calculation of the partitioned input values\n\n    ## Float inputs\n    short_range_energy_share_2019_partitioned = (\n        short_range_energy_consumption_2019 / total_energy_consumption_2019 * 100\n    )\n    medium_range_energy_share_2019_partitioned = (\n        medium_range_energy_consumption_2019 / total_energy_consumption_2019 * 100\n    )\n    long_range_energy_share_2019_partitioned = (\n        long_range_energy_consumption_2019 / total_energy_consumption_2019 * 100\n    )\n    short_range_rpk_share_2019_partitioned = short_range_ask_2019 / total_ask_2019 * 100\n    medium_range_rpk_share_2019_partitioned = medium_range_ask_2019 / total_ask_2019 * 100\n    long_range_rpk_share_2019_partitioned = long_range_ask_2019 / total_ask_2019 * 100\n    commercial_aviation_coefficient_partitioned = 1\n\n    ## Vector inputs\n    share_ask_partitioned_vs_world_2019 = total_ask_2019 / world_data_dict[\"ask_init\"][19] * 100\n    share_seats_partitioned_vs_world_2019 = total_seats_2019 / (\n        world_data_dict[\"pax_init\"][19]\n        * world_data_dict[\"ask_init\"][19]\n        / world_data_dict[\"rpk_init\"][19]\n        * 100\n    )\n    share_energy_consumption_partitioned_vs_world_2019 = (\n        total_energy_consumption_2019 / world_data_dict[\"energy_consumption_init\"][19] * 100\n    )\n    rpk_init_partitioned = []\n    ask_init_partitioned = []\n    rtk_init_partitioned = []\n    total_aircraft_distance_init_partitioned = []\n    freight_init_partitioned = []\n    pax_init_partitioned = []\n    energy_consumption_init_partitioned = []\n    for k in range(0, 20):\n        rpk_init_partitioned.append(\n            world_data_dict[\"rpk_init\"][k] * share_ask_partitioned_vs_world_2019 / 100\n        )\n        ask_init_partitioned.append(\n            world_data_dict[\"ask_init\"][k] * share_ask_partitioned_vs_world_2019 / 100\n        )\n        rtk_init_partitioned.append(\n            world_data_dict[\"rtk_init\"][k] * share_ask_partitioned_vs_world_2019 / 100\n        )\n        freight_init_partitioned.append(\n            world_data_dict[\"freight_init\"][k] * share_ask_partitioned_vs_world_2019 / 100\n        )\n        total_aircraft_distance_init_partitioned.append(\n            world_data_dict[\"total_aircraft_distance_init\"][k]\n            * share_ask_partitioned_vs_world_2019\n            / 100\n        )\n        pax_init_partitioned.append(\n            world_data_dict[\"pax_init\"][k] * share_seats_partitioned_vs_world_2019 / 100\n        )\n        energy_consumption_init_partitioned.append(\n            world_data_dict[\"energy_consumption_init\"][k]\n            * share_energy_consumption_partitioned_vs_world_2019\n            / 100\n        )\n\n    # TODO move historic and prospection start year out of custom input file\n\n    historic_start_year_partitioned = world_data_dict[\"historic_start_year\"]\n    prospection_start_year_partitioned = world_data_dict[\"prospection_start_year\"]\n\n    # Generation of the JSON file\n    partitioned_inputs_dict = {\n        \"rpk_init\": rpk_init_partitioned,\n        \"ask_init\": ask_init_partitioned,\n        \"rtk_init\": rtk_init_partitioned,\n        \"pax_init\": pax_init_partitioned,\n        \"freight_init\": freight_init_partitioned,\n        \"energy_consumption_init\": energy_consumption_init_partitioned,\n        \"total_aircraft_distance_init\": total_aircraft_distance_init_partitioned,\n        \"short_range_energy_share_2019\": short_range_energy_share_2019_partitioned,\n        \"medium_range_energy_share_2019\": medium_range_energy_share_2019_partitioned,\n        \"long_range_energy_share_2019\": long_range_energy_share_2019_partitioned,\n        \"freight_energy_share_2019\": freight_energy_share_2019_partitioned,\n        \"short_range_rpk_share_2019\": short_range_rpk_share_2019_partitioned,\n        \"medium_range_rpk_share_2019\": medium_range_rpk_share_2019_partitioned,\n        \"long_range_rpk_share_2019\": long_range_rpk_share_2019_partitioned,\n        \"commercial_aviation_coefficient\": commercial_aviation_coefficient_partitioned,\n        \"historic_start_year\": historic_start_year_partitioned,\n        \"prospection_start_year\": prospection_start_year_partitioned,\n    }\n    partitioned_inputs_path = pth.join(path, \"partitioned_inputs.json\")\n    with open(partitioned_inputs_path, \"w\") as outfile:\n        json.dump(partitioned_inputs_dict, outfile)\n\n    # Create a CSV file for initialisation of vector inputs.\n    # TODO: not necessary without optim, check relevance of the process?\n    vector_inputs_df = pd.DataFrame(\n        {\n            \"rpk_init\": rpk_init_partitioned,\n            \"ask_init\": ask_init_partitioned,\n            \"rtk_init\": rtk_init_partitioned,\n            \"pax_init\": pax_init_partitioned,\n            \"freight_init\": freight_init_partitioned,\n            \"energy_consumption_init\": energy_consumption_init_partitioned,\n            \"total_aircraft_distance_init\": total_aircraft_distance_init_partitioned,\n        },\n        index=range(historic_start_year_partitioned, prospection_start_year_partitioned),\n    )\n\n    vector_inputs_path = pth.join(path, \"vector_inputs_partitioned.csv\")\n    vector_inputs_df.to_csv(vector_inputs_path, sep=\";\")\n\n    # Generation of a CSV file for using climate models\n    climate_world_data_path = pth.join(\n        climate_data.__path__[0], \"temperature_historical_dataset.csv\"\n    )\n    climate_world_data_df = pd.read_csv(climate_world_data_path, delimiter=\";\", header=None)\n    climate_world_data = climate_world_data_df.values\n    climate_world_data_years = climate_world_data[:, 0]\n    climate_world_data_co2_emissions = climate_world_data[:, 1]\n    climate_world_data_nox_emissions = climate_world_data[:, 2]\n    climate_world_data_h2o_emissions = climate_world_data[:, 3]\n    climate_world_data_soot_emissions = climate_world_data[:, 4]\n    climate_world_data_sulfur_emissions = climate_world_data[:, 5]\n    climate_world_data_distance = climate_world_data[:, 6]\n    climate_partitioned_data_years = climate_world_data_years\n    climate_partitioned_data_co2_emissions = (\n        climate_world_data_co2_emissions * share_energy_consumption_partitioned_vs_world_2019 / 100\n    )\n    climate_partitioned_data_nox_emissions = (\n        climate_world_data_nox_emissions * share_energy_consumption_partitioned_vs_world_2019 / 100\n    )\n    climate_partitioned_data_h2o_emissions = (\n        climate_world_data_h2o_emissions * share_energy_consumption_partitioned_vs_world_2019 / 100\n    )\n    climate_partitioned_data_soot_emissions = (\n        climate_world_data_soot_emissions * share_energy_consumption_partitioned_vs_world_2019 / 100\n    )\n    climate_partitioned_data_sulfur_emissions = (\n        climate_world_data_sulfur_emissions\n        * share_energy_consumption_partitioned_vs_world_2019\n        / 100\n    )\n    climate_partitioned_data_distance = (\n        climate_world_data_distance * share_ask_partitioned_vs_world_2019 / 100\n    )\n    climate_partitioned_data_years_number = len(climate_partitioned_data_years)\n    partitioned_historical_climate_dataset = np.zeros((climate_partitioned_data_years_number, 7))\n    for k in range(0, climate_partitioned_data_years_number):\n        partitioned_historical_climate_dataset[k, 0] = climate_partitioned_data_years[k]\n        partitioned_historical_climate_dataset[k, 1] = climate_partitioned_data_co2_emissions[k]\n        partitioned_historical_climate_dataset[k, 2] = climate_partitioned_data_nox_emissions[k]\n        partitioned_historical_climate_dataset[k, 3] = climate_partitioned_data_h2o_emissions[k]\n        partitioned_historical_climate_dataset[k, 4] = climate_partitioned_data_soot_emissions[k]\n        partitioned_historical_climate_dataset[k, 5] = climate_partitioned_data_sulfur_emissions[k]\n        partitioned_historical_climate_dataset[k, 6] = climate_partitioned_data_distance[k]\n    climate_partitioned_data_path = pth.join(path, \"partitioned_temperature_historical_dataset.csv\")\n    np.savetxt(climate_partitioned_data_path, partitioned_historical_climate_dataset, delimiter=\";\")\n\n    return\n</code></pre>"},{"location":"full_doc/aeromaps.utils.functions/#aeromaps.utils.functions.merge_json_files","title":"merge_json_files","text":"<pre><code>merge_json_files(file1, file2, output_file)\n</code></pre> <p>Merge two JSON files into a single JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>file1</code> <p>Path to the first JSON file.</p> required <code>file2</code> <p>Path to the second JSON file.</p> required <code>output_file</code> <p>Path to the output JSON file where the merged content will be saved.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>aeromaps/utils/functions.py</code> <pre><code>def merge_json_files(file1, file2, output_file):\n    \"\"\"\n    Merge two JSON files into a single JSON file.\n\n    Parameters\n    ----------\n    file1\n        Path to the first JSON file.\n    file2\n        Path to the second JSON file.\n    output_file\n        Path to the output JSON file where the merged content will be saved.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    with open(file1, \"r\") as f1, open(file2, \"r\") as f2:\n        data1 = json.load(f1)\n        data2 = json.load(f2)\n\n    merged_data = {**data1, **data2}\n\n    with open(output_file, \"w\") as outfile:\n        json.dump(merged_data, outfile, indent=4)\n</code></pre>"},{"location":"full_doc/aeromaps.utils.functions/#aeromaps.utils.functions.compare_json_files","title":"compare_json_files","text":"<pre><code>compare_json_files(file1_path, file2_path, ignore_order=False, verbose=True, rtol=0.0001, atol=0.1)\n</code></pre> <p>Compare two JSON files using deepdiff and return whether differences exist.</p> <p>Parameters:</p> Name Type Description Default <code>file1_path</code> <code>str</code> <p>Path to the first JSON file.</p> required <code>file2_path</code> <code>str</code> <p>Path to the second JSON file.</p> required <code>ignore_order</code> <code>bool</code> <p>Whether to ignore the order in lists.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print differences.</p> <code>True</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for numeric comparisons.</p> <code>0.0001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for numeric comparisons.</p> <code>0.1</code> <p>Returns:</p> Type Description <code>differences_exist</code> <p>True if differences exist between the two JSON files, False otherwise.</p> Source code in <code>aeromaps/utils/functions.py</code> <pre><code>def compare_json_files(\n    file1_path: str,\n    file2_path: str,\n    ignore_order: bool = False,\n    verbose: bool = True,\n    rtol: float = 0.0001,\n    atol: float = 0.1,\n) -&gt; bool:\n    \"\"\"\n    Compare two JSON files using deepdiff and return whether differences exist.\n\n    Parameters\n    ----------\n    file1_path\n        Path to the first JSON file.\n    file2_path\n        Path to the second JSON file.\n    ignore_order\n        Whether to ignore the order in lists.\n    verbose\n        Whether to print differences.\n    rtol\n        Relative tolerance for numeric comparisons.\n    atol\n        Absolute tolerance for numeric comparisons.\n\n    Returns\n    -------\n    differences_exist\n        True if differences exist between the two JSON files, False otherwise.\n    \"\"\"\n    with open(file1_path, \"r\") as f1, open(file2_path, \"r\") as f2:\n        json1 = json.load(f1)\n        json2 = json.load(f2)\n\n    diff = DeepDiff(\n        json1,\n        json2,\n        ignore_order=ignore_order,\n        exclude_paths=False or [],\n    )\n\n    # Remove value changes that are within tolerance\n    if \"values_changed\" in diff:\n        keys_to_remove = []\n        for key, value in diff[\"values_changed\"].items():\n            if isinstance(value, dict) and \"new_value\" in value and \"old_value\" in value:\n                new_value = value[\"new_value\"]\n                old_value = value[\"old_value\"]\n                if (\n                    isinstance(new_value, (float, int))\n                    and isinstance(old_value, (float, int))\n                    and np.isclose(new_value, old_value, rtol=rtol, atol=atol, equal_nan=True)\n                ):\n                    keys_to_remove.append(key)\n                elif isinstance(new_value, dict) and isinstance(old_value, dict):\n                    # Check if all numeric values in the dict are close enough\n                    if all(\n                        np.isclose(new_value[k], old_value[k], rtol=rtol, atol=atol, equal_nan=True)\n                        for k in new_value\n                        if isinstance(new_value[k], (float, int))\n                        and k in old_value\n                        and isinstance(old_value[k], (float, int))\n                    ):\n                        keys_to_remove.append(key)\n        for key in keys_to_remove:\n            del diff[\"values_changed\"][key]\n        if not diff[\"values_changed\"]:\n            del diff[\"values_changed\"]\n\n    # Clean up iterable diffs by removing items that are close enough to something in the other JSON\n    iterable_messages = []\n\n    def cleanup_iterable_diff(tag, other_json):\n        if tag in diff:\n            keys_to_remove = []\n            for key, value in diff[tag].items():\n                # The path looks like \"root['some_list'][2]\"\n                prefix, idx_str = key.rsplit(\"[\", 1)\n                idx = idx_str[:-1]  # Remove the trailing ']'\n                other_parent = eval(prefix.replace(\"root\", \"other_json\"))\n                if isinstance(other_parent, list):\n                    if np.isclose(\n                        value, other_parent[int(idx)], rtol=rtol, atol=atol, equal_nan=True\n                    ):\n                        keys_to_remove.append(key)\n                    else:\n                        iterable_messages.append(\n                            f\"For: {prefix}, index {idx} beyond tolerance: {value} against {other_parent[int(idx)]}\"\n                        )\n            for k in keys_to_remove:\n                del diff[tag][k]\n            if not diff[tag]:\n                del diff[tag]\n\n    cleanup_iterable_diff(\"iterable_item_added\", json1)\n    cleanup_iterable_diff(\"iterable_item_removed\", json2)\n\n    if verbose:\n        if diff or iterable_messages:\n            print(\"Differences found:\")\n            if diff:\n                print(json.dumps(diff, indent=2, default=convert_non_serializable))\n            if iterable_messages:\n                for message in iterable_messages:\n                    print(message)\n        else:\n            print(\"No differences found.\")\n    return bool(diff)\n</code></pre>"},{"location":"full_doc/aeromaps.utils.functions/#aeromaps.utils.functions.convert_non_serializable","title":"convert_non_serializable","text":"<pre><code>convert_non_serializable(obj)\n</code></pre> <p>Convert non-serializable objects to a serializable format for JSON output.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <p>The object to convert.</p> required <p>Returns:</p> Type Description <code>serializable</code> <p>A JSON-serializable representation of the object.</p> Source code in <code>aeromaps/utils/functions.py</code> <pre><code>def convert_non_serializable(obj):\n    \"\"\"\n    Convert non-serializable objects to a serializable format for JSON output.\n\n    Parameters\n    ----------\n    obj\n        The object to convert.\n\n    Returns\n    -------\n    serializable\n        A JSON-serializable representation of the object.\n\n    \"\"\"\n    # Native containers -&gt; convert to list\n    if isinstance(obj, (set, list, tuple)):\n        return list(obj)\n\n    # If it's an iterable (but not a string/bytes/mapping), try to convert to list.\n    # This handles deepdiff.SetOrdered and similar container-like types that don't\n    # expose useful __dict__ contents.\n    if not isinstance(obj, (str, bytes, dict)) and hasattr(obj, \"__iter__\"):\n        try:\n            lst = list(obj)\n            return lst\n        except Exception:\n            # If it cannot be converted to a list, fall through to other handlers\n            pass\n\n    # If object has a non-empty __dict__, prefer that (useful for plain objects)\n    if hasattr(obj, \"__dict__\") and obj.__dict__:\n        # Optional debug left intentionally minimal\n        # print('Converting using __dict__', obj)\n        return obj.__dict__\n\n    # Last resort: convert to string\n    return str(obj)\n</code></pre>"},{"location":"full_doc/aeromaps.utils.functions/#aeromaps.utils.functions.custom_logger_config","title":"custom_logger_config","text":"<pre><code>custom_logger_config(logger)\n</code></pre> <p>Specific filter to remove a warning triggered in the absence of a docstring in each discipline. Hopefully temporary!!!</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <p>The logger to configure.</p> required <p>Returns:</p> Type Description <code>logger</code> <p>The configured logger with the custom filter applied.</p> Source code in <code>aeromaps/utils/functions.py</code> <pre><code>def custom_logger_config(logger):\n    \"\"\"\n    Specific filter to remove a warning triggered in the absence of a docstring in each discipline.\n    Hopefully temporary!!!\n\n\n    Parameters\n    ----------\n    logger\n        The logger to configure.\n\n    Returns\n    -------\n    logger\n        The configured logger with the custom filter applied.\n\n    \"\"\"\n\n    # Specific filter to remove a warning triggered in the absence of a docstring in each discipline.\n    class SuppressArgsSectionWarning(logging.Filter):\n        def filter(self, record: logging.LogRecord) -&gt; bool:\n            return record.getMessage() != \"The Args section is missing.\"\n\n    for handler in logger.handlers:\n        handler.addFilter(SuppressArgsSectionWarning())\n\n    return logger\n</code></pre>"},{"location":"full_doc/aeromaps.utils.functions/#aeromaps.utils.functions.clean_notebooks_on_tests","title":"clean_notebooks_on_tests","text":"<pre><code>clean_notebooks_on_tests(namespace=None, force_cleanup=False)\n</code></pre> <p>Clean up the notebook namespace by deleting variables when running tests or when forced to save semaphore memory.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <p>The namespace (dictionary) to clean. If None, uses globals().</p> <code>None</code> <code>force_cleanup</code> <p>If True, forces cleanup regardless of test detection.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>aeromaps/utils/functions.py</code> <pre><code>def clean_notebooks_on_tests(namespace=None, force_cleanup=False):\n    \"\"\"\n    Clean up the notebook namespace by deleting variables when running tests or when forced to save semaphore memory.\n\n    Parameters\n    ----------\n    namespace\n        The namespace (dictionary) to clean. If None, uses globals().\n    force_cleanup\n        If True, forces cleanup regardless of test detection.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    import os\n    import gc\n\n    logger = logging.getLogger(\"aeromaps.utils.functions\")\n    logger.info(\"\ud83e\uddf9 clean_notebooks_on_tests called\")\n\n    if namespace is None:\n        namespace = globals()\n    RUNNING_TEST = os.environ.get(\"PYTEST_CURRENT_TEST\") is not None\n\n    if RUNNING_TEST or force_cleanup:\n        logger.info(\"\ud83e\uddea Detected test run or force cleanup\")\n        to_delete = [\n            var\n            for var in list(namespace.keys())\n            if not var.startswith(\"_\")\n            and var not in (\"os\", \"gc\", \"RUNNING_TEST\", \"clean_notebooks_on_tests\", \"namespace\")\n        ]\n        for var in to_delete:\n            del namespace[var]\n        gc.collect()\n        logger.info(f\"\u2705 Cleaned up {len(to_delete)} variables\")\n    else:\n        logger.info(\"\u23ed Skipping cleanup during notebook run\")\n</code></pre>"},{"location":"full_doc/aeromaps.utils/","title":"<code>aeromaps.utils</code>","text":""},{"location":"full_doc/aeromaps.utils.yaml/","title":"<code>aeromaps.utils.yaml</code>","text":""},{"location":"full_doc/aeromaps.utils.yaml/#aeromaps.utils.yaml.aeromaps_custom_data_type_constructor","title":"aeromaps_custom_data_type_constructor","text":"<pre><code>aeromaps_custom_data_type_constructor(loader, node)\n</code></pre> <p>Custom constructor to handle specific interpolation input types in yaml files.</p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>Loader</code> <p>The YAML loader instance.</p> required <code>node</code> <code>Node</code> <p>The YAML node to be constructed.</p> required Source code in <code>aeromaps/utils/yaml.py</code> <pre><code>def aeromaps_custom_data_type_constructor(loader, node):\n    \"\"\"\n    Custom constructor to handle specific interpolation input types in yaml files.\n\n    Parameters\n    ----------\n    loader : yaml.Loader\n        The YAML loader instance.\n    node : yaml.Node\n        The YAML node to be constructed.\n    \"\"\"\n    value = loader.construct_mapping(node, deep=True)\n    return AeroMapsCustomDataType(value)\n</code></pre>"},{"location":"full_doc/aeromaps.utils.yaml/#aeromaps.utils.yaml.read_yaml_file","title":"read_yaml_file","text":"<pre><code>read_yaml_file(file_name='parameters.yaml')\n</code></pre> <p>Example function to read a YAML file and returns its contents as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>The path to the YAML file to be read (default is \"parameters.yaml\").</p> <code>'parameters.yaml'</code> <p>Returns:</p> Type Description <code>dict</code> <p>The contents of the YAML file as a dictionary.</p> Source code in <code>aeromaps/utils/yaml.py</code> <pre><code>def read_yaml_file(file_name=\"parameters.yaml\"):\n    \"\"\"\n    Example function to read a YAML file and returns its contents as a dictionary.\n\n    Parameters\n    ----------\n    file_name : str\n        The path to the YAML file to be read (default is \"parameters.yaml\").\n\n    Returns\n    -------\n    dict\n        The contents of the YAML file as a dictionary.\n    \"\"\"\n    try:\n        with open(file_name, \"r\", encoding=\"utf-8\") as file:\n            data = yaml.load(file, Loader=yaml.Loader)\n            return data if isinstance(data, dict) else {}\n    except Exception as e:\n        print(f\"Error reading YAML file: {e}\")\n        return {}\n</code></pre>"},{"location":"notebooks/examples_basic/","title":"Basic example for using AeroMAPS with Jupyter Notebook","text":"In\u00a0[\u00a0]: Copied! <pre>%matplotlib widget\nfrom aeromaps import create_process\nfrom aeromaps.core.models import (\n    models_traffic,\n    models_efficiency_top_down,\n    models_energy_without_fuel_effect,\n    models_offset,\n    models_climate_gwpstar,\n    models_sustainability,\n    models_energy_cost,\n    models_operation_cost_top_down,\n)\n</pre> %matplotlib widget from aeromaps import create_process from aeromaps.core.models import (     models_traffic,     models_efficiency_top_down,     models_energy_without_fuel_effect,     models_offset,     models_climate_gwpstar,     models_sustainability,     models_energy_cost,     models_operation_cost_top_down, ) In\u00a0[\u00a0]: Copied! <pre>models = {\n    \"models_traffic\": models_traffic,\n    \"models_efficiency_top_down\": models_efficiency_top_down,\n    \"models_energy_without_fuel_effect\": models_energy_without_fuel_effect,\n    \"models_offset\": models_offset,\n    \"models_climate_gwpstar\": models_climate_gwpstar,\n    \"models_sustainability\": models_sustainability,\n    \"models_energy_cost\": models_energy_cost,\n    \"models_operation_cost_top_down\": models_operation_cost_top_down,\n}\n\n# Default generic energy models and configuration used\n</pre> models = {     \"models_traffic\": models_traffic,     \"models_efficiency_top_down\": models_efficiency_top_down,     \"models_energy_without_fuel_effect\": models_energy_without_fuel_effect,     \"models_offset\": models_offset,     \"models_climate_gwpstar\": models_climate_gwpstar,     \"models_sustainability\": models_sustainability,     \"models_energy_cost\": models_energy_cost,     \"models_operation_cost_top_down\": models_operation_cost_top_down, }  # Default generic energy models and configuration used In\u00a0[\u00a0]: Copied! <pre>process = create_process(configuration_file=\"data/config.json\", models=models)\n</pre> process = create_process(configuration_file=\"data/config.json\", models=models) In\u00a0[\u00a0]: Copied! <pre># process.list_float_inputs()\n</pre> # process.list_float_inputs() <p>In the following, some main parameters are for instance set up.</p> In\u00a0[\u00a0]: Copied! <pre># Air traffic evolution\n\n## Growth rate by category [%]\nprocess.parameters.cagr_passenger_short_range_reference_periods = [2020, 2030, 2040, 2050]\nprocess.parameters.cagr_passenger_short_range_reference_periods_values = [3.0, 2.0, 1.0]\nprocess.parameters.cagr_passenger_medium_range_reference_periods = []\nprocess.parameters.cagr_passenger_medium_range_reference_periods_values = [3.0]\nprocess.parameters.cagr_passenger_long_range_reference_periods = []\nprocess.parameters.cagr_passenger_long_range_reference_periods_values = [3.0]\nprocess.parameters.cagr_freight_reference_periods = []\nprocess.parameters.cagr_freight_reference_periods_values = [3.0]\n</pre> # Air traffic evolution  ## Growth rate by category [%] process.parameters.cagr_passenger_short_range_reference_periods = [2020, 2030, 2040, 2050] process.parameters.cagr_passenger_short_range_reference_periods_values = [3.0, 2.0, 1.0] process.parameters.cagr_passenger_medium_range_reference_periods = [] process.parameters.cagr_passenger_medium_range_reference_periods_values = [3.0] process.parameters.cagr_passenger_long_range_reference_periods = [] process.parameters.cagr_passenger_long_range_reference_periods_values = [3.0] process.parameters.cagr_freight_reference_periods = [] process.parameters.cagr_freight_reference_periods_values = [3.0] In\u00a0[\u00a0]: Copied! <pre># Aircraft fleet and operation evolution - Aircraft load factor\n\n## Aircraft load factor in 2050 [%]\nprocess.parameters.load_factor_end_year = 85.0  # 2019 value: 82.399312\n</pre> # Aircraft fleet and operation evolution - Aircraft load factor  ## Aircraft load factor in 2050 [%] process.parameters.load_factor_end_year = 85.0  # 2019 value: 82.399312 In\u00a0[\u00a0]: Copied! <pre># Aircraft fleet and operation evolution - Aircraft efficiency using the top-down approach\n\n## Drop-in aircraft\n### Mean annual efficiency gains by category [%]\nprocess.parameters.energy_per_ask_short_range_dropin_fuel_gain_reference_years = []\nprocess.parameters.energy_per_ask_short_range_dropin_fuel_gain_reference_years_values = [1.5]\nprocess.parameters.energy_per_ask_medium_range_dropin_fuel_gain_reference_years = []\nprocess.parameters.energy_per_ask_medium_range_dropin_fuel_gain_reference_years_values = [1.5]\nprocess.parameters.energy_per_ask_long_range_dropin_fuel_gain_reference_years = []\nprocess.parameters.energy_per_ask_long_range_dropin_fuel_gain_reference_years_values = [1.5]\n\n## Hydrogen aircraft\n### Values for setting logistic functions by category\nprocess.parameters.hydrogen_final_market_share_short_range = 50.0  # [%]\nprocess.parameters.hydrogen_introduction_year_short_range = 2035\nprocess.parameters.fleet_renewal_duration = 20.0\n### Relative energy consumption for hydrogen aircraft with respect to drop-in aircraft [%]\nprocess.parameters.relative_energy_per_ask_hydrogen_wrt_dropin_short_range_reference_years = []\nprocess.parameters.relative_energy_per_ask_hydrogen_wrt_dropin_short_range_reference_years_values = [\n    1.0\n]\n</pre> # Aircraft fleet and operation evolution - Aircraft efficiency using the top-down approach  ## Drop-in aircraft ### Mean annual efficiency gains by category [%] process.parameters.energy_per_ask_short_range_dropin_fuel_gain_reference_years = [] process.parameters.energy_per_ask_short_range_dropin_fuel_gain_reference_years_values = [1.5] process.parameters.energy_per_ask_medium_range_dropin_fuel_gain_reference_years = [] process.parameters.energy_per_ask_medium_range_dropin_fuel_gain_reference_years_values = [1.5] process.parameters.energy_per_ask_long_range_dropin_fuel_gain_reference_years = [] process.parameters.energy_per_ask_long_range_dropin_fuel_gain_reference_years_values = [1.5]  ## Hydrogen aircraft ### Values for setting logistic functions by category process.parameters.hydrogen_final_market_share_short_range = 50.0  # [%] process.parameters.hydrogen_introduction_year_short_range = 2035 process.parameters.fleet_renewal_duration = 20.0 ### Relative energy consumption for hydrogen aircraft with respect to drop-in aircraft [%] process.parameters.relative_energy_per_ask_hydrogen_wrt_dropin_short_range_reference_years = [] process.parameters.relative_energy_per_ask_hydrogen_wrt_dropin_short_range_reference_years_values = [     1.0 ] In\u00a0[\u00a0]: Copied! <pre># Aircraft fleet and operation evolution - Operations\n\n## Values for setting the logistic function\nprocess.parameters.operations_final_gain = 8.0  # [%]\nprocess.parameters.operations_start_year = 2025\nprocess.parameters.operations_duration = 25.0\n</pre> # Aircraft fleet and operation evolution - Operations  ## Values for setting the logistic function process.parameters.operations_final_gain = 8.0  # [%] process.parameters.operations_start_year = 2025 process.parameters.operations_duration = 25.0 In\u00a0[\u00a0]: Copied! <pre># Aircraft energy - Introduction of alternative drop-in fuels\n\n## Share of alternative fuels in the drop-in fuel mix (the rest being supplemented by kerosene) [%]\nprocess.parameters.biofuel_share_reference_years = [2020, 2030, 2040, 2050]\nprocess.parameters.biofuel_share_reference_years_values = [0.0, 4.8, 24.0, 35.0]\nprocess.parameters.electrofuel_share_reference_years = [2020, 2030, 2040, 2050]\nprocess.parameters.electrofuel_share_reference_years_values = [0.0, 1.2, 10.0, 35.0]\n</pre> # Aircraft energy - Introduction of alternative drop-in fuels  ## Share of alternative fuels in the drop-in fuel mix (the rest being supplemented by kerosene) [%] process.parameters.biofuel_share_reference_years = [2020, 2030, 2040, 2050] process.parameters.biofuel_share_reference_years_values = [0.0, 4.8, 24.0, 35.0] process.parameters.electrofuel_share_reference_years = [2020, 2030, 2040, 2050] process.parameters.electrofuel_share_reference_years_values = [0.0, 1.2, 10.0, 35.0] In\u00a0[\u00a0]: Copied! <pre># Carbon offset\nprocess.parameters.carbon_offset_baseline_level_vs_2019_reference_periods = [2020, 2024, 2050]\nprocess.parameters.carbon_offset_baseline_level_vs_2019_reference_periods_values = [100.0, 85.0]\nprocess.parameters.residual_carbon_offset_share_reference_years = [2020, 2030, 2040, 2050]\nprocess.parameters.residual_carbon_offset_share_reference_years_values = [0.0, 0.0, 20.0, 50.0]\n</pre> # Carbon offset process.parameters.carbon_offset_baseline_level_vs_2019_reference_periods = [2020, 2024, 2050] process.parameters.carbon_offset_baseline_level_vs_2019_reference_periods_values = [100.0, 85.0] process.parameters.residual_carbon_offset_share_reference_years = [2020, 2030, 2040, 2050] process.parameters.residual_carbon_offset_share_reference_years_values = [0.0, 0.0, 20.0, 50.0] In\u00a0[\u00a0]: Copied! <pre># Environmental limits\n\n## Carbon budgets and Carbon Dioxide Removal [GtCO2]\nprocess.parameters.net_carbon_budget = 850.0\nprocess.parameters.carbon_dioxyde_removal_2100 = 280.0\n\n## Available energy resources in 2050 [EJ]\n# process.parameters.waste_biomass = 12.0\n# process.parameters.crops_biomass = 63.0\n# process.parameters.forest_residues_biomass = 17.0\n# process.parameters.agricultural_residues_biomass = 57.0\n# process.parameters.algae_biomass = 15.0\n# process.parameters.available_electricity = 250.0\n</pre> # Environmental limits  ## Carbon budgets and Carbon Dioxide Removal [GtCO2] process.parameters.net_carbon_budget = 850.0 process.parameters.carbon_dioxyde_removal_2100 = 280.0  ## Available energy resources in 2050 [EJ] # process.parameters.waste_biomass = 12.0 # process.parameters.crops_biomass = 63.0 # process.parameters.forest_residues_biomass = 17.0 # process.parameters.agricultural_residues_biomass = 57.0 # process.parameters.algae_biomass = 15.0 # process.parameters.available_electricity = 250.0 In\u00a0[\u00a0]: Copied! <pre># Allocation settings\n\n## Aviation share of the global (equivalent) carbon budget [%]\nprocess.parameters.aviation_carbon_budget_allocated_share = 2.6\nprocess.parameters.aviation_equivalentcarbonbudget_allocated_share = 5.1\n\n## Aviation share of the global energy resources (biomass and electricity) [%]\n# process.parameters.aviation_biomass_allocated_share = 5.0\n# process.parameters.aviation_electricity_allocated_share = 5.0\n</pre> # Allocation settings  ## Aviation share of the global (equivalent) carbon budget [%] process.parameters.aviation_carbon_budget_allocated_share = 2.6 process.parameters.aviation_equivalentcarbonbudget_allocated_share = 5.1  ## Aviation share of the global energy resources (biomass and electricity) [%] # process.parameters.aviation_biomass_allocated_share = 5.0 # process.parameters.aviation_electricity_allocated_share = 5.0 In\u00a0[\u00a0]: Copied! <pre>import time\n\nt1 = time.time()\nprocess.compute()\nprint(time.time() - t1)\nprocess.write_json()\n</pre> import time  t1 = time.time() process.compute() print(time.time() - t1) process.write_json() In\u00a0[\u00a0]: Copied! <pre>process.data[\"float_outputs\"]\n</pre> process.data[\"float_outputs\"] In\u00a0[\u00a0]: Copied! <pre>process.data[\"vector_outputs\"]\n</pre> process.data[\"vector_outputs\"] In\u00a0[\u00a0]: Copied! <pre>process.data[\"climate_outputs\"][[\"co2_emissions\"]]\n</pre> process.data[\"climate_outputs\"][[\"co2_emissions\"]] <p>The user can write the results to an Excel file with the following command.</p> In\u00a0[\u00a0]: Copied! <pre>process.write_excel(file_name=\"aeromaps_data.xlsx\")\n</pre> process.write_excel(file_name=\"aeromaps_data.xlsx\") In\u00a0[\u00a0]: Copied! <pre>process.list_available_plots()\n</pre> process.list_available_plots() <p>The user can thus display a figure of this list, for instance the CO<sub>2</sub> emissions of the simulated scenario.</p> In\u00a0[\u00a0]: Copied! <pre>process.plot(\"air_transport_co2_emissions\", save=False)\n</pre> process.plot(\"air_transport_co2_emissions\", save=False) In\u00a0[\u00a0]: Copied! <pre># Verify the outputs between .outputs.json and data/reference/outputs.json\nfrom aeromaps.utils.functions import compare_json_files\n\nfiles_are_different = compare_json_files(\n    \"./data/reference/outputs.json\",\n    \"./data/outputs.json\",\n    rtol=0.0001,\n    atol=0,\n)\n\nif files_are_different:\n    raise ValueError(\"The outputs.json files are different.\")\n</pre> # Verify the outputs between .outputs.json and data/reference/outputs.json from aeromaps.utils.functions import compare_json_files  files_are_different = compare_json_files(     \"./data/reference/outputs.json\",     \"./data/outputs.json\",     rtol=0.0001,     atol=0, )  if files_are_different:     raise ValueError(\"The outputs.json files are different.\") In\u00a0[\u00a0]: Copied! <pre>from aeromaps.utils.functions import clean_notebooks_on_tests\n\nclean_notebooks_on_tests(globals())\n</pre> from aeromaps.utils.functions import clean_notebooks_on_tests  clean_notebooks_on_tests(globals())"},{"location":"notebooks/examples_basic/#basic-example-for-using-aeromaps-with-jupyter-notebook","title":"Basic example for using AeroMAPS with Jupyter Notebook\u00b6","text":"<p>This document represents both an example and a tutorial for using the basic functions of AeroMAPS to simulate and evaluate a transition scenario for the aviation sector.  It is written in the form of a Jupyter Notebook to facilitate its use. The user will be able to adapt this notebook and couple it with other notebooks proposed in the documentation.</p>"},{"location":"notebooks/examples_basic/#load-and-process","title":"Load and process\u00b6","text":"<p>First, the user has to load the framework and generate a process.</p>"},{"location":"notebooks/examples_basic/#set-up-variables","title":"Set up variables\u00b6","text":"<p>The user can then set the different parameters of the model to generate its scenario. The list of the float inputs can be displayed using this command.</p>"},{"location":"notebooks/examples_basic/#compute","title":"Compute\u00b6","text":"<p>Once all the parameters have been set up, the user can compute.</p>"},{"location":"notebooks/examples_basic/#results","title":"Results\u00b6","text":"<p>The user can then display the results. The user has access to float outputs but also to annual data outputs, with the possibility of choosing the output.</p>"},{"location":"notebooks/examples_basic/#plots","title":"Plots\u00b6","text":"<p>Lastly, the user can also plot different parameters based on a database of plots. The list of the available plots can be displayed using the following command.</p>"}]}